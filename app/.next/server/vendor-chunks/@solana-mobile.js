/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana-mobile";
exports.ids = ["vendor-chunks/@solana-mobile"];
exports.modules = {

/***/ "(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/eventemitter3/index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/eventemitter3/index.js ***!
  \***********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsZ0JBQWdCLFlBQVk7QUFDNUI7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQsZ0VBQWdFO0FBQ2hFLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEU7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUE2QjtBQUNqQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVuLWZvcnR1bmUtY29va2llLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEtbW9iaWxlL3dhbGxldC1hZGFwdGVyLW1vYmlsZS9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcz9jZmI0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/eventemitter3/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/wallet-standard-mobile/node_modules/base-x/src/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/wallet-standard-mobile/node_modules/base-x/src/index.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LXN0YW5kYXJkLW1vYmlsZS9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkNBQTZDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwrQkFBK0IsNkNBQTZDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVuLWZvcnR1bmUtY29va2llLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEtbW9iaWxlL3dhbGxldC1zdGFuZGFyZC1tb2JpbGUvbm9kZV9tb2R1bGVzL2Jhc2UteC9zcmMvaW5kZXguanM/Yjc0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8vIGJhc2UteCBlbmNvZGluZyAvIGRlY29kaW5nXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTggYmFzZS14IGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTggVGhlIEJpdGNvaW4gQ29yZSBkZXZlbG9wZXJzIChiYXNlNTguY3BwKVxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBMSUNFTlNFIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuZnVuY3Rpb24gYmFzZSAoQUxQSEFCRVQpIHtcbiAgaWYgKEFMUEhBQkVULmxlbmd0aCA+PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxwaGFiZXQgdG9vIGxvbmcnKSB9XG4gIHZhciBCQVNFX01BUCA9IG5ldyBVaW50OEFycmF5KDI1NilcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBCQVNFX01BUC5sZW5ndGg7IGorKykge1xuICAgIEJBU0VfTUFQW2pdID0gMjU1XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KGkpXG4gICAgdmFyIHhjID0geC5jaGFyQ29kZUF0KDApXG4gICAgaWYgKEJBU0VfTUFQW3hjXSAhPT0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgYW1iaWd1b3VzJykgfVxuICAgIEJBU0VfTUFQW3hjXSA9IGlcbiAgfVxuICB2YXIgQkFTRSA9IEFMUEhBQkVULmxlbmd0aFxuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApXG4gIHZhciBGQUNUT1IgPSBNYXRoLmxvZyhCQVNFKSAvIE1hdGgubG9nKDI1NikgLy8gbG9nKEJBU0UpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXBcbiAgdmFyIGlGQUNUT1IgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2coQkFTRSkgLy8gbG9nKDI1NikgLyBsb2coQkFTRSksIHJvdW5kZWQgdXBcbiAgZnVuY3Rpb24gZW5jb2RlIChzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlID0gVWludDhBcnJheS5mcm9tKHNvdXJjZSlcbiAgICB9XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJycgfVxuICAgICAgICAvLyBTa2lwICYgY291bnQgbGVhZGluZyB6ZXJvZXMuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHZhciBwYmVnaW4gPSAwXG4gICAgdmFyIHBlbmQgPSBzb3VyY2UubGVuZ3RoXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCAmJiBzb3VyY2VbcGJlZ2luXSA9PT0gMCkge1xuICAgICAgcGJlZ2luKytcbiAgICAgIHplcm9lcysrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlNTggcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKHBlbmQgLSBwYmVnaW4pICogaUZBQ1RPUiArIDEpID4+PiAwXG4gICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGJ5dGVzLlxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtwYmVnaW5dXG4gICAgICAgICAgICAvLyBBcHBseSBcImI1OCA9IGI1OCAqIDI1NiArIGNoXCIuXG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MSAhPT0gLTEpOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9ICgyNTYgKiBiNThbaXQxXSkgPj4+IDBcbiAgICAgICAgYjU4W2l0MV0gPSAoY2FycnkgJSBCQVNFKSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBiZWdpbisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGJhc2U1OCByZXN1bHQuXG4gICAgdmFyIGl0MiA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICBpdDIrK1xuICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIHRoZSByZXN1bHQgaW50byBhIHN0cmluZy5cbiAgICB2YXIgc3RyID0gTEVBREVSLnJlcGVhdCh6ZXJvZXMpXG4gICAgZm9yICg7IGl0MiA8IHNpemU7ICsraXQyKSB7IHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoYjU4W2l0Ml0pIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgU3RyaW5nJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiBuZXcgVWludDhBcnJheSgpIH1cbiAgICB2YXIgcHN6ID0gMFxuICAgICAgICAvLyBTa2lwIGFuZCBjb3VudCBsZWFkaW5nICcxJ3MuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSA9PT0gTEVBREVSKSB7XG4gICAgICB6ZXJvZXMrK1xuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2UyNTYgcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKChzb3VyY2UubGVuZ3RoIC0gcHN6KSAqIEZBQ1RPUikgKyAxKSA+Pj4gMCAvLyBsb2coNTgpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXAuXG4gICAgdmFyIGIyNTYgPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGFyYWN0ZXJzLlxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSkge1xuICAgICAgICAgICAgLy8gRmluZCBjb2RlIG9mIG5leHQgY2hhcmFjdGVyXG4gICAgICB2YXIgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwc3opXG4gICAgICAgICAgICAvLyBCYXNlIG1hcCBjYW4gbm90IGJlIGluZGV4ZWQgdXNpbmcgY2hhciBjb2RlXG4gICAgICBpZiAoY2hhckNvZGUgPiAyNTUpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW2NoYXJDb2RlXVxuICAgICAgICAgICAgLy8gSW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7IHJldHVybiB9XG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMFxuICAgICAgICBiMjU2W2l0M10gPSAoY2FycnkgJSAyNTYpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gMjU2KSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiMjU2LlxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrXG4gICAgfVxuICAgIHZhciB2Y2ggPSBuZXcgVWludDhBcnJheSh6ZXJvZXMgKyAoc2l6ZSAtIGl0NCkpXG4gICAgdmFyIGogPSB6ZXJvZXNcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdXG4gICAgfVxuICAgIHJldHVybiB2Y2hcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIHZhciBidWZmZXIgPSBkZWNvZGVVbnNhZmUoc3RyaW5nKVxuICAgIGlmIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlciB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/wallet-standard-mobile/node_modules/base-x/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/wallet-standard-mobile/node_modules/bs58/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/wallet-standard-mobile/node_modules/bs58/index.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const basex = __webpack_require__(/*! base-x */ \"(ssr)/./node_modules/@solana-mobile/wallet-standard-mobile/node_modules/base-x/src/index.js\")\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LXN0YW5kYXJkLW1vYmlsZS9ub2RlX21vZHVsZXMvYnM1OC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsMkdBQVE7QUFDOUI7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZW4tZm9ydHVuZS1jb29raWUvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LXN0YW5kYXJkLW1vYmlsZS9ub2RlX21vZHVsZXMvYnM1OC9pbmRleC5qcz85MGNmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJhc2V4ID0gcmVxdWlyZSgnYmFzZS14JylcbmNvbnN0IEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZXgoQUxQSEFCRVQpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/wallet-standard-mobile/node_modules/bs58/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LocalSolanaMobileWalletAdapter: () => (/* binding */ LocalSolanaMobileWalletAdapter),\n/* harmony export */   RemoteSolanaMobileWalletAdapter: () => (/* binding */ RemoteSolanaMobileWalletAdapter),\n/* harmony export */   SolanaMobileWalletAdapter: () => (/* binding */ SolanaMobileWalletAdapter),\n/* harmony export */   SolanaMobileWalletAdapterRemoteWalletName: () => (/* binding */ SolanaMobileWalletAdapterRemoteWalletName),\n/* harmony export */   SolanaMobileWalletAdapterWalletName: () => (/* binding */ SolanaMobileWalletAdapterWalletName),\n/* harmony export */   createDefaultAddressSelector: () => (/* binding */ createDefaultAddressSelector),\n/* harmony export */   createDefaultAuthorizationResultCache: () => (/* binding */ createDefaultAuthorizationResultCache),\n/* harmony export */   createDefaultWalletNotFoundHandler: () => (/* binding */ createDefaultWalletNotFoundHandler)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/signer.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signIn.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js\");\n/* harmony import */ var _solana_mobile_wallet_standard_mobile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana-mobile/wallet-standard-mobile */ \"(ssr)/./node_modules/@solana-mobile/wallet-standard-mobile/lib/esm/index.js\");\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\n\n( false) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\n( false) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\n/** Name of the feature. */\nconst StandardConnect = 'standard:connect';\n\n/** Name of the feature. */\nconst StandardDisconnect = 'standard:disconnect';\n\n/** Name of the feature. */\nconst StandardEvents = 'standard:events';\n\n( false) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\n( false) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\n( false) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\n( false) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nfunction fromUint8Array(byteArray) {\n    return window.btoa(String.fromCharCode.call(null, ...byteArray));\n}\n\nfunction getIsSupported() {\n    return (typeof window !== 'undefined' &&\n        window.isSecureContext &&\n        typeof document !== 'undefined' &&\n        /android/i.test(navigator.userAgent));\n}\n\nvar _BaseSolanaMobileWalletAdapter_instances, _BaseSolanaMobileWalletAdapter_wallet, _BaseSolanaMobileWalletAdapter_connecting, _BaseSolanaMobileWalletAdapter_readyState, _BaseSolanaMobileWalletAdapter_accountSelector, _BaseSolanaMobileWalletAdapter_selectedAccount, _BaseSolanaMobileWalletAdapter_publicKey, _BaseSolanaMobileWalletAdapter_handleChangeEvent, _BaseSolanaMobileWalletAdapter_connect, _BaseSolanaMobileWalletAdapter_declareWalletAsInstalled, _BaseSolanaMobileWalletAdapter_assertIsAuthorized, _BaseSolanaMobileWalletAdapter_performSignTransactions, _BaseSolanaMobileWalletAdapter_runWithGuard;\nconst SolanaMobileWalletAdapterWalletName = _solana_mobile_wallet_standard_mobile__WEBPACK_IMPORTED_MODULE_1__.SolanaMobileWalletAdapterWalletName;\nconst SolanaMobileWalletAdapterRemoteWalletName = _solana_mobile_wallet_standard_mobile__WEBPACK_IMPORTED_MODULE_1__.SolanaMobileWalletAdapterRemoteWalletName;\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nfunction isVersionedTransaction(transaction) {\n    return 'version' in transaction;\n}\nfunction chainOrClusterToChainId(chain) {\n    switch (chain) {\n        case 'mainnet-beta':\n            return 'solana:mainnet';\n        case 'testnet':\n            return 'solana:testnet';\n        case 'devnet':\n            return 'solana:devnet';\n        default:\n            return chain;\n    }\n}\nclass BaseSolanaMobileWalletAdapter extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.BaseSignInMessageSignerWalletAdapter {\n    constructor(wallet, config) {\n        super();\n        _BaseSolanaMobileWalletAdapter_instances.add(this);\n        this.supportedTransactionVersions = new Set(\n        // FIXME(#244): We can't actually know what versions are supported until we know which wallet we're talking to.\n        ['legacy', 0]);\n        _BaseSolanaMobileWalletAdapter_wallet.set(this, void 0);\n        _BaseSolanaMobileWalletAdapter_connecting.set(this, false);\n        _BaseSolanaMobileWalletAdapter_readyState.set(this, getIsSupported() ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Loadable : _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Unsupported);\n        _BaseSolanaMobileWalletAdapter_accountSelector.set(this, void 0);\n        _BaseSolanaMobileWalletAdapter_selectedAccount.set(this, void 0);\n        _BaseSolanaMobileWalletAdapter_publicKey.set(this, void 0);\n        _BaseSolanaMobileWalletAdapter_handleChangeEvent.set(this, (properties) => __awaiter(this, void 0, void 0, function* () {\n            if (properties.accounts && properties.accounts.length > 0) {\n                __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_declareWalletAsInstalled).call(this);\n                const nextSelectedAccount = yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_accountSelector, \"f\").call(this, properties.accounts);\n                if (nextSelectedAccount !== __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_selectedAccount, \"f\")) {\n                    __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_selectedAccount, nextSelectedAccount, \"f\");\n                    __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_publicKey, undefined, \"f\");\n                    this.emit('connect', \n                    // Having just set `this.#selectedAccount`, `this.publicKey` is definitely non-null\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    this.publicKey);\n                }\n            }\n        }));\n        // this.#chain = chainOrClusterToChainId(config.chain);\n        __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_accountSelector, (accounts) => __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const selectedBase64EncodedAddress = yield config.addressSelector.select(accounts.map(({ publicKey }) => fromUint8Array(publicKey)));\n            return (_a = accounts.find(({ publicKey }) => fromUint8Array(publicKey) === selectedBase64EncodedAddress)) !== null && _a !== void 0 ? _a : accounts[0];\n        }), \"f\");\n        __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_wallet, wallet, \"f\");\n        __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[StandardEvents].on('change', __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_handleChangeEvent, \"f\"));\n        this.name = __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").name;\n        this.icon = __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").icon;\n        this.url = __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").url;\n        // TODO: evaluate if this logic should be kept - it seems to create a nasty bug where \n        //  the wallet tries to auto connect on page load and gets blocked by the popup blocker\n        // if (this.#readyState !== WalletReadyState.Unsupported) {\n        //     config.authorizationResultCache.get().then((authorizationResult) => {\n        //         if (authorizationResult) {\n        //             // Having a prior authorization result is, right now, the best\n        //             // indication that a mobile wallet is installed. There is no API\n        //             // we can use to test for whether the association URI is supported.\n        //             this.#declareWalletAsInstalled();\n        //         }\n        //     });\n        // }\n    }\n    get publicKey() {\n        var _a;\n        if (!__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_publicKey, \"f\") && __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_selectedAccount, \"f\")) {\n            try {\n                __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_publicKey, new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_selectedAccount, \"f\").publicKey), \"f\");\n            }\n            catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletPublicKeyError((e instanceof Error && (e === null || e === void 0 ? void 0 : e.message)) || 'Unknown error', e);\n            }\n        }\n        return (_a = __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_publicKey, \"f\")) !== null && _a !== void 0 ? _a : null;\n    }\n    get connected() {\n        return __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").connected;\n    }\n    get connecting() {\n        return __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_connecting, \"f\");\n    }\n    get readyState() {\n        return __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_readyState, \"f\");\n    }\n    /** @deprecated Use `autoConnect()` instead. */\n    autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.autoConnect();\n        });\n    }\n    autoConnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_connect).call(this, true);\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_connect).call(this);\n        });\n    }\n    /** @deprecated Use `connect()` or `autoConnect()` instead. */\n    performAuthorization(signInPayload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const cachedAuthorizationResult = yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").cachedAuthorizationResult;\n                if (cachedAuthorizationResult) {\n                    yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[StandardConnect].connect({ silent: true });\n                    return cachedAuthorizationResult;\n                }\n                if (signInPayload) {\n                    yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__.SolanaSignIn].signIn(signInPayload);\n                }\n                else\n                    yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[StandardConnect].connect();\n                const authorizationResult = yield yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").cachedAuthorizationResult;\n                return authorizationResult;\n            }\n            catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // return await this.#runWithGuard(this.#wallet.features[StandardDisconnect].disconnect);\n            return yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_runWithGuard).call(this, () => __awaiter(this, void 0, void 0, function* () {\n                __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_connecting, false, \"f\");\n                __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_publicKey, undefined, \"f\");\n                __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_selectedAccount, undefined, \"f\");\n                yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[StandardDisconnect].disconnect();\n                this.emit('disconnect');\n            }));\n        });\n    }\n    signIn(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_runWithGuard).call(this, () => __awaiter(this, void 0, void 0, function* () {\n                var _a;\n                if (__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_readyState, \"f\") !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed && __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_readyState, \"f\") !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Loadable) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletNotReadyError();\n                }\n                __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_connecting, true, \"f\");\n                try {\n                    const outputs = yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__.SolanaSignIn].signIn(Object.assign(Object.assign({}, input), { domain: (_a = input === null || input === void 0 ? void 0 : input.domain) !== null && _a !== void 0 ? _a : window.location.host }));\n                    if (outputs.length > 0) {\n                        return outputs[0];\n                    }\n                    else {\n                        throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n                    }\n                }\n                catch (e) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n                }\n                finally {\n                    __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_connecting, false, \"f\");\n                }\n            }));\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_runWithGuard).call(this, () => __awaiter(this, void 0, void 0, function* () {\n                const account = __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_assertIsAuthorized).call(this);\n                try {\n                    const outputs = yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignMessage].signMessage({\n                        account, message: message\n                    });\n                    return outputs[0].signature;\n                }\n                catch (error) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }));\n        });\n    }\n    sendTransaction(transaction, connection, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_runWithGuard).call(this, () => __awaiter(this, void 0, void 0, function* () {\n                const account = __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_assertIsAuthorized).call(this);\n                try {\n                    function getTargetCommitment() {\n                        let targetCommitment;\n                        switch (connection.commitment) {\n                            case 'confirmed':\n                            case 'finalized':\n                            case 'processed':\n                                targetCommitment = connection.commitment;\n                                break;\n                            default:\n                                targetCommitment = 'finalized';\n                        }\n                        let targetPreflightCommitment;\n                        switch (options === null || options === void 0 ? void 0 : options.preflightCommitment) {\n                            case 'confirmed':\n                            case 'finalized':\n                            case 'processed':\n                                targetPreflightCommitment = options.preflightCommitment;\n                                break;\n                            case undefined:\n                                targetPreflightCommitment = targetCommitment;\n                                break;\n                            default:\n                                targetPreflightCommitment = 'finalized';\n                        }\n                        const preflightCommitmentScore = targetPreflightCommitment === 'finalized'\n                            ? 2\n                            : targetPreflightCommitment === 'confirmed'\n                                ? 1\n                                : 0;\n                        const targetCommitmentScore = targetCommitment === 'finalized' ? 2 : targetCommitment === 'confirmed' ? 1 : 0;\n                        return preflightCommitmentScore < targetCommitmentScore\n                            ? targetPreflightCommitment\n                            : targetCommitment;\n                    }\n                    if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignAndSendTransaction in __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features) {\n                        const chain = chainOrClusterToChainId(__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").currentAuthorization.chain);\n                        const [signature] = (yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignAndSendTransaction].signAndSendTransaction({\n                            account,\n                            transaction: transaction.serialize(),\n                            chain: chain,\n                            options: options ? {\n                                skipPreflight: options.skipPreflight,\n                                maxRetries: options.maxRetries\n                            } : undefined\n                        })).map(((output) => {\n                            return fromUint8Array(output.signature);\n                        }));\n                        return signature;\n                    }\n                    else {\n                        const [signedTransaction] = yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_performSignTransactions).call(this, [transaction]);\n                        if (isVersionedTransaction(signedTransaction)) {\n                            return yield connection.sendTransaction(signedTransaction);\n                        }\n                        else {\n                            const serializedTransaction = signedTransaction.serialize();\n                            return yield connection.sendRawTransaction(serializedTransaction, Object.assign(Object.assign({}, options), { preflightCommitment: getTargetCommitment() }));\n                        }\n                    }\n                }\n                catch (error) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }));\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_runWithGuard).call(this, () => __awaiter(this, void 0, void 0, function* () {\n                const [signedTransaction] = yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_performSignTransactions).call(this, [transaction]);\n                return signedTransaction;\n            }));\n        });\n    }\n    signAllTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_runWithGuard).call(this, () => __awaiter(this, void 0, void 0, function* () {\n                const signedTransactions = yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_performSignTransactions).call(this, transactions);\n                return signedTransactions;\n            }));\n        });\n    }\n}\n_BaseSolanaMobileWalletAdapter_wallet = new WeakMap(), _BaseSolanaMobileWalletAdapter_connecting = new WeakMap(), _BaseSolanaMobileWalletAdapter_readyState = new WeakMap(), _BaseSolanaMobileWalletAdapter_accountSelector = new WeakMap(), _BaseSolanaMobileWalletAdapter_selectedAccount = new WeakMap(), _BaseSolanaMobileWalletAdapter_publicKey = new WeakMap(), _BaseSolanaMobileWalletAdapter_handleChangeEvent = new WeakMap(), _BaseSolanaMobileWalletAdapter_instances = new WeakSet(), _BaseSolanaMobileWalletAdapter_connect = function _BaseSolanaMobileWalletAdapter_connect(autoConnect = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (this.connecting || this.connected) {\n            return;\n        }\n        return yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_runWithGuard).call(this, () => __awaiter(this, void 0, void 0, function* () {\n            if (__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_readyState, \"f\") !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed && __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_readyState, \"f\") !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Loadable) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletNotReadyError();\n            }\n            __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_connecting, true, \"f\");\n            try {\n                yield __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[StandardConnect].connect({ silent: autoConnect });\n            }\n            catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n            }\n            finally {\n                __classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_connecting, false, \"f\");\n            }\n        }));\n    });\n}, _BaseSolanaMobileWalletAdapter_declareWalletAsInstalled = function _BaseSolanaMobileWalletAdapter_declareWalletAsInstalled() {\n    if (__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_readyState, \"f\") !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed) {\n        this.emit('readyStateChange', (__classPrivateFieldSet(this, _BaseSolanaMobileWalletAdapter_readyState, _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed, \"f\")));\n    }\n}, _BaseSolanaMobileWalletAdapter_assertIsAuthorized = function _BaseSolanaMobileWalletAdapter_assertIsAuthorized() {\n    if (!__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").isAuthorized || !__classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_selectedAccount, \"f\"))\n        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletNotConnectedError();\n    return __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_selectedAccount, \"f\");\n}, _BaseSolanaMobileWalletAdapter_performSignTransactions = function _BaseSolanaMobileWalletAdapter_performSignTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const account = __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_instances, \"m\", _BaseSolanaMobileWalletAdapter_assertIsAuthorized).call(this);\n        try {\n            if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_8__.SolanaSignTransaction in __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features) {\n                return __classPrivateFieldGet(this, _BaseSolanaMobileWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_8__.SolanaSignTransaction].signTransaction(...transactions.map((value) => {\n                    return { account, transaction: value.serialize() };\n                })).then((outputs) => {\n                    return outputs.map((output) => {\n                        const byteArray = output.signedTransaction;\n                        const numSignatures = byteArray[0];\n                        const messageOffset = numSignatures * SIGNATURE_LENGTH_IN_BYTES + 1;\n                        const version = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedMessage.deserializeMessageVersion(byteArray.slice(messageOffset, byteArray.length));\n                        if (version === 'legacy') {\n                            return _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.from(byteArray);\n                        }\n                        else {\n                            return _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedTransaction.deserialize(byteArray);\n                        }\n                    });\n                });\n            }\n            else {\n                throw new Error('Connected wallet does not support signing transactions');\n            }\n        }\n        catch (error) {\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n    });\n}, _BaseSolanaMobileWalletAdapter_runWithGuard = function _BaseSolanaMobileWalletAdapter_runWithGuard(callback) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            return yield callback();\n        }\n        catch (e) {\n            this.emit('error', e);\n            throw e;\n        }\n    });\n};\nclass LocalSolanaMobileWalletAdapter extends BaseSolanaMobileWalletAdapter {\n    constructor(config) {\n        var _a;\n        const chain = chainOrClusterToChainId((_a = config.chain) !== null && _a !== void 0 ? _a : config.cluster);\n        super(new _solana_mobile_wallet_standard_mobile__WEBPACK_IMPORTED_MODULE_1__.LocalSolanaMobileWalletAdapterWallet({\n            appIdentity: config.appIdentity,\n            authorizationCache: {\n                set: config.authorizationResultCache.set,\n                get: () => __awaiter(this, void 0, void 0, function* () {\n                    return yield config.authorizationResultCache.get();\n                }),\n                clear: config.authorizationResultCache.clear,\n            },\n            chains: [chain],\n            chainSelector: (0,_solana_mobile_wallet_standard_mobile__WEBPACK_IMPORTED_MODULE_1__.createDefaultChainSelector)(),\n            onWalletNotFound: () => __awaiter(this, void 0, void 0, function* () {\n                config.onWalletNotFound(this);\n            }),\n        }), {\n            addressSelector: config.addressSelector,\n            chain: chain,\n        });\n    }\n}\nclass RemoteSolanaMobileWalletAdapter extends BaseSolanaMobileWalletAdapter {\n    constructor(config) {\n        const chain = chainOrClusterToChainId(config.chain);\n        super(new _solana_mobile_wallet_standard_mobile__WEBPACK_IMPORTED_MODULE_1__.RemoteSolanaMobileWalletAdapterWallet({\n            appIdentity: config.appIdentity,\n            authorizationCache: {\n                set: config.authorizationResultCache.set,\n                get: () => __awaiter(this, void 0, void 0, function* () {\n                    return yield config.authorizationResultCache.get();\n                }),\n                clear: config.authorizationResultCache.clear,\n            },\n            chains: [chain],\n            chainSelector: (0,_solana_mobile_wallet_standard_mobile__WEBPACK_IMPORTED_MODULE_1__.createDefaultChainSelector)(),\n            remoteHostAuthority: config.remoteHostAuthority,\n            onWalletNotFound: () => __awaiter(this, void 0, void 0, function* () {\n                config.onWalletNotFound(this);\n            }),\n        }), {\n            addressSelector: config.addressSelector,\n            chain: chain,\n        });\n    }\n}\nclass SolanaMobileWalletAdapter extends LocalSolanaMobileWalletAdapter {\n}\n\nfunction createDefaultAddressSelector() {\n    return {\n        select(addresses) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return addresses[0];\n            });\n        },\n    };\n}\n\nfunction createDefaultAuthorizationResultCache() {\n    return (0,_solana_mobile_wallet_standard_mobile__WEBPACK_IMPORTED_MODULE_1__.createDefaultAuthorizationCache)();\n}\n\nfunction defaultWalletNotFoundHandler(mobileWalletAdapter) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return (0,_solana_mobile_wallet_standard_mobile__WEBPACK_IMPORTED_MODULE_1__.defaultErrorModalWalletNotFoundHandler)();\n    });\n}\nfunction createDefaultWalletNotFoundHandler() {\n    return defaultWalletNotFoundHandler;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ1I7QUFDL0s7QUFDdUM7QUFDeVE7O0FBRWpaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLE1BQTZDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLE1BQTZDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUMsTUFBNkM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsTUFBNkM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxNQUE2QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxNQUE2QztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLHNHQUFxQztBQUNqRixrREFBa0QsNEdBQTJDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZGQUFvQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHlFQUFnQixZQUFZLHlFQUFnQjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsV0FBVztBQUNoSCwwQ0FBMEMsV0FBVztBQUNyRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixzREFBUztBQUNwRztBQUNBO0FBQ0EsMEJBQTBCLDZFQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUlBQXVJLGNBQWM7QUFDcko7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLDBFQUFZO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhFQUFxQjtBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyx5RUFBZ0IsK0ZBQStGLHlFQUFnQjtBQUNwTyw4QkFBOEIsNEVBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCwwRUFBWSx1Q0FBdUMsWUFBWSxpSUFBaUk7QUFDNVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4RUFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCwrRUFBaUI7QUFDN0k7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtFQUFzQjtBQUNwRDtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEZBQTRCO0FBQ3BEO0FBQ0EscUlBQXFJLDBGQUE0QjtBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCxjQUFjLDRDQUE0QztBQUN0TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtRkFBMEI7QUFDeEQ7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLHlFQUFnQiwrRkFBK0YseUVBQWdCO0FBQ2hPLDBCQUEwQiw0RUFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsbUlBQW1JLHFCQUFxQjtBQUN4SjtBQUNBO0FBQ0EsMEJBQTBCLDhFQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQztBQUNELHlGQUF5Rix5RUFBZ0I7QUFDekcsK0dBQStHLHlFQUFnQjtBQUMvSDtBQUNBLENBQUM7QUFDRDtBQUNBLGtCQUFrQixnRkFBdUI7QUFDekM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1GQUFxQjtBQUNyQyx5R0FBeUcsbUZBQXFCO0FBQzlILDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkRBQWdCO0FBQ3hEO0FBQ0EsbUNBQW1DLHdEQUFXO0FBQzlDO0FBQ0E7QUFDQSxtQ0FBbUMsaUVBQW9CO0FBQ3ZEO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUZBQTBCO0FBQ2hEO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUdBQW9DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyQkFBMkIsaUdBQTBCO0FBQ3JEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3R0FBcUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLDJCQUEyQixpR0FBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHNHQUErQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0EsZUFBZSw2R0FBc0M7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUUrUiIsInNvdXJjZXMiOlsid2VicGFjazovL3plbi1mb3J0dW5lLWNvb2tpZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hLW1vYmlsZS93YWxsZXQtYWRhcHRlci1tb2JpbGUvbGliL2VzbS9pbmRleC5qcz8zZGNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VTaWduSW5NZXNzYWdlU2lnbmVyV2FsbGV0QWRhcHRlciwgV2FsbGV0UmVhZHlTdGF0ZSwgV2FsbGV0UHVibGljS2V5RXJyb3IsIFdhbGxldENvbm5lY3Rpb25FcnJvciwgV2FsbGV0Tm90UmVhZHlFcnJvciwgV2FsbGV0U2lnbk1lc3NhZ2VFcnJvciwgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IsIFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yLCBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZSc7XG5pbXBvcnQgeyBQdWJsaWNLZXksIFZlcnNpb25lZE1lc3NhZ2UsIFRyYW5zYWN0aW9uLCBWZXJzaW9uZWRUcmFuc2FjdGlvbiB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgeyBTb2xhbmFTaWduSW4sIFNvbGFuYVNpZ25NZXNzYWdlLCBTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uLCBTb2xhbmFTaWduVHJhbnNhY3Rpb24gfSBmcm9tICdAc29sYW5hL3dhbGxldC1zdGFuZGFyZC1mZWF0dXJlcyc7XG5pbXBvcnQgeyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZSBhcyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZSQxLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUmVtb3RlV2FsbGV0TmFtZSBhcyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUmVtb3RlV2FsbGV0TmFtZSQxLCBMb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXQsIGNyZWF0ZURlZmF1bHRDaGFpblNlbGVjdG9yLCBSZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0LCBjcmVhdGVEZWZhdWx0QXV0aG9yaXphdGlvbkNhY2hlLCBkZWZhdWx0RXJyb3JNb2RhbFdhbGxldE5vdEZvdW5kSGFuZGxlciB9IGZyb20gJ0Bzb2xhbmEtbW9iaWxlL3dhbGxldC1zdGFuZGFyZC1tb2JpbGUnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XG5cbih1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbih1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG5cbi8qKiBOYW1lIG9mIHRoZSBmZWF0dXJlLiAqL1xuY29uc3QgU3RhbmRhcmRDb25uZWN0ID0gJ3N0YW5kYXJkOmNvbm5lY3QnO1xuXG4vKiogTmFtZSBvZiB0aGUgZmVhdHVyZS4gKi9cbmNvbnN0IFN0YW5kYXJkRGlzY29ubmVjdCA9ICdzdGFuZGFyZDpkaXNjb25uZWN0JztcblxuLyoqIE5hbWUgb2YgdGhlIGZlYXR1cmUuICovXG5jb25zdCBTdGFuZGFyZEV2ZW50cyA9ICdzdGFuZGFyZDpldmVudHMnO1xuXG4odW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG4odW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xuXG4odW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG4odW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xuXG5mdW5jdGlvbiBmcm9tVWludDhBcnJheShieXRlQXJyYXkpIHtcbiAgICByZXR1cm4gd2luZG93LmJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZS5jYWxsKG51bGwsIC4uLmJ5dGVBcnJheSkpO1xufVxuXG5mdW5jdGlvbiBnZXRJc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHdpbmRvdy5pc1NlY3VyZUNvbnRleHQgJiZcbiAgICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvYW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpO1xufVxuXG52YXIgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3dhbGxldCwgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX2Nvbm5lY3RpbmcsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9yZWFkeVN0YXRlLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfYWNjb3VudFNlbGVjdG9yLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfc2VsZWN0ZWRBY2NvdW50LCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcHVibGljS2V5LCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfaGFuZGxlQ2hhbmdlRXZlbnQsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9jb25uZWN0LCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfZGVjbGFyZVdhbGxldEFzSW5zdGFsbGVkLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfYXNzZXJ0SXNBdXRob3JpemVkLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcGVyZm9ybVNpZ25UcmFuc2FjdGlvbnMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9ydW5XaXRoR3VhcmQ7XG5jb25zdCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZSA9IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lJDE7XG5jb25zdCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUmVtb3RlV2FsbGV0TmFtZSA9IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJSZW1vdGVXYWxsZXROYW1lJDE7XG5jb25zdCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTID0gNjQ7XG5mdW5jdGlvbiBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuICd2ZXJzaW9uJyBpbiB0cmFuc2FjdGlvbjtcbn1cbmZ1bmN0aW9uIGNoYWluT3JDbHVzdGVyVG9DaGFpbklkKGNoYWluKSB7XG4gICAgc3dpdGNoIChjaGFpbikge1xuICAgICAgICBjYXNlICdtYWlubmV0LWJldGEnOlxuICAgICAgICAgICAgcmV0dXJuICdzb2xhbmE6bWFpbm5ldCc7XG4gICAgICAgIGNhc2UgJ3Rlc3RuZXQnOlxuICAgICAgICAgICAgcmV0dXJuICdzb2xhbmE6dGVzdG5ldCc7XG4gICAgICAgIGNhc2UgJ2Rldm5ldCc6XG4gICAgICAgICAgICByZXR1cm4gJ3NvbGFuYTpkZXZuZXQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgIH1cbn1cbmNsYXNzIEJhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyIGV4dGVuZHMgQmFzZVNpZ25Jbk1lc3NhZ2VTaWduZXJXYWxsZXRBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih3YWxsZXQsIGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zID0gbmV3IFNldChcbiAgICAgICAgLy8gRklYTUUoIzI0NCk6IFdlIGNhbid0IGFjdHVhbGx5IGtub3cgd2hhdCB2ZXJzaW9ucyBhcmUgc3VwcG9ydGVkIHVudGlsIHdlIGtub3cgd2hpY2ggd2FsbGV0IHdlJ3JlIHRhbGtpbmcgdG8uXG4gICAgICAgIFsnbGVnYWN5JywgMF0pO1xuICAgICAgICBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfd2FsbGV0LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfY29ubmVjdGluZy5zZXQodGhpcywgZmFsc2UpO1xuICAgICAgICBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcmVhZHlTdGF0ZS5zZXQodGhpcywgZ2V0SXNTdXBwb3J0ZWQoKSA/IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUgOiBXYWxsZXRSZWFkeVN0YXRlLlVuc3VwcG9ydGVkKTtcbiAgICAgICAgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX2FjY291bnRTZWxlY3Rvci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3NlbGVjdGVkQWNjb3VudC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3B1YmxpY0tleS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX2hhbmRsZUNoYW5nZUV2ZW50LnNldCh0aGlzLCAocHJvcGVydGllcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuYWNjb3VudHMgJiYgcHJvcGVydGllcy5hY2NvdW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX2RlY2xhcmVXYWxsZXRBc0luc3RhbGxlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2VsZWN0ZWRBY2NvdW50ID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfYWNjb3VudFNlbGVjdG9yLCBcImZcIikuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzLmFjY291bnRzKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNlbGVjdGVkQWNjb3VudCAhPT0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfc2VsZWN0ZWRBY2NvdW50LCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfc2VsZWN0ZWRBY2NvdW50LCBuZXh0U2VsZWN0ZWRBY2NvdW50LCBcImZcIik7XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3B1YmxpY0tleSwgdW5kZWZpbmVkLCBcImZcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIFxuICAgICAgICAgICAgICAgICAgICAvLyBIYXZpbmcganVzdCBzZXQgYHRoaXMuI3NlbGVjdGVkQWNjb3VudGAsIGB0aGlzLnB1YmxpY0tleWAgaXMgZGVmaW5pdGVseSBub24tbnVsbFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY0tleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIHRoaXMuI2NoYWluID0gY2hhaW5PckNsdXN0ZXJUb0NoYWluSWQoY29uZmlnLmNoYWluKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfYWNjb3VudFNlbGVjdG9yLCAoYWNjb3VudHMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkQmFzZTY0RW5jb2RlZEFkZHJlc3MgPSB5aWVsZCBjb25maWcuYWRkcmVzc1NlbGVjdG9yLnNlbGVjdChhY2NvdW50cy5tYXAoKHsgcHVibGljS2V5IH0pID0+IGZyb21VaW50OEFycmF5KHB1YmxpY0tleSkpKTtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBhY2NvdW50cy5maW5kKCh7IHB1YmxpY0tleSB9KSA9PiBmcm9tVWludDhBcnJheShwdWJsaWNLZXkpID09PSBzZWxlY3RlZEJhc2U2NEVuY29kZWRBZGRyZXNzKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYWNjb3VudHNbMF07XG4gICAgICAgIH0pLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3dhbGxldCwgd2FsbGV0LCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1N0YW5kYXJkRXZlbnRzXS5vbignY2hhbmdlJywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfaGFuZGxlQ2hhbmdlRXZlbnQsIFwiZlwiKSk7XG4gICAgICAgIHRoaXMubmFtZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLm5hbWU7XG4gICAgICAgIHRoaXMuaWNvbiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmljb247XG4gICAgICAgIHRoaXMudXJsID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikudXJsO1xuICAgICAgICAvLyBUT0RPOiBldmFsdWF0ZSBpZiB0aGlzIGxvZ2ljIHNob3VsZCBiZSBrZXB0IC0gaXQgc2VlbXMgdG8gY3JlYXRlIGEgbmFzdHkgYnVnIHdoZXJlIFxuICAgICAgICAvLyAgdGhlIHdhbGxldCB0cmllcyB0byBhdXRvIGNvbm5lY3Qgb24gcGFnZSBsb2FkIGFuZCBnZXRzIGJsb2NrZWQgYnkgdGhlIHBvcHVwIGJsb2NrZXJcbiAgICAgICAgLy8gaWYgKHRoaXMuI3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuVW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgLy8gICAgIGNvbmZpZy5hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuZ2V0KCkudGhlbigoYXV0aG9yaXphdGlvblJlc3VsdCkgPT4ge1xuICAgICAgICAvLyAgICAgICAgIGlmIChhdXRob3JpemF0aW9uUmVzdWx0KSB7XG4gICAgICAgIC8vICAgICAgICAgICAgIC8vIEhhdmluZyBhIHByaW9yIGF1dGhvcml6YXRpb24gcmVzdWx0IGlzLCByaWdodCBub3csIHRoZSBiZXN0XG4gICAgICAgIC8vICAgICAgICAgICAgIC8vIGluZGljYXRpb24gdGhhdCBhIG1vYmlsZSB3YWxsZXQgaXMgaW5zdGFsbGVkLiBUaGVyZSBpcyBubyBBUElcbiAgICAgICAgLy8gICAgICAgICAgICAgLy8gd2UgY2FuIHVzZSB0byB0ZXN0IGZvciB3aGV0aGVyIHRoZSBhc3NvY2lhdGlvbiBVUkkgaXMgc3VwcG9ydGVkLlxuICAgICAgICAvLyAgICAgICAgICAgICB0aGlzLiNkZWNsYXJlV2FsbGV0QXNJbnN0YWxsZWQoKTtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICBnZXQgcHVibGljS2V5KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcHVibGljS2V5LCBcImZcIikgJiYgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfc2VsZWN0ZWRBY2NvdW50LCBcImZcIikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcHVibGljS2V5LCBuZXcgUHVibGljS2V5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3NlbGVjdGVkQWNjb3VudCwgXCJmXCIpLnB1YmxpY0tleSksIFwiZlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFB1YmxpY0tleUVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlKSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9hID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcHVibGljS2V5LCBcImZcIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5jb25uZWN0ZWQ7XG4gICAgfVxuICAgIGdldCBjb25uZWN0aW5nKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfY29ubmVjdGluZywgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3JlYWR5U3RhdGUsIFwiZlwiKTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBgYXV0b0Nvbm5lY3QoKWAgaW5zdGVhZC4gKi9cbiAgICBhdXRvQ29ubmVjdF9ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuYXV0b0Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF1dG9Db25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX2Nvbm5lY3QpLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX2Nvbm5lY3QpLmNhbGwodGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIGBjb25uZWN0KClgIG9yIGBhdXRvQ29ubmVjdCgpYCBpbnN0ZWFkLiAqL1xuICAgIHBlcmZvcm1BdXRob3JpemF0aW9uKHNpZ25JblBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXNbU3RhbmRhcmRDb25uZWN0XS5jb25uZWN0KHsgc2lsZW50OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25JblBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXNbU29sYW5hU2lnbkluXS5zaWduSW4oc2lnbkluUGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXNbU3RhbmRhcmRDb25uZWN0XS5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGF3YWl0IHRoaXMuI3J1bldpdGhHdWFyZCh0aGlzLiN3YWxsZXQuZmVhdHVyZXNbU3RhbmRhcmREaXNjb25uZWN0XS5kaXNjb25uZWN0KTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcnVuV2l0aEd1YXJkKS5jYWxsKHRoaXMsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9jb25uZWN0aW5nLCBmYWxzZSwgXCJmXCIpO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3B1YmxpY0tleSwgdW5kZWZpbmVkLCBcImZcIik7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfc2VsZWN0ZWRBY2NvdW50LCB1bmRlZmluZWQsIFwiZlwiKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTdGFuZGFyZERpc2Nvbm5lY3RdLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25JbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9ydW5XaXRoR3VhcmQpLmNhbGwodGhpcywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcmVhZHlTdGF0ZSwgXCJmXCIpICE9PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCAmJiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9yZWFkeVN0YXRlLCBcImZcIikgIT09IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFJlYWR5RXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfY29ubmVjdGluZywgdHJ1ZSwgXCJmXCIpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dHMgPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTb2xhbmFTaWduSW5dLnNpZ25JbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGlucHV0KSwgeyBkb21haW46IChfYSA9IGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnB1dC5kb21haW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5sb2NhdGlvbi5ob3N0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dHNbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWduIGluIGZhaWxlZCwgbm8gc2lnbiBpbiByZXN1bHQgcmV0dXJuZWQgYnkgd2FsbGV0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9jb25uZWN0aW5nLCBmYWxzZSwgXCJmXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcnVuV2l0aEd1YXJkKS5jYWxsKHRoaXMsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX2Fzc2VydElzQXV0aG9yaXplZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXNbU29sYW5hU2lnbk1lc3NhZ2VdLnNpZ25NZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnQsIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXRzWzBdLnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduTWVzc2FnZUVycm9yKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3J1bldpdGhHdWFyZCkuY2FsbCh0aGlzLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9hc3NlcnRJc0F1dGhvcml6ZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VGFyZ2V0Q29tbWl0bWVudCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb25uZWN0aW9uLmNvbW1pdG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmFsaXplZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tbWl0bWVudCA9IGNvbm5lY3Rpb24uY29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tbWl0bWVudCA9ICdmaW5hbGl6ZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQgPSBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50ID0gdGFyZ2V0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9ICdmaW5hbGl6ZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZmxpZ2h0Q29tbWl0bWVudFNjb3JlID0gdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9PT0gJ2ZpbmFsaXplZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQgPT09ICdjb25maXJtZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRDb21taXRtZW50U2NvcmUgPSB0YXJnZXRDb21taXRtZW50ID09PSAnZmluYWxpemVkJyA/IDIgOiB0YXJnZXRDb21taXRtZW50ID09PSAnY29uZmlybWVkJyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWZsaWdodENvbW1pdG1lbnRTY29yZSA8IHRhcmdldENvbW1pdG1lbnRTY29yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGFyZ2V0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoU29sYW5hU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiBpbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhaW4gPSBjaGFpbk9yQ2x1c3RlclRvQ2hhaW5JZChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5jdXJyZW50QXV0aG9yaXphdGlvbi5jaGFpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbc2lnbmF0dXJlXSA9ICh5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uXS5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFByZWZsaWdodDogb3B0aW9ucy5za2lwUHJlZmxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhSZXRyaWVzOiBvcHRpb25zLm1heFJldHJpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkubWFwKCgob3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb21VaW50OEFycmF5KG91dHB1dC5zaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtzaWduZWRUcmFuc2FjdGlvbl0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcGVyZm9ybVNpZ25UcmFuc2FjdGlvbnMpLmNhbGwodGhpcywgW3RyYW5zYWN0aW9uXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWZXJzaW9uZWRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY29ubmVjdGlvbi5zZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gc2lnbmVkVHJhbnNhY3Rpb24uc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBwcmVmbGlnaHRDb21taXRtZW50OiBnZXRUYXJnZXRDb21taXRtZW50KCkgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcnVuV2l0aEd1YXJkKS5jYWxsKHRoaXMsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc2lnbmVkVHJhbnNhY3Rpb25dID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3BlcmZvcm1TaWduVHJhbnNhY3Rpb25zKS5jYWxsKHRoaXMsIFt0cmFuc2FjdGlvbl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbjtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25BbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3J1bldpdGhHdWFyZCkuY2FsbCh0aGlzLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb25zID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3BlcmZvcm1TaWduVHJhbnNhY3Rpb25zKS5jYWxsKHRoaXMsIHRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9ucztcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3dhbGxldCA9IG5ldyBXZWFrTWFwKCksIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9jb25uZWN0aW5nID0gbmV3IFdlYWtNYXAoKSwgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3JlYWR5U3RhdGUgPSBuZXcgV2Vha01hcCgpLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfYWNjb3VudFNlbGVjdG9yID0gbmV3IFdlYWtNYXAoKSwgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3NlbGVjdGVkQWNjb3VudCA9IG5ldyBXZWFrTWFwKCksIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9wdWJsaWNLZXkgPSBuZXcgV2Vha01hcCgpLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfaGFuZGxlQ2hhbmdlRXZlbnQgPSBuZXcgV2Vha01hcCgpLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX2Nvbm5lY3QgPSBmdW5jdGlvbiBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfY29ubmVjdChhdXRvQ29ubmVjdCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGluZyB8fCB0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcnVuV2l0aEd1YXJkKS5jYWxsKHRoaXMsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9yZWFkeVN0YXRlLCBcImZcIikgIT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkICYmIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3JlYWR5U3RhdGUsIFwiZlwiKSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RSZWFkeUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9jb25uZWN0aW5nLCB0cnVlLCBcImZcIik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1N0YW5kYXJkQ29ubmVjdF0uY29ubmVjdCh7IHNpbGVudDogYXV0b0Nvbm5lY3QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9jb25uZWN0aW5nLCBmYWxzZSwgXCJmXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfSk7XG59LCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfZGVjbGFyZVdhbGxldEFzSW5zdGFsbGVkID0gZnVuY3Rpb24gX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX2RlY2xhcmVXYWxsZXRBc0luc3RhbGxlZCgpIHtcbiAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcmVhZHlTdGF0ZSwgXCJmXCIpICE9PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5U3RhdGVDaGFuZ2UnLCAoX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcmVhZHlTdGF0ZSwgV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQsIFwiZlwiKSkpO1xuICAgIH1cbn0sIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9hc3NlcnRJc0F1dGhvcml6ZWQgPSBmdW5jdGlvbiBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfYXNzZXJ0SXNBdXRob3JpemVkKCkge1xuICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuaXNBdXRob3JpemVkIHx8ICFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9zZWxlY3RlZEFjY291bnQsIFwiZlwiKSlcbiAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3NlbGVjdGVkQWNjb3VudCwgXCJmXCIpO1xufSwgX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3BlcmZvcm1TaWduVHJhbnNhY3Rpb25zID0gZnVuY3Rpb24gX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3BlcmZvcm1TaWduVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfYXNzZXJ0SXNBdXRob3JpemVkKS5jYWxsKHRoaXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKFNvbGFuYVNpZ25UcmFuc2FjdGlvbiBpbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTb2xhbmFTaWduVHJhbnNhY3Rpb25dLnNpZ25UcmFuc2FjdGlvbiguLi50cmFuc2FjdGlvbnMubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBhY2NvdW50LCB0cmFuc2FjdGlvbjogdmFsdWUuc2VyaWFsaXplKCkgfTtcbiAgICAgICAgICAgICAgICB9KSkudGhlbigob3V0cHV0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0cy5tYXAoKG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gb3V0cHV0LnNpZ25lZFRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtU2lnbmF0dXJlcyA9IGJ5dGVBcnJheVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VPZmZzZXQgPSBudW1TaWduYXR1cmVzICogU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uKGJ5dGVBcnJheS5zbGljZShtZXNzYWdlT2Zmc2V0LCBieXRlQXJyYXkubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gJ2xlZ2FjeScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShieXRlQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZlcnNpb25lZFRyYW5zYWN0aW9uLmRlc2VyaWFsaXplKGJ5dGVBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0ZWQgd2FsbGV0IGRvZXMgbm90IHN1cHBvcnQgc2lnbmluZyB0cmFuc2FjdGlvbnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcihlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59LCBfQmFzZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJfcnVuV2l0aEd1YXJkID0gZnVuY3Rpb24gX0Jhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyX3J1bldpdGhHdWFyZChjYWxsYmFjaykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNsYXNzIExvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlciBleHRlbmRzIEJhc2VTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjaGFpbiA9IGNoYWluT3JDbHVzdGVyVG9DaGFpbklkKChfYSA9IGNvbmZpZy5jaGFpbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uZmlnLmNsdXN0ZXIpO1xuICAgICAgICBzdXBlcihuZXcgTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0KHtcbiAgICAgICAgICAgIGFwcElkZW50aXR5OiBjb25maWcuYXBwSWRlbnRpdHksXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uQ2FjaGU6IHtcbiAgICAgICAgICAgICAgICBzZXQ6IGNvbmZpZy5hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuc2V0LFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY29uZmlnLmF1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5nZXQoKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjbGVhcjogY29uZmlnLmF1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5jbGVhcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFpbnM6IFtjaGFpbl0sXG4gICAgICAgICAgICBjaGFpblNlbGVjdG9yOiBjcmVhdGVEZWZhdWx0Q2hhaW5TZWxlY3RvcigpLFxuICAgICAgICAgICAgb25XYWxsZXROb3RGb3VuZDogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5vbldhbGxldE5vdEZvdW5kKHRoaXMpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhZGRyZXNzU2VsZWN0b3I6IGNvbmZpZy5hZGRyZXNzU2VsZWN0b3IsXG4gICAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFJlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXIgZXh0ZW5kcyBCYXNlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNoYWluID0gY2hhaW5PckNsdXN0ZXJUb0NoYWluSWQoY29uZmlnLmNoYWluKTtcbiAgICAgICAgc3VwZXIobmV3IFJlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXQoe1xuICAgICAgICAgICAgYXBwSWRlbnRpdHk6IGNvbmZpZy5hcHBJZGVudGl0eSxcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25DYWNoZToge1xuICAgICAgICAgICAgICAgIHNldDogY29uZmlnLmF1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5zZXQsXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjb25maWcuYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLmdldCgpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNsZWFyOiBjb25maWcuYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLmNsZWFyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYWluczogW2NoYWluXSxcbiAgICAgICAgICAgIGNoYWluU2VsZWN0b3I6IGNyZWF0ZURlZmF1bHRDaGFpblNlbGVjdG9yKCksXG4gICAgICAgICAgICByZW1vdGVIb3N0QXV0aG9yaXR5OiBjb25maWcucmVtb3RlSG9zdEF1dGhvcml0eSxcbiAgICAgICAgICAgIG9uV2FsbGV0Tm90Rm91bmQ6ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25maWcub25XYWxsZXROb3RGb3VuZCh0aGlzKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgYWRkcmVzc1NlbGVjdG9yOiBjb25maWcuYWRkcmVzc1NlbGVjdG9yLFxuICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyIGV4dGVuZHMgTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyIHtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdEFkZHJlc3NTZWxlY3RvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3QoYWRkcmVzc2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGRyZXNzZXNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0QXV0aG9yaXphdGlvblJlc3VsdENhY2hlKCkge1xuICAgIHJldHVybiBjcmVhdGVEZWZhdWx0QXV0aG9yaXphdGlvbkNhY2hlKCk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXYWxsZXROb3RGb3VuZEhhbmRsZXIobW9iaWxlV2FsbGV0QWRhcHRlcikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RXJyb3JNb2RhbFdhbGxldE5vdEZvdW5kSGFuZGxlcigpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlcigpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlcjtcbn1cblxuZXhwb3J0IHsgTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyLCBSZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUmVtb3RlV2FsbGV0TmFtZSwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWUsIGNyZWF0ZURlZmF1bHRBZGRyZXNzU2VsZWN0b3IsIGNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUsIGNyZWF0ZURlZmF1bHRXYWxsZXROb3RGb3VuZEhhbmRsZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseWalletAdapter: () => (/* binding */ BaseWalletAdapter),\n/* harmony export */   EventEmitter: () => (/* reexport safe */ eventemitter3__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   WalletReadyState: () => (/* binding */ WalletReadyState),\n/* harmony export */   isIosAndRedirectable: () => (/* binding */ isIosAndRedirectable),\n/* harmony export */   scopePollingDetectionStrategy: () => (/* binding */ scopePollingDetectionStrategy)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n\n\n\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */\nvar WalletReadyState;\n(function (WalletReadyState) {\n    /**\n     * User-installable wallets can typically be detected by scanning for an API\n     * that they've injected into the global context. If such an API is present,\n     * we consider the wallet to have been installed.\n     */\n    WalletReadyState[\"Installed\"] = \"Installed\";\n    WalletReadyState[\"NotDetected\"] = \"NotDetected\";\n    /**\n     * Loadable wallets are always available to you. Since you can load them at\n     * any time, it's meaningless to say that they have been detected.\n     */\n    WalletReadyState[\"Loadable\"] = \"Loadable\";\n    /**\n     * If a wallet is not supported on a given platform (eg. server-rendering, or\n     * mobile) then it will stay in the `Unsupported` state.\n     */\n    WalletReadyState[\"Unsupported\"] = \"Unsupported\";\n})(WalletReadyState || (WalletReadyState = {}));\nclass BaseWalletAdapter extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    get connected() {\n        return !!this.publicKey;\n    }\n    async autoConnect() {\n        await this.connect();\n    }\n    async prepareTransaction(transaction, connection, options = {}) {\n        const publicKey = this.publicKey;\n        if (!publicKey)\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError();\n        transaction.feePayer = transaction.feePayer || publicKey;\n        transaction.recentBlockhash =\n            transaction.recentBlockhash ||\n                (await connection.getLatestBlockhash({\n                    commitment: options.preflightCommitment,\n                    minContextSlot: options.minContextSlot,\n                })).blockhash;\n        return transaction;\n    }\n}\nfunction scopePollingDetectionStrategy(detect) {\n    // Early return when server-side rendering\n    if (typeof window === 'undefined' || typeof document === 'undefined')\n        return;\n    const disposers = [];\n    function detectAndDispose() {\n        const detected = detect();\n        if (detected) {\n            for (const dispose of disposers) {\n                dispose();\n            }\n        }\n    }\n    // Strategy #1: Try detecting every second.\n    const interval = \n    // TODO: #334 Replace with idle callback strategy.\n    setInterval(detectAndDispose, 1000);\n    disposers.push(() => clearInterval(interval));\n    // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n    if (\n    // Implies that `DOMContentLoaded` has not yet fired.\n    document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', detectAndDispose, { once: true });\n        disposers.push(() => document.removeEventListener('DOMContentLoaded', detectAndDispose));\n    }\n    // Strategy #3: Detect after the `window` has fully loaded.\n    if (\n    // If the `complete` state has been reached, we're too late.\n    document.readyState !== 'complete') {\n        window.addEventListener('load', detectAndDispose, { once: true });\n        disposers.push(() => window.removeEventListener('load', detectAndDispose));\n    }\n    // Strategy #4: Detect synchronously, now.\n    detectAndDispose();\n}\n/**\n * Users on iOS can be redirected into a wallet's in-app browser automatically,\n * if that wallet has a universal link configured to do so\n * But should not be redirected from within a webview, eg. if they're already\n * inside a wallet's browser\n * This function can be used to identify users who are on iOS and can be redirected\n *\n * @returns true if the user can be redirected\n */\nfunction isIosAndRedirectable() {\n    // SSR: return false\n    if (!navigator)\n        return false;\n    const userAgent = navigator.userAgent.toLowerCase();\n    // if on iOS the user agent will contain either iPhone or iPad\n    // caveat: if requesting desktop site then this won't work\n    const isIos = userAgent.includes('iphone') || userAgent.includes('ipad');\n    // if in a webview then it will not include Safari\n    // note that other iOS browsers also include Safari\n    // so we will redirect only if Safari is also included\n    const isSafari = userAgent.includes('safari');\n    return isIos && isSafari;\n}\n//# sourceMappingURL=adapter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS9hZGFwdGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBeUM7QUFDYTtBQUM5QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQ3RDLGdDQUFnQyxxREFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLHNCQUFzQiwrREFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFlBQVk7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3plbi1mb3J0dW5lLWNvb2tpZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hLW1vYmlsZS93YWxsZXQtYWRhcHRlci1tb2JpbGUvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL2FkYXB0ZXIuanM/NWRjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5leHBvcnQgeyBFdmVudEVtaXR0ZXIgfTtcbi8qKlxuICogQSB3YWxsZXQncyByZWFkaW5lc3MgZGVzY3JpYmVzIGEgc2VyaWVzIG9mIHN0YXRlcyB0aGF0IHRoZSB3YWxsZXQgY2FuIGJlIGluLFxuICogZGVwZW5kaW5nIG9uIHdoYXQga2luZCBvZiB3YWxsZXQgaXQgaXMuIEFuIGluc3RhbGxhYmxlIHdhbGxldCAoZWcuIGEgYnJvd3NlclxuICogZXh0ZW5zaW9uIGxpa2UgUGhhbnRvbSkgbWlnaHQgYmUgYEluc3RhbGxlZGAgaWYgd2UndmUgZm91bmQgdGhlIFBoYW50b20gQVBJXG4gKiBpbiB0aGUgZ2xvYmFsIHNjb3BlLCBvciBgTm90RGV0ZWN0ZWRgIG90aGVyd2lzZS4gQSBsb2FkYWJsZSwgemVyby1pbnN0YWxsXG4gKiBydW50aW1lIChlZy4gVG9ydXMgV2FsbGV0KSBtaWdodCBzaW1wbHkgc2lnbmFsIHRoYXQgaXQncyBgTG9hZGFibGVgLiBVc2UgdGhpc1xuICogbWV0YWRhdGEgdG8gcGVyc29uYWxpemUgdGhlIHdhbGxldCBsaXN0IGZvciBlYWNoIHVzZXIgKGVnLiB0byBzaG93IHRoZWlyXG4gKiBpbnN0YWxsZWQgd2FsbGV0cyBmaXJzdCkuXG4gKi9cbmV4cG9ydCB2YXIgV2FsbGV0UmVhZHlTdGF0ZTtcbihmdW5jdGlvbiAoV2FsbGV0UmVhZHlTdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIFVzZXItaW5zdGFsbGFibGUgd2FsbGV0cyBjYW4gdHlwaWNhbGx5IGJlIGRldGVjdGVkIGJ5IHNjYW5uaW5nIGZvciBhbiBBUElcbiAgICAgKiB0aGF0IHRoZXkndmUgaW5qZWN0ZWQgaW50byB0aGUgZ2xvYmFsIGNvbnRleHQuIElmIHN1Y2ggYW4gQVBJIGlzIHByZXNlbnQsXG4gICAgICogd2UgY29uc2lkZXIgdGhlIHdhbGxldCB0byBoYXZlIGJlZW4gaW5zdGFsbGVkLlxuICAgICAqL1xuICAgIFdhbGxldFJlYWR5U3RhdGVbXCJJbnN0YWxsZWRcIl0gPSBcIkluc3RhbGxlZFwiO1xuICAgIFdhbGxldFJlYWR5U3RhdGVbXCJOb3REZXRlY3RlZFwiXSA9IFwiTm90RGV0ZWN0ZWRcIjtcbiAgICAvKipcbiAgICAgKiBMb2FkYWJsZSB3YWxsZXRzIGFyZSBhbHdheXMgYXZhaWxhYmxlIHRvIHlvdS4gU2luY2UgeW91IGNhbiBsb2FkIHRoZW0gYXRcbiAgICAgKiBhbnkgdGltZSwgaXQncyBtZWFuaW5nbGVzcyB0byBzYXkgdGhhdCB0aGV5IGhhdmUgYmVlbiBkZXRlY3RlZC5cbiAgICAgKi9cbiAgICBXYWxsZXRSZWFkeVN0YXRlW1wiTG9hZGFibGVcIl0gPSBcIkxvYWRhYmxlXCI7XG4gICAgLyoqXG4gICAgICogSWYgYSB3YWxsZXQgaXMgbm90IHN1cHBvcnRlZCBvbiBhIGdpdmVuIHBsYXRmb3JtIChlZy4gc2VydmVyLXJlbmRlcmluZywgb3JcbiAgICAgKiBtb2JpbGUpIHRoZW4gaXQgd2lsbCBzdGF5IGluIHRoZSBgVW5zdXBwb3J0ZWRgIHN0YXRlLlxuICAgICAqL1xuICAgIFdhbGxldFJlYWR5U3RhdGVbXCJVbnN1cHBvcnRlZFwiXSA9IFwiVW5zdXBwb3J0ZWRcIjtcbn0pKFdhbGxldFJlYWR5U3RhdGUgfHwgKFdhbGxldFJlYWR5U3RhdGUgPSB7fSkpO1xuZXhwb3J0IGNsYXNzIEJhc2VXYWxsZXRBZGFwdGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBnZXQgY29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnB1YmxpY0tleTtcbiAgICB9XG4gICAgYXN5bmMgYXV0b0Nvbm5lY3QoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSB0aGlzLnB1YmxpY0tleTtcbiAgICAgICAgaWYgKCFwdWJsaWNLZXkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSB0cmFuc2FjdGlvbi5mZWVQYXllciB8fCBwdWJsaWNLZXk7XG4gICAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggfHxcbiAgICAgICAgICAgICAgICAoYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goe1xuICAgICAgICAgICAgICAgICAgICBjb21taXRtZW50OiBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQsXG4gICAgICAgICAgICAgICAgICAgIG1pbkNvbnRleHRTbG90OiBvcHRpb25zLm1pbkNvbnRleHRTbG90LFxuICAgICAgICAgICAgICAgIH0pKS5ibG9ja2hhc2g7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc2NvcGVQb2xsaW5nRGV0ZWN0aW9uU3RyYXRlZ3koZGV0ZWN0KSB7XG4gICAgLy8gRWFybHkgcmV0dXJuIHdoZW4gc2VydmVyLXNpZGUgcmVuZGVyaW5nXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBkaXNwb3NlcnMgPSBbXTtcbiAgICBmdW5jdGlvbiBkZXRlY3RBbmREaXNwb3NlKCkge1xuICAgICAgICBjb25zdCBkZXRlY3RlZCA9IGRldGVjdCgpO1xuICAgICAgICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGlzcG9zZSBvZiBkaXNwb3NlcnMpIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RyYXRlZ3kgIzE6IFRyeSBkZXRlY3RpbmcgZXZlcnkgc2Vjb25kLlxuICAgIGNvbnN0IGludGVydmFsID0gXG4gICAgLy8gVE9ETzogIzMzNCBSZXBsYWNlIHdpdGggaWRsZSBjYWxsYmFjayBzdHJhdGVneS5cbiAgICBzZXRJbnRlcnZhbChkZXRlY3RBbmREaXNwb3NlLCAxMDAwKTtcbiAgICBkaXNwb3NlcnMucHVzaCgoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKSk7XG4gICAgLy8gU3RyYXRlZ3kgIzI6IERldGVjdCBhcyBzb29uIGFzIHRoZSBET00gYmVjb21lcyAncmVhZHknLydpbnRlcmFjdGl2ZScuXG4gICAgaWYgKFxuICAgIC8vIEltcGxpZXMgdGhhdCBgRE9NQ29udGVudExvYWRlZGAgaGFzIG5vdCB5ZXQgZmlyZWQuXG4gICAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBkZXRlY3RBbmREaXNwb3NlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIGRpc3Bvc2Vycy5wdXNoKCgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBkZXRlY3RBbmREaXNwb3NlKSk7XG4gICAgfVxuICAgIC8vIFN0cmF0ZWd5ICMzOiBEZXRlY3QgYWZ0ZXIgdGhlIGB3aW5kb3dgIGhhcyBmdWxseSBsb2FkZWQuXG4gICAgaWYgKFxuICAgIC8vIElmIHRoZSBgY29tcGxldGVgIHN0YXRlIGhhcyBiZWVuIHJlYWNoZWQsIHdlJ3JlIHRvbyBsYXRlLlxuICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBkZXRlY3RBbmREaXNwb3NlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIGRpc3Bvc2Vycy5wdXNoKCgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgZGV0ZWN0QW5kRGlzcG9zZSkpO1xuICAgIH1cbiAgICAvLyBTdHJhdGVneSAjNDogRGV0ZWN0IHN5bmNocm9ub3VzbHksIG5vdy5cbiAgICBkZXRlY3RBbmREaXNwb3NlKCk7XG59XG4vKipcbiAqIFVzZXJzIG9uIGlPUyBjYW4gYmUgcmVkaXJlY3RlZCBpbnRvIGEgd2FsbGV0J3MgaW4tYXBwIGJyb3dzZXIgYXV0b21hdGljYWxseSxcbiAqIGlmIHRoYXQgd2FsbGV0IGhhcyBhIHVuaXZlcnNhbCBsaW5rIGNvbmZpZ3VyZWQgdG8gZG8gc29cbiAqIEJ1dCBzaG91bGQgbm90IGJlIHJlZGlyZWN0ZWQgZnJvbSB3aXRoaW4gYSB3ZWJ2aWV3LCBlZy4gaWYgdGhleSdyZSBhbHJlYWR5XG4gKiBpbnNpZGUgYSB3YWxsZXQncyBicm93c2VyXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IHVzZXJzIHdobyBhcmUgb24gaU9TIGFuZCBjYW4gYmUgcmVkaXJlY3RlZFxuICpcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHVzZXIgY2FuIGJlIHJlZGlyZWN0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW9zQW5kUmVkaXJlY3RhYmxlKCkge1xuICAgIC8vIFNTUjogcmV0dXJuIGZhbHNlXG4gICAgaWYgKCFuYXZpZ2F0b3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gaWYgb24gaU9TIHRoZSB1c2VyIGFnZW50IHdpbGwgY29udGFpbiBlaXRoZXIgaVBob25lIG9yIGlQYWRcbiAgICAvLyBjYXZlYXQ6IGlmIHJlcXVlc3RpbmcgZGVza3RvcCBzaXRlIHRoZW4gdGhpcyB3b24ndCB3b3JrXG4gICAgY29uc3QgaXNJb3MgPSB1c2VyQWdlbnQuaW5jbHVkZXMoJ2lwaG9uZScpIHx8IHVzZXJBZ2VudC5pbmNsdWRlcygnaXBhZCcpO1xuICAgIC8vIGlmIGluIGEgd2VidmlldyB0aGVuIGl0IHdpbGwgbm90IGluY2x1ZGUgU2FmYXJpXG4gICAgLy8gbm90ZSB0aGF0IG90aGVyIGlPUyBicm93c2VycyBhbHNvIGluY2x1ZGUgU2FmYXJpXG4gICAgLy8gc28gd2Ugd2lsbCByZWRpcmVjdCBvbmx5IGlmIFNhZmFyaSBpcyBhbHNvIGluY2x1ZGVkXG4gICAgY29uc3QgaXNTYWZhcmkgPSB1c2VyQWdlbnQuaW5jbHVkZXMoJ3NhZmFyaScpO1xuICAgIHJldHVybiBpc0lvcyAmJiBpc1NhZmFyaTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYXB0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/errors.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/errors.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletAccountError: () => (/* binding */ WalletAccountError),\n/* harmony export */   WalletConfigError: () => (/* binding */ WalletConfigError),\n/* harmony export */   WalletConnectionError: () => (/* binding */ WalletConnectionError),\n/* harmony export */   WalletDisconnectedError: () => (/* binding */ WalletDisconnectedError),\n/* harmony export */   WalletDisconnectionError: () => (/* binding */ WalletDisconnectionError),\n/* harmony export */   WalletError: () => (/* binding */ WalletError),\n/* harmony export */   WalletKeypairError: () => (/* binding */ WalletKeypairError),\n/* harmony export */   WalletLoadError: () => (/* binding */ WalletLoadError),\n/* harmony export */   WalletNotConnectedError: () => (/* binding */ WalletNotConnectedError),\n/* harmony export */   WalletNotReadyError: () => (/* binding */ WalletNotReadyError),\n/* harmony export */   WalletPublicKeyError: () => (/* binding */ WalletPublicKeyError),\n/* harmony export */   WalletSendTransactionError: () => (/* binding */ WalletSendTransactionError),\n/* harmony export */   WalletSignInError: () => (/* binding */ WalletSignInError),\n/* harmony export */   WalletSignMessageError: () => (/* binding */ WalletSignMessageError),\n/* harmony export */   WalletSignTransactionError: () => (/* binding */ WalletSignTransactionError),\n/* harmony export */   WalletTimeoutError: () => (/* binding */ WalletTimeoutError),\n/* harmony export */   WalletWindowBlockedError: () => (/* binding */ WalletWindowBlockedError),\n/* harmony export */   WalletWindowClosedError: () => (/* binding */ WalletWindowClosedError)\n/* harmony export */ });\nclass WalletError extends Error {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(message, error) {\n        super(message);\n        this.error = error;\n    }\n}\nclass WalletNotReadyError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletNotReadyError';\n    }\n}\nclass WalletLoadError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletLoadError';\n    }\n}\nclass WalletConfigError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletConfigError';\n    }\n}\nclass WalletConnectionError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletConnectionError';\n    }\n}\nclass WalletDisconnectedError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletDisconnectedError';\n    }\n}\nclass WalletDisconnectionError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletDisconnectionError';\n    }\n}\nclass WalletAccountError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletAccountError';\n    }\n}\nclass WalletPublicKeyError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletPublicKeyError';\n    }\n}\nclass WalletKeypairError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletKeypairError';\n    }\n}\nclass WalletNotConnectedError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletNotConnectedError';\n    }\n}\nclass WalletSendTransactionError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletSendTransactionError';\n    }\n}\nclass WalletSignTransactionError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletSignTransactionError';\n    }\n}\nclass WalletSignMessageError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletSignMessageError';\n    }\n}\nclass WalletSignInError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletSignInError';\n    }\n}\nclass WalletTimeoutError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletTimeoutError';\n    }\n}\nclass WalletWindowBlockedError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletWindowBlockedError';\n    }\n}\nclass WalletWindowClosedError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletWindowClosedError';\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS9lcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3plbi1mb3J0dW5lLWNvb2tpZS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hLW1vYmlsZS93YWxsZXQtYWRhcHRlci1tb2JpbGUvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL2Vycm9ycy5qcz9iMjhmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBXYWxsZXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9yKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldE5vdFJlYWR5RXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXROb3RSZWFkeUVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0TG9hZEVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0TG9hZEVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0Q29uZmlnRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRDb25maWdFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldENvbm5lY3Rpb25FcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldENvbm5lY3Rpb25FcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldERpc2Nvbm5lY3RlZEVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0RGlzY29ubmVjdGVkRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXREaXNjb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXREaXNjb25uZWN0aW9uRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRBY2NvdW50RXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRBY2NvdW50RXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRQdWJsaWNLZXlFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldFB1YmxpY0tleUVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0S2V5cGFpckVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0S2V5cGFpckVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXROb3RDb25uZWN0ZWRFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0U2lnbk1lc3NhZ2VFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldFNpZ25NZXNzYWdlRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRTaWduSW5FcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldFNpZ25JbkVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0VGltZW91dEVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0VGltZW91dEVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0V2luZG93QmxvY2tlZEVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0V2luZG93QmxvY2tlZEVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0V2luZG93Q2xvc2VkRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRXaW5kb3dDbG9zZWRFcnJvcic7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/signer.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/signer.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseMessageSignerWalletAdapter: () => (/* binding */ BaseMessageSignerWalletAdapter),\n/* harmony export */   BaseSignInMessageSignerWalletAdapter: () => (/* binding */ BaseSignInMessageSignerWalletAdapter),\n/* harmony export */   BaseSignerWalletAdapter: () => (/* binding */ BaseSignerWalletAdapter)\n/* harmony export */ });\n/* harmony import */ var _adapter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter.js */ \"(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transaction.js */ \"(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\");\n\n\n\nclass BaseSignerWalletAdapter extends _adapter_js__WEBPACK_IMPORTED_MODULE_0__.BaseWalletAdapter {\n    async sendTransaction(transaction, connection, options = {}) {\n        let emit = true;\n        try {\n            if ((0,_transaction_js__WEBPACK_IMPORTED_MODULE_1__.isVersionedTransaction)(transaction)) {\n                if (!this.supportedTransactionVersions)\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(`Sending versioned transactions isn't supported by this wallet`);\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(`Sending transaction version ${transaction.version} isn't supported by this wallet`);\n                try {\n                    transaction = await this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return await connection.sendRawTransaction(rawTransaction, options);\n                }\n                catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(error?.message, error);\n                }\n            }\n            else {\n                try {\n                    const { signers, ...sendOptions } = options;\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n                    signers?.length && transaction.partialSign(...signers);\n                    transaction = await this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return await connection.sendRawTransaction(rawTransaction, sendOptions);\n                }\n                catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(error?.message, error);\n                }\n            }\n        }\n        catch (error) {\n            if (emit) {\n                this.emit('error', error);\n            }\n            throw error;\n        }\n    }\n    async signAllTransactions(transactions) {\n        for (const transaction of transactions) {\n            if ((0,_transaction_js__WEBPACK_IMPORTED_MODULE_1__.isVersionedTransaction)(transaction)) {\n                if (!this.supportedTransactionVersions)\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError(`Signing versioned transactions isn't supported by this wallet`);\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError(`Signing transaction version ${transaction.version} isn't supported by this wallet`);\n            }\n        }\n        const signedTransactions = [];\n        for (const transaction of transactions) {\n            signedTransactions.push(await this.signTransaction(transaction));\n        }\n        return signedTransactions;\n    }\n}\nclass BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {\n}\nclass BaseSignInMessageSignerWalletAdapter extends BaseMessageSignerWalletAdapter {\n}\n//# sourceMappingURL=signer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS9zaWduZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtEO0FBQ21DO0FBQzNCO0FBQ25ELHNDQUFzQywwREFBaUI7QUFDOUQsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQSxnQkFBZ0IsdUVBQXNCO0FBQ3RDO0FBQ0EsOEJBQThCLGtFQUEwQjtBQUN4RDtBQUNBLDhCQUE4QixrRUFBMEIsZ0NBQWdDLHFCQUFxQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrRUFBMEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtFQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrRUFBMEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtFQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUVBQXNCO0FBQ3RDO0FBQ0EsOEJBQThCLGtFQUEwQjtBQUN4RDtBQUNBLDhCQUE4QixrRUFBMEIsZ0NBQWdDLHFCQUFxQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVuLWZvcnR1bmUtY29va2llLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEtbW9iaWxlL3dhbGxldC1hZGFwdGVyLW1vYmlsZS9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vc2lnbmVyLmpzP2JlNDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZVdhbGxldEFkYXB0ZXIsIH0gZnJvbSAnLi9hZGFwdGVyLmpzJztcbmltcG9ydCB7IFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yLCBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvciB9IGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24gfSBmcm9tICcuL3RyYW5zYWN0aW9uLmpzJztcbmV4cG9ydCBjbGFzcyBCYXNlU2lnbmVyV2FsbGV0QWRhcHRlciBleHRlbmRzIEJhc2VXYWxsZXRBZGFwdGVyIHtcbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgZW1pdCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yKGBTZW5kaW5nIHZlcnNpb25lZCB0cmFuc2FjdGlvbnMgaXNuJ3Qgc3VwcG9ydGVkIGJ5IHRoaXMgd2FsbGV0YCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMuaGFzKHRyYW5zYWN0aW9uLnZlcnNpb24pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IoYFNlbmRpbmcgdHJhbnNhY3Rpb24gdmVyc2lvbiAke3RyYW5zYWN0aW9uLnZlcnNpb259IGlzbid0IHN1cHBvcnRlZCBieSB0aGlzIHdhbGxldGApO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVycm9yIHdhcyB0aHJvd24gYnkgYHNpZ25UcmFuc2FjdGlvbmAsIHJldGhyb3cgaXQgYW5kIGRvbid0IGVtaXQgYSBkdXBsaWNhdGUgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmVycywgLi4uc2VuZE9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5wcmVwYXJlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIHNlbmRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVycz8ubGVuZ3RoICYmIHRyYW5zYWN0aW9uLnBhcnRpYWxTaWduKC4uLnNpZ25lcnMpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3VHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uLCBzZW5kT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZXJyb3Igd2FzIHRocm93biBieSBgc2lnblRyYW5zYWN0aW9uYCwgcmV0aHJvdyBpdCBhbmQgZG9uJ3QgZW1pdCBhIGR1cGxpY2F0ZSBldmVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVtaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCB0cmFuc2FjdGlvbiBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IoYFNpZ25pbmcgdmVyc2lvbmVkIHRyYW5zYWN0aW9ucyBpc24ndCBzdXBwb3J0ZWQgYnkgdGhpcyB3YWxsZXRgKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucy5oYXModHJhbnNhY3Rpb24udmVyc2lvbikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcihgU2lnbmluZyB0cmFuc2FjdGlvbiB2ZXJzaW9uICR7dHJhbnNhY3Rpb24udmVyc2lvbn0gaXNuJ3Qgc3VwcG9ydGVkIGJ5IHRoaXMgd2FsbGV0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb25zID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdHJhbnNhY3Rpb24gb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBzaWduZWRUcmFuc2FjdGlvbnMucHVzaChhd2FpdCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJhc2VNZXNzYWdlU2lnbmVyV2FsbGV0QWRhcHRlciBleHRlbmRzIEJhc2VTaWduZXJXYWxsZXRBZGFwdGVyIHtcbn1cbmV4cG9ydCBjbGFzcyBCYXNlU2lnbkluTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIgZXh0ZW5kcyBCYXNlTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIge1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/signer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isVersionedTransaction: () => (/* binding */ isVersionedTransaction)\n/* harmony export */ });\nfunction isVersionedTransaction(transaction) {\n    return 'version' in transaction;\n}\n//# sourceMappingURL=transaction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZW4tZm9ydHVuZS1jb29raWUvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS90cmFuc2FjdGlvbi5qcz83OGVmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuICd2ZXJzaW9uJyBpbiB0cmFuc2FjdGlvbjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/eventemitter3/index.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/eventemitter3/index.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* reexport default export from named module */ _index_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/eventemitter3/index.js\");\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUM7O0FBRWQ7QUFDdkIsaUVBQWUsc0NBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZW4tZm9ydHVuZS1jb29raWUvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4Lm1qcz83NWY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi9pbmRleC5qcydcblxuZXhwb3J0IHsgRXZlbnRFbWl0dGVyIH1cbmV4cG9ydCBkZWZhdWx0IEV2ZW50RW1pdHRlclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/node_modules/eventemitter3/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/wallet-standard-mobile/lib/esm/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana-mobile/wallet-standard-mobile/lib/esm/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LocalSolanaMobileWalletAdapterWallet: () => (/* binding */ LocalSolanaMobileWalletAdapterWallet),\n/* harmony export */   RemoteSolanaMobileWalletAdapterWallet: () => (/* binding */ RemoteSolanaMobileWalletAdapterWallet),\n/* harmony export */   SolanaMobileWalletAdapterRemoteWalletName: () => (/* binding */ SolanaMobileWalletAdapterRemoteWalletName),\n/* harmony export */   SolanaMobileWalletAdapterWalletName: () => (/* binding */ SolanaMobileWalletAdapterWalletName),\n/* harmony export */   createDefaultAuthorizationCache: () => (/* binding */ createDefaultAuthorizationCache),\n/* harmony export */   createDefaultChainSelector: () => (/* binding */ createDefaultChainSelector),\n/* harmony export */   createDefaultWalletNotFoundHandler: () => (/* binding */ createDefaultWalletNotFoundHandler),\n/* harmony export */   defaultErrorModalWalletNotFoundHandler: () => (/* binding */ defaultErrorModalWalletNotFoundHandler),\n/* harmony export */   registerMwa: () => (/* binding */ registerMwa)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/./node_modules/@solana/wallet-standard-features/lib/esm/signIn.js\");\n/* harmony import */ var qrcode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! qrcode */ \"(ssr)/./node_modules/qrcode/lib/index.js\");\n/* harmony import */ var _solana_mobile_mobile_wallet_adapter_protocol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana-mobile/mobile-wallet-adapter-protocol */ \"(ssr)/./node_modules/@solana-mobile/wallet-standard-mobile/node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/./node_modules/@wallet-standard/features/lib/esm/connect.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/./node_modules/@wallet-standard/features/lib/esm/disconnect.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/./node_modules/@wallet-standard/features/lib/esm/events.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/@solana-mobile/wallet-standard-mobile/node_modules/bs58/index.js\");\n/* harmony import */ var _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @solana/wallet-standard-chains */ \"(ssr)/./node_modules/@solana/wallet-standard-chains/lib/esm/index.js\");\n\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __classPrivateFieldGet$1(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet$1(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\n\nvar _EmbeddedModal_instances, _EmbeddedModal_root, _EmbeddedModal_eventListeners, _EmbeddedModal_listenersAttached, _EmbeddedModal_injectHTML, _EmbeddedModal_attachEventListeners, _EmbeddedModal_removeEventListeners, _EmbeddedModal_handleKeyDown;\nconst modalHtml = `\n<div class=\"mobile-wallet-adapter-embedded-modal-container\" role=\"dialog\" aria-modal=\"true\" aria-labelledby=\"modal-title\">\n    <div data-modal-close style=\"position: absolute; width: 100%; height: 100%;\"></div>\n\t<div class=\"mobile-wallet-adapter-embedded-modal-card\">\n\t\t<div>\n\t\t\t<button data-modal-close class=\"mobile-wallet-adapter-embedded-modal-close\">\n\t\t\t\t<svg width=\"14\" height=\"14\">\n\t\t\t\t\t<path d=\"M 6.7125,8.3036995 1.9082,13.108199 c -0.2113,0.2112 -0.4765,0.3168 -0.7957,0.3168 -0.3192,0 -0.5844,-0.1056 -0.7958,-0.3168 C 0.1056,12.896899 0,12.631699 0,12.312499 c 0,-0.3192 0.1056,-0.5844 0.3167,-0.7958 L 5.1212,6.7124995 0.3167,1.9082 C 0.1056,1.6969 0,1.4317 0,1.1125 0,0.7933 0.1056,0.5281 0.3167,0.3167 0.5281,0.1056 0.7933,0 1.1125,0 1.4317,0 1.6969,0.1056 1.9082,0.3167 L 6.7125,5.1212 11.5167,0.3167 C 11.7281,0.1056 11.9933,0 12.3125,0 c 0.3192,0 0.5844,0.1056 0.7957,0.3167 0.2112,0.2114 0.3168,0.4766 0.3168,0.7958 0,0.3192 -0.1056,0.5844 -0.3168,0.7957 L 8.3037001,6.7124995 13.1082,11.516699 c 0.2112,0.2114 0.3168,0.4766 0.3168,0.7958 0,0.3192 -0.1056,0.5844 -0.3168,0.7957 -0.2113,0.2112 -0.4765,0.3168 -0.7957,0.3168 -0.3192,0 -0.5844,-0.1056 -0.7958,-0.3168 z\" />\n\t\t\t\t</svg>\n\t\t\t</button>\n\t\t</div>\n\t\t<div class=\"mobile-wallet-adapter-embedded-modal-content\"></div>\n\t</div>\n</div>\n`;\nconst css$2 = `\n.mobile-wallet-adapter-embedded-modal-container {\n    display: flex; /* Use flexbox to center content */\n    justify-content: center; /* Center horizontally */\n    align-items: center; /* Center vertically */\n    position: fixed; /* Stay in place */\n    z-index: 1; /* Sit on top */\n    left: 0;\n    top: 0;\n    width: 100%; /* Full width */\n    height: 100%; /* Full height */\n    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */\n    overflow-y: auto; /* enable scrolling */\n}\n\n.mobile-wallet-adapter-embedded-modal-card {\n    display: flex;\n    flex-direction: column;\n    margin: auto 20px;\n    max-width: 780px;\n    padding: 20px;\n    border-radius: 24px;\n    background: #ffffff;\n    font-family: \"Inter Tight\", \"PT Sans\", Calibri, sans-serif;\n    transform: translateY(-200%);\n    animation: slide-in 0.5s forwards;\n}\n\n@keyframes slide-in {\n    100% { transform: translateY(0%); }\n}\n\n.mobile-wallet-adapter-embedded-modal-close {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 32px;\n    height: 32px;\n    cursor: pointer;\n    background: #e4e9e9;\n    border: none;\n    border-radius: 50%;\n}\n\n.mobile-wallet-adapter-embedded-modal-close:focus-visible {\n    outline-color: red;\n}\n\n.mobile-wallet-adapter-embedded-modal-close svg {\n    fill: #546266;\n    transition: fill 200ms ease 0s;\n}\n\n.mobile-wallet-adapter-embedded-modal-close:hover svg {\n    fill: #fff;\n}\n`;\nconst fonts = `\n<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?family=Inter+Tight:ital,wght@0,100..900;1,100..900&display=swap\" rel=\"stylesheet\">\n`;\nclass EmbeddedModal {\n    constructor() {\n        _EmbeddedModal_instances.add(this);\n        _EmbeddedModal_root.set(this, null);\n        _EmbeddedModal_eventListeners.set(this, {});\n        _EmbeddedModal_listenersAttached.set(this, false);\n        this.dom = null;\n        this.open = () => {\n            console.debug('Modal open');\n            __classPrivateFieldGet$1(this, _EmbeddedModal_instances, \"m\", _EmbeddedModal_attachEventListeners).call(this);\n            if (__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\")) {\n                __classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").style.display = 'flex';\n            }\n        };\n        this.close = (event = undefined) => {\n            var _a;\n            console.debug('Modal close');\n            __classPrivateFieldGet$1(this, _EmbeddedModal_instances, \"m\", _EmbeddedModal_removeEventListeners).call(this);\n            if (__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\")) {\n                __classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").style.display = 'none';\n            }\n            (_a = __classPrivateFieldGet$1(this, _EmbeddedModal_eventListeners, \"f\")['close']) === null || _a === void 0 ? void 0 : _a.forEach((listener) => listener(event));\n        };\n        _EmbeddedModal_handleKeyDown.set(this, (event) => {\n            if (event.key === 'Escape')\n                this.close(event);\n        });\n        // Bind methods to ensure `this` context is correct\n        this.init = this.init.bind(this);\n        __classPrivateFieldSet$1(this, _EmbeddedModal_root, document.getElementById('mobile-wallet-adapter-embedded-root-ui'), \"f\");\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log('Injecting modal');\n            __classPrivateFieldGet$1(this, _EmbeddedModal_instances, \"m\", _EmbeddedModal_injectHTML).call(this);\n        });\n    }\n    addEventListener(event, listener) {\n        var _a;\n        ((_a = __classPrivateFieldGet$1(this, _EmbeddedModal_eventListeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.push(listener)) || (__classPrivateFieldGet$1(this, _EmbeddedModal_eventListeners, \"f\")[event] = [listener]);\n        return () => this.removeEventListener(event, listener);\n    }\n    removeEventListener(event, listener) {\n        var _a;\n        __classPrivateFieldGet$1(this, _EmbeddedModal_eventListeners, \"f\")[event] = (_a = __classPrivateFieldGet$1(this, _EmbeddedModal_eventListeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.filter((existingListener) => listener !== existingListener);\n    }\n}\n_EmbeddedModal_root = new WeakMap(), _EmbeddedModal_eventListeners = new WeakMap(), _EmbeddedModal_listenersAttached = new WeakMap(), _EmbeddedModal_handleKeyDown = new WeakMap(), _EmbeddedModal_instances = new WeakSet(), _EmbeddedModal_injectHTML = function _EmbeddedModal_injectHTML() {\n    // Check if the HTML has already been injected\n    if (document.getElementById('mobile-wallet-adapter-embedded-root-ui')) {\n        if (!__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\"))\n            __classPrivateFieldSet$1(this, _EmbeddedModal_root, document.getElementById('mobile-wallet-adapter-embedded-root-ui'), \"f\");\n        return;\n    }\n    // Create a container for the modal\n    __classPrivateFieldSet$1(this, _EmbeddedModal_root, document.createElement('div'), \"f\");\n    __classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").id = 'mobile-wallet-adapter-embedded-root-ui';\n    __classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").innerHTML = modalHtml;\n    __classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").style.display = 'none';\n    // Add modal content\n    const content = __classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").querySelector('.mobile-wallet-adapter-embedded-modal-content');\n    if (content)\n        content.innerHTML = this.contentHtml;\n    // Apply styles\n    const styles = document.createElement('style');\n    styles.id = 'mobile-wallet-adapter-embedded-modal-styles';\n    styles.textContent = css$2 + this.contentStyles;\n    // Create a shadow DOM to encapsulate the modal\n    const host = document.createElement('div');\n    host.innerHTML = fonts;\n    this.dom = host.attachShadow({ mode: 'closed' });\n    this.dom.appendChild(styles);\n    this.dom.appendChild(__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\"));\n    // Append the shadow DOM host to the body\n    document.body.appendChild(host);\n}, _EmbeddedModal_attachEventListeners = function _EmbeddedModal_attachEventListeners() {\n    if (!__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\") || __classPrivateFieldGet$1(this, _EmbeddedModal_listenersAttached, \"f\"))\n        return;\n    const closers = [...__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").querySelectorAll('[data-modal-close]')];\n    closers.forEach(closer => closer === null || closer === void 0 ? void 0 : closer.addEventListener('click', this.close));\n    window.addEventListener('load', this.close);\n    document.addEventListener('keydown', __classPrivateFieldGet$1(this, _EmbeddedModal_handleKeyDown, \"f\"));\n    __classPrivateFieldSet$1(this, _EmbeddedModal_listenersAttached, true, \"f\");\n}, _EmbeddedModal_removeEventListeners = function _EmbeddedModal_removeEventListeners() {\n    if (!__classPrivateFieldGet$1(this, _EmbeddedModal_listenersAttached, \"f\"))\n        return;\n    window.removeEventListener('load', this.close);\n    document.removeEventListener('keydown', __classPrivateFieldGet$1(this, _EmbeddedModal_handleKeyDown, \"f\"));\n    if (!__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\"))\n        return;\n    const closers = [...__classPrivateFieldGet$1(this, _EmbeddedModal_root, \"f\").querySelectorAll('[data-modal-close]')];\n    closers.forEach(closer => closer === null || closer === void 0 ? void 0 : closer.removeEventListener('click', this.close));\n    __classPrivateFieldSet$1(this, _EmbeddedModal_listenersAttached, false, \"f\");\n};\n\nclass RemoteConnectionModal extends EmbeddedModal {\n    constructor() {\n        super(...arguments);\n        this.contentStyles = css$1;\n        this.contentHtml = QRCodeHtml;\n    }\n    initWithQR(qrCode) {\n        const _super = Object.create(null, {\n            init: { get: () => super.init }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            _super.init.call(this);\n            this.populateQRCode(qrCode);\n        });\n    }\n    populateQRCode(qrUrl) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const qrcodeContainer = (_a = this.dom) === null || _a === void 0 ? void 0 : _a.getElementById('mobile-wallet-adapter-embedded-modal-qr-code-container');\n            if (qrcodeContainer) {\n                const qrCodeElement = yield qrcode__WEBPACK_IMPORTED_MODULE_0__.toCanvas(qrUrl, { width: 200, margin: 0 });\n                if (qrcodeContainer.firstElementChild !== null) {\n                    qrcodeContainer.replaceChild(qrCodeElement, qrcodeContainer.firstElementChild);\n                }\n                else\n                    qrcodeContainer.appendChild(qrCodeElement);\n            }\n            else {\n                console.error('QRCode Container not found');\n            }\n        });\n    }\n}\nconst QRCodeHtml = `\n<div class=\"mobile-wallet-adapter-embedded-modal-qr-content\">\n    <div>\n        <svg class=\"mobile-wallet-adapter-embedded-modal-icon\" width=\"100%\" height=\"100%\">\n            <circle r=\"52\" cx=\"53\" cy=\"53\" fill=\"#99b3be\" stroke=\"#000000\" stroke-width=\"2\"/>\n            <path d=\"m 53,82.7305 c -3.3116,0 -6.1361,-1.169 -8.4735,-3.507 -2.338,-2.338 -3.507,-5.1625 -3.507,-8.4735 0,-3.3116 1.169,-6.1364 3.507,-8.4744 2.3374,-2.338 5.1619,-3.507 8.4735,-3.507 3.3116,0 6.1361,1.169 8.4735,3.507 2.338,2.338 3.507,5.1628 3.507,8.4744 0,3.311 -1.169,6.1355 -3.507,8.4735 -2.3374,2.338 -5.1619,3.507 -8.4735,3.507 z m 0.007,-5.25 c 1.8532,0 3.437,-0.6598 4.7512,-1.9793 1.3149,-1.3195 1.9723,-2.9058 1.9723,-4.7591 0,-1.8526 -0.6598,-3.4364 -1.9793,-4.7512 -1.3195,-1.3149 -2.9055,-1.9723 -4.7582,-1.9723 -1.8533,0 -3.437,0.6598 -4.7513,1.9793 -1.3148,1.3195 -1.9722,2.9058 -1.9722,4.7591 0,1.8527 0.6597,3.4364 1.9792,4.7512 1.3195,1.3149 2.9056,1.9723 4.7583,1.9723 z m -28,-33.5729 -3.85,-3.6347 c 4.1195,-4.025 8.8792,-7.1984 14.2791,-9.52 5.4005,-2.3223 11.2551,-3.4834 17.5639,-3.4834 6.3087,0 12.1634,1.1611 17.5639,3.4834 5.3999,2.3216 10.1596,5.495 14.2791,9.52 l -3.85,3.6347 C 77.2999,40.358 73.0684,37.5726 68.2985,35.5514 63.5292,33.5301 58.4296,32.5195 53,32.5195 c -5.4297,0 -10.5292,1.0106 -15.2985,3.0319 -4.7699,2.0212 -9.0014,4.8066 -12.6945,8.3562 z m 44.625,10.8771 c -2.2709,-2.1046 -4.7962,-3.7167 -7.5758,-4.8361 -2.7795,-1.12 -5.7983,-1.68 -9.0562,-1.68 -3.2579,0 -6.2621,0.56 -9.0125,1.68 -2.7504,1.1194 -5.2903,2.7315 -7.6195,4.8361 L 32.5189,51.15 c 2.8355,-2.6028 5.9777,-4.6086 9.4263,-6.0174 3.4481,-1.4087 7.133,-2.1131 11.0548,-2.1131 3.9217,0 7.5979,0.7044 11.0285,2.1131 3.43,1.4088 6.5631,3.4146 9.3992,6.0174 z\"/>\n        </svg>\n        <div class=\"mobile-wallet-adapter-embedded-modal-title\">Remote Mobile Wallet Adapter</div>\n    </div>\n    <div>\n        <div>\n            <h4 class=\"mobile-wallet-adapter-embedded-modal-qr-label\">\n                Open your wallet and scan this code\n            </h4>\n        </div>\n        <div id=\"mobile-wallet-adapter-embedded-modal-qr-code-container\" class=\"mobile-wallet-adapter-embedded-modal-qr-code-container\"></div>\n    </div>\n</div>\n<div class=\"mobile-wallet-adapter-embedded-modal-divider\"><hr></div>\n<div class=\"mobile-wallet-adapter-embedded-modal-footer\">\n    <div class=\"mobile-wallet-adapter-embedded-modal-subtitle\">\n        Follow the instructions on your device. When you're finished, this screen will update.\n    </div>\n    <div class=\"mobile-wallet-adapter-embedded-modal-progress-badge\">\n        <div>\n            <div class=\"spinner\">\n                <div class=\"leftWrapper\">\n                    <div class=\"left\">\n                        <div class=\"circle\"></div>\n                    </div>\n                </div>\n                <div class=\"rightWrapper\">\n                    <div class=\"right\">\n                        <div class=\"circle\"></div>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <div>Waiting for scan</div>\n    </div>\n</div>\n`;\nconst css$1 = `\n.mobile-wallet-adapter-embedded-modal-qr-content {\n    display: flex; \n    margin-top: 10px;\n    padding: 10px;\n}\n\n.mobile-wallet-adapter-embedded-modal-qr-content > div:first-child {\n    display: flex;\n    flex-direction: column;\n    flex: 2;\n    margin-top: auto;\n    margin-right: 30px;\n}\n\n.mobile-wallet-adapter-embedded-modal-qr-content > div:nth-child(2) {\n    display: flex;\n    flex-direction: column;\n    flex: 1;\n    margin-left: auto;\n}\n\n.mobile-wallet-adapter-embedded-modal-footer {\n    display: flex;\n    padding: 10px;\n}\n\n.mobile-wallet-adapter-embedded-modal-icon {}\n\n.mobile-wallet-adapter-embedded-modal-title {\n    color: #000000;\n    font-size: 2.5em;\n    font-weight: 600;\n}\n\n.mobile-wallet-adapter-embedded-modal-qr-label {\n    text-align: right;\n    color: #000000;\n}\n\n.mobile-wallet-adapter-embedded-modal-qr-code-container {\n    margin-left: auto;\n}\n\n.mobile-wallet-adapter-embedded-modal-divider {\n    margin-top: 20px;\n    padding-left: 10px;\n    padding-right: 10px;\n}\n\n.mobile-wallet-adapter-embedded-modal-divider hr {\n    border-top: 1px solid #D9DEDE;\n}\n\n.mobile-wallet-adapter-embedded-modal-subtitle {\n    margin: auto;\n    margin-right: 60px;\n    padding: 20px;\n    color: #6E8286;\n}\n\n.mobile-wallet-adapter-embedded-modal-progress-badge {\n    display: flex;\n    background: #F7F8F8;\n    height: 56px;\n    min-width: 200px;\n    margin: auto;\n    padding-left: 20px;\n    padding-right: 20px;\n    border-radius: 18px;\n    color: #A8B6B8;\n    align-items: center;\n}\n\n.mobile-wallet-adapter-embedded-modal-progress-badge > div:first-child {\n    margin-left: auto;\n    margin-right: 20px;\n}\n\n.mobile-wallet-adapter-embedded-modal-progress-badge > div:nth-child(2) {\n    margin-right: auto;\n}\n\n/* Smaller screens */\n@media all and (max-width: 600px) {\n    .mobile-wallet-adapter-embedded-modal-card {\n        text-align: center;\n    }\n    .mobile-wallet-adapter-embedded-modal-qr-content {\n        flex-direction: column;\n    }\n    .mobile-wallet-adapter-embedded-modal-qr-content > div:first-child {\n        margin: auto;\n    }\n    .mobile-wallet-adapter-embedded-modal-qr-content > div:nth-child(2) {\n        margin: auto;\n        flex: 2 auto;\n    }\n    .mobile-wallet-adapter-embedded-modal-footer {\n        flex-direction: column;\n    }\n    .mobile-wallet-adapter-embedded-modal-icon {\n        display: none;\n    }\n    .mobile-wallet-adapter-embedded-modal-title {\n        font-size: 1.5em;\n    }\n    .mobile-wallet-adapter-embedded-modal-subtitle {\n        margin-right: unset;\n    }\n    .mobile-wallet-adapter-embedded-modal-qr-label {\n        text-align: center;\n    }\n    .mobile-wallet-adapter-embedded-modal-qr-code-container {\n        margin: auto;\n    }\n}\n\n/* Spinner */\n@keyframes spinLeft {\n    0% {\n        transform: rotate(20deg);\n    }\n    50% {\n        transform: rotate(160deg);\n    }\n    100% {\n        transform: rotate(20deg);\n    }\n}\n@keyframes spinRight {\n    0% {\n        transform: rotate(160deg);\n    }\n    50% {\n        transform: rotate(20deg);\n    }\n    100% {\n        transform: rotate(160deg);\n    }\n}\n@keyframes spin {\n    0% {\n        transform: rotate(0deg);\n    }\n    100% {\n        transform: rotate(2520deg);\n    }\n}\n\n.spinner {\n    position: relative;\n    width: 1.5em;\n    height: 1.5em;\n    margin: auto;\n    animation: spin 10s linear infinite;\n}\n.spinner::before {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n}\n.right, .rightWrapper, .left, .leftWrapper {\n    position: absolute;\n    top: 0;\n    overflow: hidden;\n    width: .75em;\n    height: 1.5em;\n}\n.left, .leftWrapper {\n    left: 0;\n}\n.right {\n    left: -12px;\n}\n.rightWrapper {\n    right: 0;\n}\n.circle {\n    border: .125em solid #A8B6B8;\n    width: 1.25em; /* 1.5em - 2*0.125em border */\n    height: 1.25em; /* 1.5em - 2*0.125em border */\n    border-radius: 0.75em; /* 0.5*1.5em spinner size 8 */\n}\n.left {\n    transform-origin: 100% 50%;\n    animation: spinLeft 2.5s cubic-bezier(.2,0,.8,1) infinite;\n}\n.right {\n    transform-origin: 100% 50%;\n    animation: spinRight 2.5s cubic-bezier(.2,0,.8,1) infinite;\n}\n`;\n\nconst icon = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03IDIuNUgxN0MxNy44Mjg0IDIuNSAxOC41IDMuMTcxNTcgMTguNSA0VjIwQzE4LjUgMjAuODI4NCAxNy44Mjg0IDIxLjUgMTcgMjEuNUg3QzYuMTcxNTcgMjEuNSA1LjUgMjAuODI4NCA1LjUgMjBWNEM1LjUgMy4xNzE1NyA2LjE3MTU3IDIuNSA3IDIuNVpNMyA0QzMgMS43OTA4NiA0Ljc5MDg2IDAgNyAwSDE3QzE5LjIwOTEgMCAyMSAxLjc5MDg2IDIxIDRWMjBDMjEgMjIuMjA5MSAxOS4yMDkxIDI0IDE3IDI0SDdDNC43OTA4NiAyNCAzIDIyLjIwOTEgMyAyMFY0Wk0xMSA0LjYxNTM4QzEwLjQ0NzcgNC42MTUzOCAxMCA1LjA2MzEgMTAgNS42MTUzOFY2LjM4NDYyQzEwIDYuOTM2OSAxMC40NDc3IDcuMzg0NjIgMTEgNy4zODQ2MkgxM0MxMy41NTIzIDcuMzg0NjIgMTQgNi45MzY5IDE0IDYuMzg0NjJWNS42MTUzOEMxNCA1LjA2MzEgMTMuNTUyMyA0LjYxNTM4IDEzIDQuNjE1MzhIMTFaIiBmaWxsPSIjRENCOEZGIi8+Cjwvc3ZnPgo=';\n\nfunction fromUint8Array(byteArray) {\n    return window.btoa(String.fromCharCode.call(null, ...byteArray));\n}\nfunction toUint8Array(base64EncodedByteArray) {\n    return new Uint8Array(window\n        .atob(base64EncodedByteArray)\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n}\n\nvar _LocalSolanaMobileWalletAdapterWallet_instances, _LocalSolanaMobileWalletAdapterWallet_listeners, _LocalSolanaMobileWalletAdapterWallet_version, _LocalSolanaMobileWalletAdapterWallet_name, _LocalSolanaMobileWalletAdapterWallet_url, _LocalSolanaMobileWalletAdapterWallet_icon, _LocalSolanaMobileWalletAdapterWallet_appIdentity, _LocalSolanaMobileWalletAdapterWallet_authorization, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, _LocalSolanaMobileWalletAdapterWallet_connecting, _LocalSolanaMobileWalletAdapterWallet_connectionGeneration, _LocalSolanaMobileWalletAdapterWallet_chains, _LocalSolanaMobileWalletAdapterWallet_chainSelector, _LocalSolanaMobileWalletAdapterWallet_optionalFeatures, _LocalSolanaMobileWalletAdapterWallet_onWalletNotFound, _LocalSolanaMobileWalletAdapterWallet_on, _LocalSolanaMobileWalletAdapterWallet_emit, _LocalSolanaMobileWalletAdapterWallet_off, _LocalSolanaMobileWalletAdapterWallet_connect, _LocalSolanaMobileWalletAdapterWallet_performAuthorization, _LocalSolanaMobileWalletAdapterWallet_handleAuthorizationResult, _LocalSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult, _LocalSolanaMobileWalletAdapterWallet_performReauthorization, _LocalSolanaMobileWalletAdapterWallet_disconnect, _LocalSolanaMobileWalletAdapterWallet_transact, _LocalSolanaMobileWalletAdapterWallet_assertIsAuthorized, _LocalSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts, _LocalSolanaMobileWalletAdapterWallet_performSignTransactions, _LocalSolanaMobileWalletAdapterWallet_performSignAndSendTransaction, _LocalSolanaMobileWalletAdapterWallet_signAndSendTransaction, _LocalSolanaMobileWalletAdapterWallet_signTransaction, _LocalSolanaMobileWalletAdapterWallet_signMessage, _LocalSolanaMobileWalletAdapterWallet_signIn, _LocalSolanaMobileWalletAdapterWallet_performSignIn, _RemoteSolanaMobileWalletAdapterWallet_instances, _RemoteSolanaMobileWalletAdapterWallet_listeners, _RemoteSolanaMobileWalletAdapterWallet_version, _RemoteSolanaMobileWalletAdapterWallet_name, _RemoteSolanaMobileWalletAdapterWallet_url, _RemoteSolanaMobileWalletAdapterWallet_icon, _RemoteSolanaMobileWalletAdapterWallet_appIdentity, _RemoteSolanaMobileWalletAdapterWallet_authorization, _RemoteSolanaMobileWalletAdapterWallet_authorizationCache, _RemoteSolanaMobileWalletAdapterWallet_connecting, _RemoteSolanaMobileWalletAdapterWallet_connectionGeneration, _RemoteSolanaMobileWalletAdapterWallet_chains, _RemoteSolanaMobileWalletAdapterWallet_chainSelector, _RemoteSolanaMobileWalletAdapterWallet_optionalFeatures, _RemoteSolanaMobileWalletAdapterWallet_onWalletNotFound, _RemoteSolanaMobileWalletAdapterWallet_hostAuthority, _RemoteSolanaMobileWalletAdapterWallet_session, _RemoteSolanaMobileWalletAdapterWallet_on, _RemoteSolanaMobileWalletAdapterWallet_emit, _RemoteSolanaMobileWalletAdapterWallet_off, _RemoteSolanaMobileWalletAdapterWallet_connect, _RemoteSolanaMobileWalletAdapterWallet_performAuthorization, _RemoteSolanaMobileWalletAdapterWallet_handleAuthorizationResult, _RemoteSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult, _RemoteSolanaMobileWalletAdapterWallet_performReauthorization, _RemoteSolanaMobileWalletAdapterWallet_disconnect, _RemoteSolanaMobileWalletAdapterWallet_transact, _RemoteSolanaMobileWalletAdapterWallet_assertIsAuthorized, _RemoteSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts, _RemoteSolanaMobileWalletAdapterWallet_performSignTransactions, _RemoteSolanaMobileWalletAdapterWallet_performSignAndSendTransaction, _RemoteSolanaMobileWalletAdapterWallet_signAndSendTransaction, _RemoteSolanaMobileWalletAdapterWallet_signTransaction, _RemoteSolanaMobileWalletAdapterWallet_signMessage, _RemoteSolanaMobileWalletAdapterWallet_signIn, _RemoteSolanaMobileWalletAdapterWallet_performSignIn;\nconst SolanaMobileWalletAdapterWalletName = 'Mobile Wallet Adapter';\nconst SolanaMobileWalletAdapterRemoteWalletName = 'Remote Mobile Wallet Adapter';\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nconst DEFAULT_FEATURES = [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__.SolanaSignAndSendTransaction, _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__.SolanaSignTransaction, _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__.SolanaSignMessage, _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignIn];\nclass LocalSolanaMobileWalletAdapterWallet {\n    constructor(config) {\n        _LocalSolanaMobileWalletAdapterWallet_instances.add(this);\n        _LocalSolanaMobileWalletAdapterWallet_listeners.set(this, {});\n        _LocalSolanaMobileWalletAdapterWallet_version.set(this, '1.0.0'); // wallet-standard version\n        _LocalSolanaMobileWalletAdapterWallet_name.set(this, SolanaMobileWalletAdapterWalletName);\n        _LocalSolanaMobileWalletAdapterWallet_url.set(this, 'https://solanamobile.com/wallets');\n        _LocalSolanaMobileWalletAdapterWallet_icon.set(this, icon);\n        _LocalSolanaMobileWalletAdapterWallet_appIdentity.set(this, void 0);\n        _LocalSolanaMobileWalletAdapterWallet_authorization.set(this, void 0);\n        _LocalSolanaMobileWalletAdapterWallet_authorizationCache.set(this, void 0);\n        _LocalSolanaMobileWalletAdapterWallet_connecting.set(this, false);\n        /**\n         * Every time the connection is recycled in some way (eg. `disconnect()` is called)\n         * increment this and use it to make sure that `transact` calls from the previous\n         * 'generation' don't continue to do work and throw exceptions.\n         */\n        _LocalSolanaMobileWalletAdapterWallet_connectionGeneration.set(this, 0);\n        _LocalSolanaMobileWalletAdapterWallet_chains.set(this, []);\n        _LocalSolanaMobileWalletAdapterWallet_chainSelector.set(this, void 0);\n        _LocalSolanaMobileWalletAdapterWallet_optionalFeatures.set(this, void 0);\n        _LocalSolanaMobileWalletAdapterWallet_onWalletNotFound.set(this, void 0);\n        _LocalSolanaMobileWalletAdapterWallet_on.set(this, (event, listener) => {\n            var _a;\n            ((_a = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_listeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.push(listener)) || (__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_listeners, \"f\")[event] = [listener]);\n            return () => __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_instances, \"m\", _LocalSolanaMobileWalletAdapterWallet_off).call(this, event, listener);\n        });\n        _LocalSolanaMobileWalletAdapterWallet_connect.set(this, ({ silent } = {}) => __awaiter(this, void 0, void 0, function* () {\n            if (__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_connecting, \"f\") || this.connected) {\n                return { accounts: this.accounts };\n            }\n            __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_connecting, true, \"f\");\n            try {\n                if (silent) {\n                    const cachedAuthorization = yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").get();\n                    if (cachedAuthorization) {\n                        yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult, \"f\").call(this, cachedAuthorization.capabilities);\n                        yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_handleAuthorizationResult, \"f\").call(this, cachedAuthorization);\n                    }\n                    else {\n                        return { accounts: this.accounts };\n                    }\n                }\n                else {\n                    yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performAuthorization, \"f\").call(this);\n                }\n            }\n            catch (e) {\n                throw new Error((e instanceof Error && e.message) || 'Unknown error');\n            }\n            finally {\n                __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_connecting, false, \"f\");\n            }\n            return { accounts: this.accounts };\n        }));\n        _LocalSolanaMobileWalletAdapterWallet_performAuthorization.set(this, (signInPayload) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                const cachedAuthorizationResult = yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").get();\n                if (cachedAuthorizationResult) {\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_handleAuthorizationResult, \"f\").call(this, cachedAuthorizationResult);\n                    return cachedAuthorizationResult;\n                }\n                const selectedChain = yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_chainSelector, \"f\").select(__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_chains, \"f\"));\n                return yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, (wallet) => __awaiter(this, void 0, void 0, function* () {\n                    const [capabilities, mwaAuthorizationResult] = yield Promise.all([\n                        wallet.getCapabilities(),\n                        wallet.authorize({\n                            chain: selectedChain,\n                            identity: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_appIdentity, \"f\"),\n                            sign_in_payload: signInPayload,\n                        })\n                    ]);\n                    const accounts = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts, \"f\").call(this, mwaAuthorizationResult.accounts);\n                    const authorization = Object.assign(Object.assign({}, mwaAuthorizationResult), { accounts, chain: selectedChain, capabilities: capabilities });\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    Promise.all([\n                        __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult, \"f\").call(this, capabilities),\n                        __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").set(authorization),\n                        __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_handleAuthorizationResult, \"f\").call(this, authorization),\n                    ]);\n                    return authorization;\n                }));\n            }\n            catch (e) {\n                throw new Error((e instanceof Error && e.message) || 'Unknown error');\n            }\n        }));\n        _LocalSolanaMobileWalletAdapterWallet_handleAuthorizationResult.set(this, (authorization) => __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const didPublicKeysChange = \n            // Case 1: We started from having no authorization.\n            __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\") == null ||\n                // Case 2: The number of authorized accounts changed.\n                ((_a = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\")) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorization.accounts.length ||\n                // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.\n                __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\").accounts.some((account, ii) => account.address !== authorization.accounts[ii].address);\n            __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, authorization, \"f\");\n            if (didPublicKeysChange) {\n                __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_instances, \"m\", _LocalSolanaMobileWalletAdapterWallet_emit).call(this, 'change', { accounts: this.accounts });\n            }\n        }));\n        _LocalSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult.set(this, (capabilities) => __awaiter(this, void 0, void 0, function* () {\n            // TODO: investigate why using SolanaSignTransactions constant breaks treeshaking\n            const supportsSignTransaction = capabilities.features.includes('solana:signTransactions'); //SolanaSignTransactions);\n            const supportsSignAndSendTransaction = capabilities.supports_sign_and_send_transactions;\n            const didCapabilitiesChange = _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__.SolanaSignAndSendTransaction in this.features !== supportsSignAndSendTransaction ||\n                _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__.SolanaSignTransaction in this.features !== supportsSignTransaction;\n            __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_optionalFeatures, Object.assign(Object.assign({}, ((supportsSignAndSendTransaction || (!supportsSignAndSendTransaction && !supportsSignTransaction)) && {\n                [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__.SolanaSignAndSendTransaction]: {\n                    version: '1.0.0',\n                    supportedTransactionVersions: ['legacy', 0],\n                    signAndSendTransaction: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_signAndSendTransaction, \"f\"),\n                },\n            })), (supportsSignTransaction && {\n                [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__.SolanaSignTransaction]: {\n                    version: '1.0.0',\n                    supportedTransactionVersions: ['legacy', 0],\n                    signTransaction: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_signTransaction, \"f\"),\n                },\n            })), \"f\");\n            if (didCapabilitiesChange) {\n                __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_instances, \"m\", _LocalSolanaMobileWalletAdapterWallet_emit).call(this, 'change', { features: this.features });\n            }\n        }));\n        _LocalSolanaMobileWalletAdapterWallet_performReauthorization.set(this, (wallet, authToken, chain) => __awaiter(this, void 0, void 0, function* () {\n            var _b, _c;\n            try {\n                const [capabilities, mwaAuthorizationResult] = yield Promise.all([\n                    (_c = (_b = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\")) === null || _b === void 0 ? void 0 : _b.capabilities) !== null && _c !== void 0 ? _c : yield wallet.getCapabilities(),\n                    wallet.authorize({\n                        auth_token: authToken,\n                        identity: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_appIdentity, \"f\"),\n                        chain: chain\n                    })\n                ]);\n                const accounts = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts, \"f\").call(this, mwaAuthorizationResult.accounts);\n                const authorization = Object.assign(Object.assign({}, mwaAuthorizationResult), { accounts: accounts, chain: chain, capabilities: capabilities });\n                // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                Promise.all([\n                    __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").set(authorization),\n                    __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_handleAuthorizationResult, \"f\").call(this, authorization),\n                ]);\n            }\n            catch (e) {\n                __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_disconnect, \"f\").call(this);\n                throw new Error((e instanceof Error && e.message) || 'Unknown error');\n            }\n        }));\n        _LocalSolanaMobileWalletAdapterWallet_disconnect.set(this, () => __awaiter(this, void 0, void 0, function* () {\n            var _d;\n            __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n            __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_connecting, false, \"f\");\n            __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_connectionGeneration, (_d = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_connectionGeneration, \"f\"), _d++, _d), \"f\");\n            __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, undefined, \"f\");\n            __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_instances, \"m\", _LocalSolanaMobileWalletAdapterWallet_emit).call(this, 'change', { accounts: this.accounts });\n        }));\n        _LocalSolanaMobileWalletAdapterWallet_transact.set(this, (callback) => __awaiter(this, void 0, void 0, function* () {\n            var _e;\n            const walletUriBase = (_e = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\")) === null || _e === void 0 ? void 0 : _e.wallet_uri_base;\n            const config = walletUriBase ? { baseUri: walletUriBase } : undefined;\n            const currentConnectionGeneration = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_connectionGeneration, \"f\");\n            try {\n                return yield (0,_solana_mobile_mobile_wallet_adapter_protocol__WEBPACK_IMPORTED_MODULE_1__.transact)(callback, config);\n            }\n            catch (e) {\n                if (__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_connectionGeneration, \"f\") !== currentConnectionGeneration) {\n                    yield new Promise(() => { }); // Never resolve.\n                }\n                if (e instanceof Error &&\n                    e.name === 'SolanaMobileWalletAdapterError' &&\n                    e.code === 'ERROR_WALLET_NOT_FOUND') {\n                    yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_onWalletNotFound, \"f\").call(this, this);\n                }\n                throw e;\n            }\n        }));\n        _LocalSolanaMobileWalletAdapterWallet_assertIsAuthorized.set(this, () => {\n            if (!__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\"))\n                throw new Error('Wallet not connected');\n            return { authToken: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\").auth_token, chain: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\").chain };\n        });\n        _LocalSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts.set(this, (accounts) => {\n            return accounts.map((account) => {\n                var _a, _b;\n                const publicKey = toUint8Array(account.address);\n                return {\n                    address: bs58__WEBPACK_IMPORTED_MODULE_2__.encode(publicKey),\n                    publicKey,\n                    label: account.label,\n                    icon: account.icon,\n                    chains: (_a = account.chains) !== null && _a !== void 0 ? _a : __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_chains, \"f\"),\n                    // TODO: get supported features from getCapabilities API \n                    features: (_b = account.features) !== null && _b !== void 0 ? _b : DEFAULT_FEATURES\n                };\n            });\n        });\n        _LocalSolanaMobileWalletAdapterWallet_performSignTransactions.set(this, (transactions) => __awaiter(this, void 0, void 0, function* () {\n            const { authToken, chain } = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_assertIsAuthorized, \"f\").call(this);\n            try {\n                const base64Transactions = transactions.map((tx) => { return fromUint8Array(tx); });\n                return yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, (wallet) => __awaiter(this, void 0, void 0, function* () {\n                    yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performReauthorization, \"f\").call(this, wallet, authToken, chain);\n                    const signedTransactions = (yield wallet.signTransactions({\n                        payloads: base64Transactions,\n                    })).signed_payloads.map(toUint8Array);\n                    return signedTransactions;\n                }));\n            }\n            catch (e) {\n                throw new Error((e instanceof Error && e.message) || 'Unknown error');\n            }\n        }));\n        _LocalSolanaMobileWalletAdapterWallet_performSignAndSendTransaction.set(this, (transaction, options) => __awaiter(this, void 0, void 0, function* () {\n            const { authToken, chain } = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_assertIsAuthorized, \"f\").call(this);\n            try {\n                return yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, (wallet) => __awaiter(this, void 0, void 0, function* () {\n                    const [capabilities, _1] = yield Promise.all([\n                        wallet.getCapabilities(),\n                        __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performReauthorization, \"f\").call(this, wallet, authToken, chain)\n                    ]);\n                    if (capabilities.supports_sign_and_send_transactions) {\n                        const base64Transaction = fromUint8Array(transaction);\n                        const signatures = (yield wallet.signAndSendTransactions(Object.assign(Object.assign({}, options), { payloads: [base64Transaction] }))).signatures.map(toUint8Array);\n                        return signatures[0];\n                    }\n                    else {\n                        throw new Error('connected wallet does not support signAndSendTransaction');\n                    }\n                }));\n            }\n            catch (e) {\n                throw new Error((e instanceof Error && e.message) || 'Unknown error');\n            }\n        }));\n        _LocalSolanaMobileWalletAdapterWallet_signAndSendTransaction.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n            const outputs = [];\n            for (const input of inputs) {\n                const signature = yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performSignAndSendTransaction, \"f\").call(this, input.transaction, input.options);\n                outputs.push({ signature });\n            }\n            return outputs;\n        }));\n        _LocalSolanaMobileWalletAdapterWallet_signTransaction.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n            return (yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performSignTransactions, \"f\").call(this, inputs.map(({ transaction }) => transaction)))\n                .map((signedTransaction) => {\n                return { signedTransaction };\n            });\n        }));\n        _LocalSolanaMobileWalletAdapterWallet_signMessage.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n            const { authToken, chain } = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_assertIsAuthorized, \"f\").call(this);\n            const addresses = inputs.map(({ account }) => fromUint8Array(account.publicKey));\n            const messages = inputs.map(({ message }) => fromUint8Array(message));\n            try {\n                return yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, (wallet) => __awaiter(this, void 0, void 0, function* () {\n                    yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performReauthorization, \"f\").call(this, wallet, authToken, chain);\n                    const signedMessages = (yield wallet.signMessages({\n                        addresses: addresses,\n                        payloads: messages,\n                    })).signed_payloads.map(toUint8Array);\n                    return signedMessages.map((signedMessage) => {\n                        return { signedMessage: signedMessage, signature: signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES) };\n                    });\n                }));\n            }\n            catch (e) {\n                throw new Error((e instanceof Error && e.message) || 'Unknown error');\n            }\n        }));\n        _LocalSolanaMobileWalletAdapterWallet_signIn.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n            const outputs = [];\n            if (inputs.length > 1) {\n                for (const input of inputs) {\n                    outputs.push(yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performSignIn, \"f\").call(this, input));\n                }\n            }\n            else {\n                return [yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performSignIn, \"f\").call(this, inputs[0])];\n            }\n            return outputs;\n        }));\n        _LocalSolanaMobileWalletAdapterWallet_performSignIn.set(this, (input) => __awaiter(this, void 0, void 0, function* () {\n            var _f, _g, _h;\n            __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_connecting, true, \"f\");\n            try {\n                const authorizationResult = yield __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_performAuthorization, \"f\").call(this, Object.assign(Object.assign({}, input), { domain: (_f = input === null || input === void 0 ? void 0 : input.domain) !== null && _f !== void 0 ? _f : window.location.host }));\n                if (!authorizationResult.sign_in_result) {\n                    throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n                }\n                const signedInAddress = authorizationResult.sign_in_result.address;\n                const signedInAccount = authorizationResult.accounts.find(acc => acc.address == signedInAddress);\n                return {\n                    account: Object.assign(Object.assign({}, signedInAccount !== null && signedInAccount !== void 0 ? signedInAccount : {\n                        address: bs58__WEBPACK_IMPORTED_MODULE_2__.encode(toUint8Array(signedInAddress))\n                    }), { publicKey: toUint8Array(signedInAddress), chains: (_g = signedInAccount === null || signedInAccount === void 0 ? void 0 : signedInAccount.chains) !== null && _g !== void 0 ? _g : __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_chains, \"f\"), features: (_h = signedInAccount === null || signedInAccount === void 0 ? void 0 : signedInAccount.features) !== null && _h !== void 0 ? _h : authorizationResult.capabilities.features }),\n                    signedMessage: toUint8Array(authorizationResult.sign_in_result.signed_message),\n                    signature: toUint8Array(authorizationResult.sign_in_result.signature)\n                };\n            }\n            catch (e) {\n                throw new Error((e instanceof Error && e.message) || 'Unknown error');\n            }\n            finally {\n                __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_connecting, false, \"f\");\n            }\n        }));\n        __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, config.authorizationCache, \"f\");\n        __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_appIdentity, config.appIdentity, \"f\");\n        __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_chains, config.chains, \"f\");\n        __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_chainSelector, config.chainSelector, \"f\");\n        __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_onWalletNotFound, config.onWalletNotFound, \"f\");\n        __classPrivateFieldSet$1(this, _LocalSolanaMobileWalletAdapterWallet_optionalFeatures, {\n            // In MWA 1.0, signAndSend is optional and signTransaction is mandatory. Whereas in MWA 2.0+,\n            // signAndSend is mandatory and signTransaction is optional (and soft deprecated). As of mid\n            // 2025, all MWA wallets support both signAndSendTransaction and signTransaction so its safe\n            // assume both are supported here. The features will be updated based on the actual connected \n            // wallets capabilities during connection regardless, so this is safe. \n            [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__.SolanaSignAndSendTransaction]: {\n                version: '1.0.0',\n                supportedTransactionVersions: ['legacy', 0],\n                signAndSendTransaction: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_signAndSendTransaction, \"f\"),\n            },\n            [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__.SolanaSignTransaction]: {\n                version: '1.0.0',\n                supportedTransactionVersions: ['legacy', 0],\n                signTransaction: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_signTransaction, \"f\"),\n            },\n        }, \"f\");\n    }\n    get version() {\n        return __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_version, \"f\");\n    }\n    get name() {\n        return __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_name, \"f\");\n    }\n    get url() {\n        return __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_url, \"f\");\n    }\n    get icon() {\n        return __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_icon, \"f\");\n    }\n    get chains() {\n        return __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_chains, \"f\");\n    }\n    get features() {\n        return Object.assign({ [_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.StandardConnect]: {\n                version: '1.0.0',\n                connect: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_connect, \"f\"),\n            }, [_wallet_standard_features__WEBPACK_IMPORTED_MODULE_8__.StandardDisconnect]: {\n                version: '1.0.0',\n                disconnect: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_disconnect, \"f\"),\n            }, [_wallet_standard_features__WEBPACK_IMPORTED_MODULE_9__.StandardEvents]: {\n                version: '1.0.0',\n                on: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_on, \"f\"),\n            }, [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__.SolanaSignMessage]: {\n                version: '1.0.0',\n                signMessage: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_signMessage, \"f\"),\n            }, [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignIn]: {\n                version: '1.0.0',\n                signIn: __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_signIn, \"f\"),\n            } }, __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_optionalFeatures, \"f\"));\n    }\n    get accounts() {\n        var _a, _b;\n        return (_b = (_a = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\")) === null || _a === void 0 ? void 0 : _a.accounts) !== null && _b !== void 0 ? _b : [];\n    }\n    get connected() {\n        return !!__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\");\n    }\n    get isAuthorized() {\n        return !!__classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\");\n    }\n    get currentAuthorization() {\n        return __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorization, \"f\");\n    }\n    get cachedAuthorizationResult() {\n        return __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").get();\n    }\n}\n_LocalSolanaMobileWalletAdapterWallet_listeners = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_version = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_name = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_url = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_icon = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_appIdentity = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_authorization = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_authorizationCache = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_connecting = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_connectionGeneration = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_chains = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_chainSelector = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_optionalFeatures = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_onWalletNotFound = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_on = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_connect = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_performAuthorization = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_handleAuthorizationResult = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_performReauthorization = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_disconnect = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_transact = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_assertIsAuthorized = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_performSignTransactions = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_performSignAndSendTransaction = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_signAndSendTransaction = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_signTransaction = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_signMessage = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_signIn = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_performSignIn = new WeakMap(), _LocalSolanaMobileWalletAdapterWallet_instances = new WeakSet(), _LocalSolanaMobileWalletAdapterWallet_emit = function _LocalSolanaMobileWalletAdapterWallet_emit(event, ...args) {\n    var _a;\n    // eslint-disable-next-line prefer-spread\n    (_a = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_listeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.forEach((listener) => listener.apply(null, args));\n}, _LocalSolanaMobileWalletAdapterWallet_off = function _LocalSolanaMobileWalletAdapterWallet_off(event, listener) {\n    var _a;\n    __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_listeners, \"f\")[event] = (_a = __classPrivateFieldGet$1(this, _LocalSolanaMobileWalletAdapterWallet_listeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.filter((existingListener) => listener !== existingListener);\n};\nclass RemoteSolanaMobileWalletAdapterWallet {\n    constructor(config) {\n        _RemoteSolanaMobileWalletAdapterWallet_instances.add(this);\n        _RemoteSolanaMobileWalletAdapterWallet_listeners.set(this, {});\n        _RemoteSolanaMobileWalletAdapterWallet_version.set(this, '1.0.0'); // wallet-standard version\n        _RemoteSolanaMobileWalletAdapterWallet_name.set(this, SolanaMobileWalletAdapterRemoteWalletName);\n        _RemoteSolanaMobileWalletAdapterWallet_url.set(this, 'https://solanamobile.com/wallets');\n        _RemoteSolanaMobileWalletAdapterWallet_icon.set(this, icon);\n        _RemoteSolanaMobileWalletAdapterWallet_appIdentity.set(this, void 0);\n        _RemoteSolanaMobileWalletAdapterWallet_authorization.set(this, void 0);\n        _RemoteSolanaMobileWalletAdapterWallet_authorizationCache.set(this, void 0);\n        _RemoteSolanaMobileWalletAdapterWallet_connecting.set(this, false);\n        /**\n         * Every time the connection is recycled in some way (eg. `disconnect()` is called)\n         * increment this and use it to make sure that `transact` calls from the previous\n         * 'generation' don't continue to do work and throw exceptions.\n         */\n        _RemoteSolanaMobileWalletAdapterWallet_connectionGeneration.set(this, 0);\n        _RemoteSolanaMobileWalletAdapterWallet_chains.set(this, []);\n        _RemoteSolanaMobileWalletAdapterWallet_chainSelector.set(this, void 0);\n        _RemoteSolanaMobileWalletAdapterWallet_optionalFeatures.set(this, void 0);\n        _RemoteSolanaMobileWalletAdapterWallet_onWalletNotFound.set(this, void 0);\n        _RemoteSolanaMobileWalletAdapterWallet_hostAuthority.set(this, void 0);\n        _RemoteSolanaMobileWalletAdapterWallet_session.set(this, void 0);\n        _RemoteSolanaMobileWalletAdapterWallet_on.set(this, (event, listener) => {\n            var _a;\n            ((_a = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_listeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.push(listener)) || (__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_listeners, \"f\")[event] = [listener]);\n            return () => __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_instances, \"m\", _RemoteSolanaMobileWalletAdapterWallet_off).call(this, event, listener);\n        });\n        _RemoteSolanaMobileWalletAdapterWallet_connect.set(this, ({ silent } = {}) => __awaiter(this, void 0, void 0, function* () {\n            if (__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connecting, \"f\") || this.connected) {\n                return { accounts: this.accounts };\n            }\n            __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connecting, true, \"f\");\n            try {\n                yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performAuthorization, \"f\").call(this);\n            }\n            catch (e) {\n                throw new Error((e instanceof Error && e.message) || 'Unknown error');\n            }\n            finally {\n                __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connecting, false, \"f\");\n            }\n            return { accounts: this.accounts };\n        }));\n        _RemoteSolanaMobileWalletAdapterWallet_performAuthorization.set(this, (signInPayload) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                const cachedAuthorizationResult = yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").get();\n                if (cachedAuthorizationResult) {\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_handleAuthorizationResult, \"f\").call(this, cachedAuthorizationResult);\n                    return cachedAuthorizationResult;\n                }\n                if (__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, \"f\"))\n                    __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, undefined, \"f\");\n                const selectedChain = yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_chainSelector, \"f\").select(__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_chains, \"f\"));\n                return yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, (wallet) => __awaiter(this, void 0, void 0, function* () {\n                    const [capabilities, mwaAuthorizationResult] = yield Promise.all([\n                        wallet.getCapabilities(),\n                        wallet.authorize({\n                            chain: selectedChain,\n                            identity: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_appIdentity, \"f\"),\n                            sign_in_payload: signInPayload,\n                        })\n                    ]);\n                    const accounts = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts, \"f\").call(this, mwaAuthorizationResult.accounts);\n                    const authorizationResult = Object.assign(Object.assign({}, mwaAuthorizationResult), { accounts, chain: selectedChain, capabilities: capabilities });\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    Promise.all([\n                        __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult, \"f\").call(this, capabilities),\n                        __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").set(authorizationResult),\n                        __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_handleAuthorizationResult, \"f\").call(this, authorizationResult),\n                    ]);\n                    return authorizationResult;\n                }));\n            }\n            catch (e) {\n                throw new Error((e instanceof Error && e.message) || 'Unknown error');\n            }\n        }));\n        _RemoteSolanaMobileWalletAdapterWallet_handleAuthorizationResult.set(this, (authorization) => __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const didPublicKeysChange = \n            // Case 1: We started from having no authorization.\n            __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\") == null ||\n                // Case 2: The number of authorized accounts changed.\n                ((_a = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\")) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorization.accounts.length ||\n                // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.\n                __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\").accounts.some((account, ii) => account.address !== authorization.accounts[ii].address);\n            __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, authorization, \"f\");\n            if (didPublicKeysChange) {\n                __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_instances, \"m\", _RemoteSolanaMobileWalletAdapterWallet_emit).call(this, 'change', { accounts: this.accounts });\n            }\n        }));\n        _RemoteSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult.set(this, (capabilities) => __awaiter(this, void 0, void 0, function* () {\n            // TODO: investigate why using SolanaSignTransactions constant breaks treeshaking\n            const supportsSignTransaction = capabilities.features.includes('solana:signTransactions'); //SolanaSignTransactions);\n            const supportsSignAndSendTransaction = capabilities.supports_sign_and_send_transactions ||\n                capabilities.features.includes('solana:signAndSendTransaction');\n            const didCapabilitiesChange = _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__.SolanaSignAndSendTransaction in this.features !== supportsSignAndSendTransaction ||\n                _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__.SolanaSignTransaction in this.features !== supportsSignTransaction;\n            __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_optionalFeatures, Object.assign(Object.assign({}, (supportsSignAndSendTransaction && {\n                [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__.SolanaSignAndSendTransaction]: {\n                    version: '1.0.0',\n                    supportedTransactionVersions: capabilities.supported_transaction_versions,\n                    signAndSendTransaction: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_signAndSendTransaction, \"f\"),\n                },\n            })), (supportsSignTransaction && {\n                [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__.SolanaSignTransaction]: {\n                    version: '1.0.0',\n                    supportedTransactionVersions: capabilities.supported_transaction_versions,\n                    signTransaction: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_signTransaction, \"f\"),\n                },\n            })), \"f\");\n            if (didCapabilitiesChange) {\n                __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_instances, \"m\", _RemoteSolanaMobileWalletAdapterWallet_emit).call(this, 'change', { features: this.features });\n            }\n        }));\n        _RemoteSolanaMobileWalletAdapterWallet_performReauthorization.set(this, (wallet, authToken, chain) => __awaiter(this, void 0, void 0, function* () {\n            var _b, _c;\n            try {\n                const [capabilities, mwaAuthorizationResult] = yield Promise.all([\n                    (_c = (_b = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\")) === null || _b === void 0 ? void 0 : _b.capabilities) !== null && _c !== void 0 ? _c : yield wallet.getCapabilities(),\n                    wallet.authorize({\n                        auth_token: authToken,\n                        identity: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_appIdentity, \"f\"),\n                        chain: chain\n                    })\n                ]);\n                const accounts = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts, \"f\").call(this, mwaAuthorizationResult.accounts);\n                const authorization = Object.assign(Object.assign({}, mwaAuthorizationResult), { accounts: accounts, chain: chain, capabilities: capabilities });\n                // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                Promise.all([\n                    __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").set(authorization),\n                    __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_handleAuthorizationResult, \"f\").call(this, authorization),\n                ]);\n            }\n            catch (e) {\n                __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_disconnect, \"f\").call(this);\n                throw new Error((e instanceof Error && e.message) || 'Unknown error');\n            }\n        }));\n        _RemoteSolanaMobileWalletAdapterWallet_disconnect.set(this, () => __awaiter(this, void 0, void 0, function* () {\n            var _d;\n            var _e;\n            (_d = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, \"f\")) === null || _d === void 0 ? void 0 : _d.close();\n            __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n            __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connecting, false, \"f\");\n            __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connectionGeneration, (_e = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connectionGeneration, \"f\"), _e++, _e), \"f\");\n            __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, undefined, \"f\");\n            __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, undefined, \"f\");\n            __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_instances, \"m\", _RemoteSolanaMobileWalletAdapterWallet_emit).call(this, 'change', { accounts: this.accounts });\n        }));\n        _RemoteSolanaMobileWalletAdapterWallet_transact.set(this, (callback) => __awaiter(this, void 0, void 0, function* () {\n            var _f;\n            const walletUriBase = (_f = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\")) === null || _f === void 0 ? void 0 : _f.wallet_uri_base;\n            const baseConfig = walletUriBase ? { baseUri: walletUriBase } : undefined;\n            const remoteConfig = Object.assign(Object.assign({}, baseConfig), { remoteHostAuthority: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_hostAuthority, \"f\") });\n            const currentConnectionGeneration = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connectionGeneration, \"f\");\n            const modal = new RemoteConnectionModal();\n            if (__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, \"f\")) {\n                return callback(__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, \"f\").wallet);\n            }\n            try {\n                const { associationUrl, close, wallet } = yield (0,_solana_mobile_mobile_wallet_adapter_protocol__WEBPACK_IMPORTED_MODULE_1__.startRemoteScenario)(remoteConfig);\n                const removeCloseListener = modal.addEventListener('close', (event) => {\n                    if (event)\n                        close();\n                });\n                modal.initWithQR(associationUrl.toString());\n                modal.open();\n                __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, { close, wallet: yield wallet }, \"f\");\n                removeCloseListener();\n                modal.close();\n                return yield callback(__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, \"f\").wallet);\n            }\n            catch (e) {\n                modal.close();\n                if (__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connectionGeneration, \"f\") !== currentConnectionGeneration) {\n                    yield new Promise(() => { }); // Never resolve.\n                }\n                if (e instanceof Error &&\n                    e.name === 'SolanaMobileWalletAdapterError' &&\n                    e.code === 'ERROR_WALLET_NOT_FOUND') {\n                    yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_onWalletNotFound, \"f\").call(this, this);\n                }\n                throw e;\n            }\n        }));\n        _RemoteSolanaMobileWalletAdapterWallet_assertIsAuthorized.set(this, () => {\n            if (!__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\"))\n                throw new Error('Wallet not connected');\n            return { authToken: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\").auth_token, chain: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\").chain };\n        });\n        _RemoteSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts.set(this, (accounts) => {\n            return accounts.map((account) => {\n                var _a, _b;\n                const publicKey = toUint8Array(account.address);\n                return {\n                    address: bs58__WEBPACK_IMPORTED_MODULE_2__.encode(publicKey),\n                    publicKey,\n                    label: account.label,\n                    icon: account.icon,\n                    chains: (_a = account.chains) !== null && _a !== void 0 ? _a : __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_chains, \"f\"),\n                    // TODO: get supported features from getCapabilities API \n                    features: (_b = account.features) !== null && _b !== void 0 ? _b : DEFAULT_FEATURES\n                };\n            });\n        });\n        _RemoteSolanaMobileWalletAdapterWallet_performSignTransactions.set(this, (transactions) => __awaiter(this, void 0, void 0, function* () {\n            const { authToken, chain } = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_assertIsAuthorized, \"f\").call(this);\n            try {\n                return yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, (wallet) => __awaiter(this, void 0, void 0, function* () {\n                    yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performReauthorization, \"f\").call(this, wallet, authToken, chain);\n                    const signedTransactions = (yield wallet.signTransactions({\n                        payloads: transactions.map(fromUint8Array),\n                    })).signed_payloads.map(toUint8Array);\n                    return signedTransactions;\n                }));\n            }\n            catch (e) {\n                throw new Error((e instanceof Error && e.message) || 'Unknown error');\n            }\n        }));\n        _RemoteSolanaMobileWalletAdapterWallet_performSignAndSendTransaction.set(this, (transaction, options) => __awaiter(this, void 0, void 0, function* () {\n            const { authToken, chain } = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_assertIsAuthorized, \"f\").call(this);\n            try {\n                return yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, (wallet) => __awaiter(this, void 0, void 0, function* () {\n                    const [capabilities, _1] = yield Promise.all([\n                        wallet.getCapabilities(),\n                        __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performReauthorization, \"f\").call(this, wallet, authToken, chain)\n                    ]);\n                    if (capabilities.supports_sign_and_send_transactions) {\n                        const signatures = (yield wallet.signAndSendTransactions(Object.assign(Object.assign({}, options), { payloads: [fromUint8Array(transaction)] }))).signatures.map(toUint8Array);\n                        return signatures[0];\n                    }\n                    else {\n                        throw new Error('connected wallet does not support signAndSendTransaction');\n                    }\n                }));\n            }\n            catch (e) {\n                throw new Error((e instanceof Error && e.message) || 'Unknown error');\n            }\n        }));\n        _RemoteSolanaMobileWalletAdapterWallet_signAndSendTransaction.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n            const outputs = [];\n            for (const input of inputs) {\n                const signature = (yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performSignAndSendTransaction, \"f\").call(this, input.transaction, input.options));\n                outputs.push({ signature });\n            }\n            return outputs;\n        }));\n        _RemoteSolanaMobileWalletAdapterWallet_signTransaction.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n            return (yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performSignTransactions, \"f\").call(this, inputs.map(({ transaction }) => transaction)))\n                .map((signedTransaction) => {\n                return { signedTransaction };\n            });\n        }));\n        _RemoteSolanaMobileWalletAdapterWallet_signMessage.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n            const { authToken, chain } = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_assertIsAuthorized, \"f\").call(this);\n            const addresses = inputs.map(({ account }) => fromUint8Array(account.publicKey));\n            const messages = inputs.map(({ message }) => fromUint8Array(message));\n            try {\n                return yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_transact, \"f\").call(this, (wallet) => __awaiter(this, void 0, void 0, function* () {\n                    yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performReauthorization, \"f\").call(this, wallet, authToken, chain);\n                    const signedMessages = (yield wallet.signMessages({\n                        addresses: addresses,\n                        payloads: messages,\n                    })).signed_payloads.map(toUint8Array);\n                    return signedMessages.map((signedMessage) => {\n                        return { signedMessage: signedMessage, signature: signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES) };\n                    });\n                }));\n            }\n            catch (e) {\n                throw new Error((e instanceof Error && e.message) || 'Unknown error');\n            }\n        }));\n        _RemoteSolanaMobileWalletAdapterWallet_signIn.set(this, (...inputs) => __awaiter(this, void 0, void 0, function* () {\n            const outputs = [];\n            if (inputs.length > 1) {\n                for (const input of inputs) {\n                    outputs.push(yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performSignIn, \"f\").call(this, input));\n                }\n            }\n            else {\n                return [yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performSignIn, \"f\").call(this, inputs[0])];\n            }\n            return outputs;\n        }));\n        _RemoteSolanaMobileWalletAdapterWallet_performSignIn.set(this, (input) => __awaiter(this, void 0, void 0, function* () {\n            var _g, _h, _j;\n            __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connecting, true, \"f\");\n            try {\n                const authorizationResult = yield __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_performAuthorization, \"f\").call(this, Object.assign(Object.assign({}, input), { domain: (_g = input === null || input === void 0 ? void 0 : input.domain) !== null && _g !== void 0 ? _g : window.location.host }));\n                if (!authorizationResult.sign_in_result) {\n                    throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n                }\n                const signedInAddress = authorizationResult.sign_in_result.address;\n                const signedInAccount = authorizationResult.accounts.find(acc => acc.address == signedInAddress);\n                return {\n                    account: Object.assign(Object.assign({}, signedInAccount !== null && signedInAccount !== void 0 ? signedInAccount : {\n                        address: bs58__WEBPACK_IMPORTED_MODULE_2__.encode(toUint8Array(signedInAddress))\n                    }), { publicKey: toUint8Array(signedInAddress), chains: (_h = signedInAccount === null || signedInAccount === void 0 ? void 0 : signedInAccount.chains) !== null && _h !== void 0 ? _h : __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_chains, \"f\"), features: (_j = signedInAccount === null || signedInAccount === void 0 ? void 0 : signedInAccount.features) !== null && _j !== void 0 ? _j : authorizationResult.capabilities.features }),\n                    signedMessage: toUint8Array(authorizationResult.sign_in_result.signed_message),\n                    signature: toUint8Array(authorizationResult.sign_in_result.signature)\n                };\n            }\n            catch (e) {\n                throw new Error((e instanceof Error && e.message) || 'Unknown error');\n            }\n            finally {\n                __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connecting, false, \"f\");\n            }\n        }));\n        __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorizationCache, config.authorizationCache, \"f\");\n        __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_appIdentity, config.appIdentity, \"f\");\n        __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_chains, config.chains, \"f\");\n        __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_chainSelector, config.chainSelector, \"f\");\n        __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_hostAuthority, config.remoteHostAuthority, \"f\");\n        __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_onWalletNotFound, config.onWalletNotFound, \"f\");\n        __classPrivateFieldSet$1(this, _RemoteSolanaMobileWalletAdapterWallet_optionalFeatures, {\n            // In MWA 1.0, signAndSend is optional and signTransaction is mandatory. Whereas in MWA 2.0+,\n            // signAndSend is mandatory and signTransaction is optional (and soft deprecated). As of mid\n            // 2025, all MWA wallets support both signAndSendTransaction and signTransaction so its safe\n            // assume both are supported here. The features will be updated based on the actual connected \n            // wallets capabilities during connection regardless, so this is safe. \n            [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__.SolanaSignAndSendTransaction]: {\n                version: '1.0.0',\n                supportedTransactionVersions: ['legacy', 0],\n                signAndSendTransaction: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_signAndSendTransaction, \"f\"),\n            },\n            [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__.SolanaSignTransaction]: {\n                version: '1.0.0',\n                supportedTransactionVersions: ['legacy', 0],\n                signTransaction: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_signTransaction, \"f\"),\n            },\n        }, \"f\");\n    }\n    get version() {\n        return __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_version, \"f\");\n    }\n    get name() {\n        return __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_name, \"f\");\n    }\n    get url() {\n        return __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_url, \"f\");\n    }\n    get icon() {\n        return __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_icon, \"f\");\n    }\n    get chains() {\n        return __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_chains, \"f\");\n    }\n    get features() {\n        return Object.assign({ [_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.StandardConnect]: {\n                version: '1.0.0',\n                connect: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_connect, \"f\"),\n            }, [_wallet_standard_features__WEBPACK_IMPORTED_MODULE_8__.StandardDisconnect]: {\n                version: '1.0.0',\n                disconnect: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_disconnect, \"f\"),\n            }, [_wallet_standard_features__WEBPACK_IMPORTED_MODULE_9__.StandardEvents]: {\n                version: '1.0.0',\n                on: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_on, \"f\"),\n            }, [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__.SolanaSignMessage]: {\n                version: '1.0.0',\n                signMessage: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_signMessage, \"f\"),\n            }, [_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignIn]: {\n                version: '1.0.0',\n                signIn: __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_signIn, \"f\"),\n            } }, __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_optionalFeatures, \"f\"));\n    }\n    get accounts() {\n        var _a, _b;\n        return (_b = (_a = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\")) === null || _a === void 0 ? void 0 : _a.accounts) !== null && _b !== void 0 ? _b : [];\n    }\n    get connected() {\n        return !!__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_session, \"f\") && !!__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\");\n    }\n    get isAuthorized() {\n        return !!__classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\");\n    }\n    get currentAuthorization() {\n        return __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorization, \"f\");\n    }\n    get cachedAuthorizationResult() {\n        return __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_authorizationCache, \"f\").get();\n    }\n}\n_RemoteSolanaMobileWalletAdapterWallet_listeners = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_version = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_name = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_url = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_icon = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_appIdentity = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_authorization = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_authorizationCache = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_connecting = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_connectionGeneration = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_chains = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_chainSelector = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_optionalFeatures = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_onWalletNotFound = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_hostAuthority = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_session = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_on = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_connect = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_performAuthorization = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_handleAuthorizationResult = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_handleWalletCapabilitiesResult = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_performReauthorization = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_disconnect = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_transact = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_assertIsAuthorized = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_accountsToWalletStandardAccounts = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_performSignTransactions = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_performSignAndSendTransaction = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_signAndSendTransaction = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_signTransaction = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_signMessage = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_signIn = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_performSignIn = new WeakMap(), _RemoteSolanaMobileWalletAdapterWallet_instances = new WeakSet(), _RemoteSolanaMobileWalletAdapterWallet_emit = function _RemoteSolanaMobileWalletAdapterWallet_emit(event, ...args) {\n    var _a;\n    // eslint-disable-next-line prefer-spread\n    (_a = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_listeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.forEach((listener) => listener.apply(null, args));\n}, _RemoteSolanaMobileWalletAdapterWallet_off = function _RemoteSolanaMobileWalletAdapterWallet_off(event, listener) {\n    var _a;\n    __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_listeners, \"f\")[event] = (_a = __classPrivateFieldGet$1(this, _RemoteSolanaMobileWalletAdapterWallet_listeners, \"f\")[event]) === null || _a === void 0 ? void 0 : _a.filter((existingListener) => listener !== existingListener);\n};\n\nvar __classPrivateFieldSet = ( false) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = ( false) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _RegisterWalletEvent_detail;\n/**\n * Register a {@link \"@wallet-standard/base\".Wallet} as a Standard Wallet with the app.\n *\n * This dispatches a {@link \"@wallet-standard/base\".WindowRegisterWalletEvent} to notify the app that the Wallet is\n * ready to be registered.\n *\n * This also adds a listener for {@link \"@wallet-standard/base\".WindowAppReadyEvent} to listen for a notification from\n * the app that the app is ready to register the Wallet.\n *\n * This combination of event dispatch and listener guarantees that the Wallet will be registered synchronously as soon\n * as the app is ready whether the Wallet loads before or after the app.\n *\n * @param wallet Wallet to register.\n *\n * @group Wallet\n */\nfunction registerWallet(wallet) {\n    const callback = ({ register }) => register(wallet);\n    try {\n        window.dispatchEvent(new RegisterWalletEvent(callback));\n    }\n    catch (error) {\n        console.error('wallet-standard:register-wallet event could not be dispatched\\n', error);\n    }\n    try {\n        window.addEventListener('wallet-standard:app-ready', ({ detail: api }) => callback(api));\n    }\n    catch (error) {\n        console.error('wallet-standard:app-ready event listener could not be added\\n', error);\n    }\n}\nclass RegisterWalletEvent extends Event {\n    constructor(callback) {\n        super('wallet-standard:register-wallet', {\n            bubbles: false,\n            cancelable: false,\n            composed: false,\n        });\n        _RegisterWalletEvent_detail.set(this, void 0);\n        __classPrivateFieldSet(this, _RegisterWalletEvent_detail, callback, \"f\");\n    }\n    get detail() {\n        return __classPrivateFieldGet(this, _RegisterWalletEvent_detail, \"f\");\n    }\n    get type() {\n        return 'wallet-standard:register-wallet';\n    }\n    /** @deprecated */\n    preventDefault() {\n        throw new Error('preventDefault cannot be called');\n    }\n    /** @deprecated */\n    stopImmediatePropagation() {\n        throw new Error('stopImmediatePropagation cannot be called');\n    }\n    /** @deprecated */\n    stopPropagation() {\n        throw new Error('stopPropagation cannot be called');\n    }\n}\n_RegisterWalletEvent_detail = new WeakMap();\n\n( false) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\n( false) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nfunction getIsLocalAssociationSupported() {\n    return (typeof window !== 'undefined' &&\n        window.isSecureContext &&\n        typeof document !== 'undefined' &&\n        /android/i.test(navigator.userAgent));\n}\nfunction getIsRemoteAssociationSupported() {\n    return (typeof window !== 'undefined' &&\n        window.isSecureContext &&\n        typeof document !== 'undefined' &&\n        !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));\n}\n// Source: https://github.com/anza-xyz/wallet-adapter/blob/master/packages/core/react/src/getEnvironment.ts#L14\n// This is the same implementation that gated MWA in the Anza wallet-adapter-react library.\nfunction isWebView(userAgentString) {\n    return /(WebView|Version\\/.+(Chrome)\\/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)|; wv\\).+(Chrome)\\/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+))/i.test(userAgentString);\n}\n\nfunction registerMwa(config) {\n    if (typeof window === 'undefined') {\n        console.warn(`MWA not registered: no window object`);\n        return;\n    }\n    if (!window.isSecureContext) {\n        console.warn(`MWA not registered: secure context required (https)`);\n        return;\n    }\n    // Local association technically is possible in a webview, but we prevent registration\n    // by default because it usually fails in the most common cases (e.g wallet browsers).\n    if (getIsLocalAssociationSupported() && !isWebView(navigator.userAgent)) {\n        registerWallet(new LocalSolanaMobileWalletAdapterWallet(config));\n    }\n    else if (getIsRemoteAssociationSupported() && config.remoteHostAuthority !== undefined) {\n        registerWallet(new RemoteSolanaMobileWalletAdapterWallet(Object.assign(Object.assign({}, config), { remoteHostAuthority: config.remoteHostAuthority })));\n    }\n    else ;\n}\n\nconst WALLET_NOT_FOUND_ERROR_MESSAGE = 'To use mobile wallet adapter, you must have a compatible mobile wallet application installed on your device.';\nconst BROWSER_NOT_SUPPORTED_ERROR_MESSAGE = 'This browser appears to be incompatible with mobile wallet adapter. Open this page in a compatible mobile browser app and try again.';\nclass ErrorModal extends EmbeddedModal {\n    constructor() {\n        super(...arguments);\n        this.contentStyles = css;\n        this.contentHtml = ErrorDialogHtml;\n    }\n    initWithError(error) {\n        super.init();\n        this.populateError(error);\n    }\n    populateError(error) {\n        var _a, _b;\n        const errorMessageElement = (_a = this.dom) === null || _a === void 0 ? void 0 : _a.getElementById('mobile-wallet-adapter-error-message');\n        const actionBtn = (_b = this.dom) === null || _b === void 0 ? void 0 : _b.getElementById('mobile-wallet-adapter-error-action');\n        if (errorMessageElement) {\n            if (error.name === 'SolanaMobileWalletAdapterError') {\n                switch (error.code) {\n                    case 'ERROR_WALLET_NOT_FOUND':\n                        errorMessageElement.innerHTML = WALLET_NOT_FOUND_ERROR_MESSAGE;\n                        if (actionBtn)\n                            actionBtn.addEventListener('click', () => {\n                                window.location.href = 'https://solanamobile.com/wallets';\n                            });\n                        return;\n                    case 'ERROR_BROWSER_NOT_SUPPORTED':\n                        errorMessageElement.innerHTML = BROWSER_NOT_SUPPORTED_ERROR_MESSAGE;\n                        if (actionBtn)\n                            actionBtn.style.display = 'none';\n                        return;\n                }\n            }\n            errorMessageElement.innerHTML = `An unexpected error occurred: ${error.message}`;\n        }\n        else {\n            console.log('Failed to locate error dialog element');\n        }\n    }\n}\nconst ErrorDialogHtml = `\n<svg class=\"mobile-wallet-adapter-embedded-modal-error-icon\" xmlns=\"http://www.w3.org/2000/svg\" height=\"50px\" viewBox=\"0 -960 960 960\" width=\"50px\" fill=\"#000000\"><path d=\"M 280,-80 Q 197,-80 138.5,-138.5 80,-197 80,-280 80,-363 138.5,-421.5 197,-480 280,-480 q 83,0 141.5,58.5 58.5,58.5 58.5,141.5 0,83 -58.5,141.5 Q 363,-80 280,-80 Z M 824,-120 568,-376 Q 556,-389 542.5,-402.5 529,-416 516,-428 q 38,-24 61,-64 23,-40 23,-88 0,-75 -52.5,-127.5 Q 495,-760 420,-760 345,-760 292.5,-707.5 240,-655 240,-580 q 0,6 0.5,11.5 0.5,5.5 1.5,11.5 -18,2 -39.5,8 -21.5,6 -38.5,14 -2,-11 -3,-22 -1,-11 -1,-23 0,-109 75.5,-184.5 Q 311,-840 420,-840 q 109,0 184.5,75.5 75.5,75.5 75.5,184.5 0,43 -13.5,81.5 Q 653,-460 629,-428 l 251,252 z m -615,-61 71,-71 70,71 29,-28 -71,-71 71,-71 -28,-28 -71,71 -71,-71 -28,28 71,71 -71,71 z\"/></svg>\n<div class=\"mobile-wallet-adapter-embedded-modal-title\">We can't find a wallet.</div>\n<div id=\"mobile-wallet-adapter-error-message\" class=\"mobile-wallet-adapter-embedded-modal-subtitle\"></div>\n<div>\n    <button data-error-action id=\"mobile-wallet-adapter-error-action\" class=\"mobile-wallet-adapter-embedded-modal-error-action\">\n        Find a wallet\n    </button>\n</div>\n`;\nconst css = `\n.mobile-wallet-adapter-embedded-modal-content {\n    text-align: center;\n}\n\n.mobile-wallet-adapter-embedded-modal-error-icon {\n    margin-top: 24px;\n}\n\n.mobile-wallet-adapter-embedded-modal-title {\n    margin: 18px 100px auto 100px;\n    color: #000000;\n    font-size: 2.75em;\n    font-weight: 600;\n}\n\n.mobile-wallet-adapter-embedded-modal-subtitle {\n    margin: 30px 60px 40px 60px;\n    color: #000000;\n    font-size: 1.25em;\n    font-weight: 400;\n}\n\n.mobile-wallet-adapter-embedded-modal-error-action {\n    display: block;\n    width: 100%;\n    height: 56px;\n    /*margin-top: 40px;*/\n    font-size: 1.25em;\n    /*line-height: 24px;*/\n    /*letter-spacing: -1%;*/\n    background: #000000;\n    color: #FFFFFF;\n    border-radius: 18px;\n}\n\n/* Smaller screens */\n@media all and (max-width: 600px) {\n    .mobile-wallet-adapter-embedded-modal-title {\n        font-size: 1.5em;\n        margin-right: 12px;\n        margin-left: 12px;\n    }\n    .mobile-wallet-adapter-embedded-modal-subtitle {\n        margin-right: 12px;\n        margin-left: 12px;\n    }\n}\n`;\n\nfunction defaultErrorModalWalletNotFoundHandler() {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (typeof window !== 'undefined') {\n            const userAgent = window.navigator.userAgent.toLowerCase();\n            const errorDialog = new ErrorModal();\n            if (userAgent.includes('wv')) { // Android WebView\n                // MWA is not supported in this browser so we inform the user\n                // errorDialog.initWithError(\n                //     new SolanaMobileWalletAdapterError(\n                //         SolanaMobileWalletAdapterErrorCode.ERROR_BROWSER_NOT_SUPPORTED, \n                //         ''\n                //     )\n                // );\n                // TODO: investigate why instantiating a new SolanaMobileWalletAdapterError here breaks treeshaking \n                errorDialog.initWithError({\n                    name: 'SolanaMobileWalletAdapterError',\n                    code: 'ERROR_BROWSER_NOT_SUPPORTED',\n                    message: ''\n                });\n            }\n            else { // Browser, user does not have a wallet installed.\n                // errorDialog.initWithError(\n                //     new SolanaMobileWalletAdapterError(\n                //         SolanaMobileWalletAdapterErrorCode.ERROR_WALLET_NOT_FOUND, \n                //         ''\n                //     )\n                // );\n                // TODO: investigate why instantiating a new SolanaMobileWalletAdapterError here breaks treeshaking \n                errorDialog.initWithError({\n                    name: 'SolanaMobileWalletAdapterError',\n                    code: 'ERROR_WALLET_NOT_FOUND',\n                    message: ''\n                });\n            }\n            errorDialog.open();\n        }\n    });\n}\nfunction createDefaultWalletNotFoundHandler() {\n    return () => __awaiter(this, void 0, void 0, function* () { defaultErrorModalWalletNotFoundHandler(); });\n}\n\nconst CACHE_KEY = 'SolanaMobileWalletAdapterDefaultAuthorizationCache';\nfunction createDefaultAuthorizationCache() {\n    let storage;\n    try {\n        storage = window.localStorage;\n        // eslint-disable-next-line no-empty\n    }\n    catch (_a) { }\n    return {\n        clear() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    storage.removeItem(CACHE_KEY);\n                    // eslint-disable-next-line no-empty\n                }\n                catch (_a) { }\n            });\n        },\n        get() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    const parsed = JSON.parse(storage.getItem(CACHE_KEY));\n                    if (parsed && parsed.accounts) {\n                        const parsedAccounts = parsed.accounts.map((account) => {\n                            return Object.assign(Object.assign({}, account), { publicKey: 'publicKey' in account\n                                    ? new Uint8Array(Object.values(account.publicKey)) // Rebuild publicKey for WalletAccount\n                                    : bs58__WEBPACK_IMPORTED_MODULE_2__.decode(account.address) });\n                        });\n                        return Object.assign(Object.assign({}, parsed), { accounts: parsedAccounts });\n                    }\n                    else\n                        return parsed || undefined;\n                    // eslint-disable-next-line no-empty\n                }\n                catch (_a) { }\n            });\n        },\n        set(authorization) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    storage.setItem(CACHE_KEY, JSON.stringify(authorization));\n                    // eslint-disable-next-line no-empty\n                }\n                catch (_a) { }\n            });\n        },\n    };\n}\n\nfunction createDefaultChainSelector() {\n    return {\n        select(chains) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (chains.length === 1) {\n                    return chains[0];\n                }\n                else if (chains.includes(_solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_10__.SOLANA_MAINNET_CHAIN)) {\n                    return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_10__.SOLANA_MAINNET_CHAIN;\n                }\n                else\n                    return chains[0];\n            });\n        },\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LXN0YW5kYXJkLW1vYmlsZS9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdJO0FBQzVHO0FBQ2tFO0FBQ0U7QUFDdEU7QUFDNEM7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsYUFBYSxhQUFhO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLHVDQUF1QztBQUN2QyxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNENBQWUsVUFBVSx1QkFBdUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBGQUE0QixFQUFFLG1GQUFxQixFQUFFLCtFQUFpQixFQUFFLDBFQUFZO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1FQUFtRSxTQUFTLElBQUk7QUFDaEY7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esd0VBQXdFLDZCQUE2Qiw0REFBNEQ7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdLQUF3Syx5QkFBeUI7QUFDak07QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVHQUF1RztBQUN2RztBQUNBLDBDQUEwQywwRkFBNEI7QUFDdEUsZ0JBQWdCLG1GQUFxQjtBQUNyQyxpSUFBaUk7QUFDakksaUJBQWlCLDBGQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLGlCQUFpQixtRkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLHdLQUF3Syx5QkFBeUI7QUFDak07QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxvRUFBb0UsNkJBQTZCLDhEQUE4RDtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0E7QUFDQTtBQUNBLG9LQUFvSyx5QkFBeUI7QUFDN0wsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx5QkFBeUI7QUFDdEU7QUFDQTtBQUNBLDZCQUE2Qix1RkFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsR0FBRztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3Q0FBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0Esc0VBQXNFLDRCQUE0QjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRyxjQUFjLCtCQUErQjtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNKQUFzSixhQUFhO0FBQ25LO0FBQ0EseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLDRDQUE0QyxTQUFTO0FBQ3JELDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlDQUFpQztBQUNqQyxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyTEFBMkwsWUFBWSxpSUFBaUk7QUFDeFU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELGlDQUFpQyx3Q0FBYTtBQUM5QyxxQkFBcUIsS0FBSyw4YkFBOGI7QUFDeGQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEZBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhLG1GQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsQ0FBQyxzRUFBZTtBQUMvQztBQUNBO0FBQ0EsYUFBYSxHQUFHLHlFQUFrQjtBQUNsQztBQUNBO0FBQ0EsYUFBYSxHQUFHLHFFQUFjO0FBQzlCO0FBQ0E7QUFDQSxhQUFhLEdBQUcsK0VBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxhQUFhLEdBQUcsMEVBQVk7QUFDNUI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0VBQW9FLFNBQVMsSUFBSTtBQUNqRjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDhFQUE4RSw2QkFBNkIsNERBQTREO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwS0FBMEsseUJBQXlCO0FBQ25NO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBLDBDQUEwQywwRkFBNEI7QUFDdEUsZ0JBQWdCLG1GQUFxQjtBQUNyQyxrSUFBa0k7QUFDbEksaUJBQWlCLDBGQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLGlCQUFpQixtRkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLDBLQUEwSyx5QkFBeUI7QUFDbk07QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxvRUFBb0UsNkJBQTZCLDhEQUE4RDtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNLQUFzSyx5QkFBeUI7QUFDL0wsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx5QkFBeUI7QUFDMUUsK0RBQStELGlCQUFpQixnSEFBZ0g7QUFDaE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQyxRQUFRLGtHQUFtQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlHQUFpRyw2QkFBNkI7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsR0FBRztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3Q0FBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHLGNBQWMseUNBQXlDO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUpBQXVKLGFBQWE7QUFDcEs7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkMsNENBQTRDLFNBQVM7QUFDckQsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUNBQWlDO0FBQ2pDLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRMQUE0TCxZQUFZLGlJQUFpSTtBQUN6VTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsaUNBQWlDLHdDQUFhO0FBQzlDLHFCQUFxQixLQUFLLCtiQUErYjtBQUN6ZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBGQUE0QjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYSxtRkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLENBQUMsc0VBQWU7QUFDL0M7QUFDQTtBQUNBLGFBQWEsR0FBRyx5RUFBa0I7QUFDbEM7QUFDQTtBQUNBLGFBQWEsR0FBRyxxRUFBYztBQUM5QjtBQUNBO0FBQ0EsYUFBYSxHQUFHLCtFQUFpQjtBQUNqQztBQUNBO0FBQ0EsYUFBYSxHQUFHLDBFQUFZO0FBQzVCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixNQUE2QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQTZDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0NBQXNDO0FBQ3JEO0FBQ0Esc0JBQXNCLHlEQUF5RDtBQUMvRTtBQUNBO0FBQ0Esa0NBQWtDLG1EQUFtRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsTUFBNkM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsTUFBNkM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixhQUFhLGlEQUFpRDtBQUM3SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsY0FBYztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0VBQWdFLDJDQUEyQztBQUMzRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGNBQWM7QUFDL0U7QUFDQSxzQ0FBc0Msd0NBQWEsbUJBQW1CO0FBQ3RFLHlCQUF5QjtBQUN6Qiw2REFBNkQsYUFBYSwwQkFBMEI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpRkFBb0I7QUFDN0QsMkJBQTJCLGlGQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRTZUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVuLWZvcnR1bmUtY29va2llLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEtbW9iaWxlL3dhbGxldC1zdGFuZGFyZC1tb2JpbGUvbGliL2VzbS9pbmRleC5qcz9mZDM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24sIFNvbGFuYVNpZ25UcmFuc2FjdGlvbiwgU29sYW5hU2lnbk1lc3NhZ2UsIFNvbGFuYVNpZ25JbiB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLWZlYXR1cmVzJztcbmltcG9ydCBRUkNvZGUgZnJvbSAncXJjb2RlJztcbmltcG9ydCB7IHRyYW5zYWN0LCBzdGFydFJlbW90ZVNjZW5hcmlvIH0gZnJvbSAnQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sJztcbmltcG9ydCB7IFN0YW5kYXJkQ29ubmVjdCwgU3RhbmRhcmREaXNjb25uZWN0LCBTdGFuZGFyZEV2ZW50cyB9IGZyb20gJ0B3YWxsZXQtc3RhbmRhcmQvZmVhdHVyZXMnO1xuaW1wb3J0IGJhc2U1OCBmcm9tICdiczU4JztcbmltcG9ydCB7IFNPTEFOQV9NQUlOTkVUX0NIQUlOIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtY2hhaW5zJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkMShyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cblxudmFyIF9FbWJlZGRlZE1vZGFsX2luc3RhbmNlcywgX0VtYmVkZGVkTW9kYWxfcm9vdCwgX0VtYmVkZGVkTW9kYWxfZXZlbnRMaXN0ZW5lcnMsIF9FbWJlZGRlZE1vZGFsX2xpc3RlbmVyc0F0dGFjaGVkLCBfRW1iZWRkZWRNb2RhbF9pbmplY3RIVE1MLCBfRW1iZWRkZWRNb2RhbF9hdHRhY2hFdmVudExpc3RlbmVycywgX0VtYmVkZGVkTW9kYWxfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsIF9FbWJlZGRlZE1vZGFsX2hhbmRsZUtleURvd247XG5jb25zdCBtb2RhbEh0bWwgPSBgXG48ZGl2IGNsYXNzPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNvbnRhaW5lclwiIHJvbGU9XCJkaWFsb2dcIiBhcmlhLW1vZGFsPVwidHJ1ZVwiIGFyaWEtbGFiZWxsZWRieT1cIm1vZGFsLXRpdGxlXCI+XG4gICAgPGRpdiBkYXRhLW1vZGFsLWNsb3NlIHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1wiPjwvZGl2PlxuXHQ8ZGl2IGNsYXNzPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNhcmRcIj5cblx0XHQ8ZGl2PlxuXHRcdFx0PGJ1dHRvbiBkYXRhLW1vZGFsLWNsb3NlIGNsYXNzPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNsb3NlXCI+XG5cdFx0XHRcdDxzdmcgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCI+XG5cdFx0XHRcdFx0PHBhdGggZD1cIk0gNi43MTI1LDguMzAzNjk5NSAxLjkwODIsMTMuMTA4MTk5IGMgLTAuMjExMywwLjIxMTIgLTAuNDc2NSwwLjMxNjggLTAuNzk1NywwLjMxNjggLTAuMzE5MiwwIC0wLjU4NDQsLTAuMTA1NiAtMC43OTU4LC0wLjMxNjggQyAwLjEwNTYsMTIuODk2ODk5IDAsMTIuNjMxNjk5IDAsMTIuMzEyNDk5IGMgMCwtMC4zMTkyIDAuMTA1NiwtMC41ODQ0IDAuMzE2NywtMC43OTU4IEwgNS4xMjEyLDYuNzEyNDk5NSAwLjMxNjcsMS45MDgyIEMgMC4xMDU2LDEuNjk2OSAwLDEuNDMxNyAwLDEuMTEyNSAwLDAuNzkzMyAwLjEwNTYsMC41MjgxIDAuMzE2NywwLjMxNjcgMC41MjgxLDAuMTA1NiAwLjc5MzMsMCAxLjExMjUsMCAxLjQzMTcsMCAxLjY5NjksMC4xMDU2IDEuOTA4MiwwLjMxNjcgTCA2LjcxMjUsNS4xMjEyIDExLjUxNjcsMC4zMTY3IEMgMTEuNzI4MSwwLjEwNTYgMTEuOTkzMywwIDEyLjMxMjUsMCBjIDAuMzE5MiwwIDAuNTg0NCwwLjEwNTYgMC43OTU3LDAuMzE2NyAwLjIxMTIsMC4yMTE0IDAuMzE2OCwwLjQ3NjYgMC4zMTY4LDAuNzk1OCAwLDAuMzE5MiAtMC4xMDU2LDAuNTg0NCAtMC4zMTY4LDAuNzk1NyBMIDguMzAzNzAwMSw2LjcxMjQ5OTUgMTMuMTA4MiwxMS41MTY2OTkgYyAwLjIxMTIsMC4yMTE0IDAuMzE2OCwwLjQ3NjYgMC4zMTY4LDAuNzk1OCAwLDAuMzE5MiAtMC4xMDU2LDAuNTg0NCAtMC4zMTY4LDAuNzk1NyAtMC4yMTEzLDAuMjExMiAtMC40NzY1LDAuMzE2OCAtMC43OTU3LDAuMzE2OCAtMC4zMTkyLDAgLTAuNTg0NCwtMC4xMDU2IC0wLjc5NTgsLTAuMzE2OCB6XCIgLz5cblx0XHRcdFx0PC9zdmc+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2IGNsYXNzPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNvbnRlbnRcIj48L2Rpdj5cblx0PC9kaXY+XG48L2Rpdj5cbmA7XG5jb25zdCBjc3MkMiA9IGBcbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY29udGFpbmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4OyAvKiBVc2UgZmxleGJveCB0byBjZW50ZXIgY29udGVudCAqL1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyOyAvKiBDZW50ZXIgaG9yaXpvbnRhbGx5ICovXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjsgLyogQ2VudGVyIHZlcnRpY2FsbHkgKi9cbiAgICBwb3NpdGlvbjogZml4ZWQ7IC8qIFN0YXkgaW4gcGxhY2UgKi9cbiAgICB6LWluZGV4OiAxOyAvKiBTaXQgb24gdG9wICovXG4gICAgbGVmdDogMDtcbiAgICB0b3A6IDA7XG4gICAgd2lkdGg6IDEwMCU7IC8qIEZ1bGwgd2lkdGggKi9cbiAgICBoZWlnaHQ6IDEwMCU7IC8qIEZ1bGwgaGVpZ2h0ICovXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLDAsMCwwLjQpOyAvKiBCbGFjayB3LyBvcGFjaXR5ICovXG4gICAgb3ZlcmZsb3cteTogYXV0bzsgLyogZW5hYmxlIHNjcm9sbGluZyAqL1xufVxuXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNhcmQge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBtYXJnaW46IGF1dG8gMjBweDtcbiAgICBtYXgtd2lkdGg6IDc4MHB4O1xuICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgYm9yZGVyLXJhZGl1czogMjRweDtcbiAgICBiYWNrZ3JvdW5kOiAjZmZmZmZmO1xuICAgIGZvbnQtZmFtaWx5OiBcIkludGVyIFRpZ2h0XCIsIFwiUFQgU2Fuc1wiLCBDYWxpYnJpLCBzYW5zLXNlcmlmO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMjAwJSk7XG4gICAgYW5pbWF0aW9uOiBzbGlkZS1pbiAwLjVzIGZvcndhcmRzO1xufVxuXG5Aa2V5ZnJhbWVzIHNsaWRlLWluIHtcbiAgICAxMDAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKTsgfVxufVxuXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNsb3NlIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgd2lkdGg6IDMycHg7XG4gICAgaGVpZ2h0OiAzMnB4O1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBiYWNrZ3JvdW5kOiAjZTRlOWU5O1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG59XG5cbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY2xvc2U6Zm9jdXMtdmlzaWJsZSB7XG4gICAgb3V0bGluZS1jb2xvcjogcmVkO1xufVxuXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNsb3NlIHN2ZyB7XG4gICAgZmlsbDogIzU0NjI2NjtcbiAgICB0cmFuc2l0aW9uOiBmaWxsIDIwMG1zIGVhc2UgMHM7XG59XG5cbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY2xvc2U6aG92ZXIgc3ZnIHtcbiAgICBmaWxsOiAjZmZmO1xufVxuYDtcbmNvbnN0IGZvbnRzID0gYFxuPGxpbmsgcmVsPVwicHJlY29ubmVjdFwiIGhyZWY9XCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tXCI+XG48bGluayByZWw9XCJwcmVjb25uZWN0XCIgaHJlZj1cImh0dHBzOi8vZm9udHMuZ3N0YXRpYy5jb21cIiBjcm9zc29yaWdpbj5cbjxsaW5rIGhyZWY9XCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/ZmFtaWx5PUludGVyK1RpZ2h0Oml0YWwsd2dodEAwLDEwMC4uOTAwOzEsMTAwLi45MDAmZGlzcGxheT1zd2FwXCIgcmVsPVwic3R5bGVzaGVldFwiPlxuYDtcbmNsYXNzIEVtYmVkZGVkTW9kYWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBfRW1iZWRkZWRNb2RhbF9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICBfRW1iZWRkZWRNb2RhbF9yb290LnNldCh0aGlzLCBudWxsKTtcbiAgICAgICAgX0VtYmVkZGVkTW9kYWxfZXZlbnRMaXN0ZW5lcnMuc2V0KHRoaXMsIHt9KTtcbiAgICAgICAgX0VtYmVkZGVkTW9kYWxfbGlzdGVuZXJzQXR0YWNoZWQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgICAgICB0aGlzLm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdNb2RhbCBvcGVuJyk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0VtYmVkZGVkTW9kYWxfaW5zdGFuY2VzLCBcIm1cIiwgX0VtYmVkZGVkTW9kYWxfYXR0YWNoRXZlbnRMaXN0ZW5lcnMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9FbWJlZGRlZE1vZGFsX3Jvb3QsIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfRW1iZWRkZWRNb2RhbF9yb290LCBcImZcIikuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbG9zZSA9IChldmVudCA9IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnTW9kYWwgY2xvc2UnKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfRW1iZWRkZWRNb2RhbF9pbnN0YW5jZXMsIFwibVwiLCBfRW1iZWRkZWRNb2RhbF9yZW1vdmVFdmVudExpc3RlbmVycykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0VtYmVkZGVkTW9kYWxfcm9vdCwgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9FbWJlZGRlZE1vZGFsX3Jvb3QsIFwiZlwiKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9hID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9FbWJlZGRlZE1vZGFsX2V2ZW50TGlzdGVuZXJzLCBcImZcIilbJ2Nsb3NlJ10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZXZlbnQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX0VtYmVkZGVkTW9kYWxfaGFuZGxlS2V5RG93bi5zZXQodGhpcywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJylcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEJpbmQgbWV0aG9kcyB0byBlbnN1cmUgYHRoaXNgIGNvbnRleHQgaXMgY29ycmVjdFxuICAgICAgICB0aGlzLmluaXQgPSB0aGlzLmluaXQuYmluZCh0aGlzKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9FbWJlZGRlZE1vZGFsX3Jvb3QsIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtcm9vdC11aScpLCBcImZcIik7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSW5qZWN0aW5nIG1vZGFsJyk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0VtYmVkZGVkTW9kYWxfaW5zdGFuY2VzLCBcIm1cIiwgX0VtYmVkZGVkTW9kYWxfaW5qZWN0SFRNTCkuY2FsbCh0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKChfYSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfRW1iZWRkZWRNb2RhbF9ldmVudExpc3RlbmVycywgXCJmXCIpW2V2ZW50XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnB1c2gobGlzdGVuZXIpKSB8fCAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9FbWJlZGRlZE1vZGFsX2V2ZW50TGlzdGVuZXJzLCBcImZcIilbZXZlbnRdID0gW2xpc3RlbmVyXSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0VtYmVkZGVkTW9kYWxfZXZlbnRMaXN0ZW5lcnMsIFwiZlwiKVtldmVudF0gPSAoX2EgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0VtYmVkZGVkTW9kYWxfZXZlbnRMaXN0ZW5lcnMsIFwiZlwiKVtldmVudF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIoKGV4aXN0aW5nTGlzdGVuZXIpID0+IGxpc3RlbmVyICE9PSBleGlzdGluZ0xpc3RlbmVyKTtcbiAgICB9XG59XG5fRW1iZWRkZWRNb2RhbF9yb290ID0gbmV3IFdlYWtNYXAoKSwgX0VtYmVkZGVkTW9kYWxfZXZlbnRMaXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpLCBfRW1iZWRkZWRNb2RhbF9saXN0ZW5lcnNBdHRhY2hlZCA9IG5ldyBXZWFrTWFwKCksIF9FbWJlZGRlZE1vZGFsX2hhbmRsZUtleURvd24gPSBuZXcgV2Vha01hcCgpLCBfRW1iZWRkZWRNb2RhbF9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfRW1iZWRkZWRNb2RhbF9pbmplY3RIVE1MID0gZnVuY3Rpb24gX0VtYmVkZGVkTW9kYWxfaW5qZWN0SFRNTCgpIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgSFRNTCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtcm9vdC11aScpKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9FbWJlZGRlZE1vZGFsX3Jvb3QsIFwiZlwiKSlcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkMSh0aGlzLCBfRW1iZWRkZWRNb2RhbF9yb290LCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLXJvb3QtdWknKSwgXCJmXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIGNvbnRhaW5lciBmb3IgdGhlIG1vZGFsXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9FbWJlZGRlZE1vZGFsX3Jvb3QsIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBcImZcIik7XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9FbWJlZGRlZE1vZGFsX3Jvb3QsIFwiZlwiKS5pZCA9ICdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtcm9vdC11aSc7XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9FbWJlZGRlZE1vZGFsX3Jvb3QsIFwiZlwiKS5pbm5lckhUTUwgPSBtb2RhbEh0bWw7XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9FbWJlZGRlZE1vZGFsX3Jvb3QsIFwiZlwiKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIC8vIEFkZCBtb2RhbCBjb250ZW50XG4gICAgY29uc3QgY29udGVudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfRW1iZWRkZWRNb2RhbF9yb290LCBcImZcIikucXVlcnlTZWxlY3RvcignLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jb250ZW50Jyk7XG4gICAgaWYgKGNvbnRlbnQpXG4gICAgICAgIGNvbnRlbnQuaW5uZXJIVE1MID0gdGhpcy5jb250ZW50SHRtbDtcbiAgICAvLyBBcHBseSBzdHlsZXNcbiAgICBjb25zdCBzdHlsZXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlcy5pZCA9ICdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtc3R5bGVzJztcbiAgICBzdHlsZXMudGV4dENvbnRlbnQgPSBjc3MkMiArIHRoaXMuY29udGVudFN0eWxlcztcbiAgICAvLyBDcmVhdGUgYSBzaGFkb3cgRE9NIHRvIGVuY2Fwc3VsYXRlIHRoZSBtb2RhbFxuICAgIGNvbnN0IGhvc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBob3N0LmlubmVySFRNTCA9IGZvbnRzO1xuICAgIHRoaXMuZG9tID0gaG9zdC5hdHRhY2hTaGFkb3coeyBtb2RlOiAnY2xvc2VkJyB9KTtcbiAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChzdHlsZXMpO1xuICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfRW1iZWRkZWRNb2RhbF9yb290LCBcImZcIikpO1xuICAgIC8vIEFwcGVuZCB0aGUgc2hhZG93IERPTSBob3N0IHRvIHRoZSBib2R5XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChob3N0KTtcbn0sIF9FbWJlZGRlZE1vZGFsX2F0dGFjaEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX0VtYmVkZGVkTW9kYWxfYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0VtYmVkZGVkTW9kYWxfcm9vdCwgXCJmXCIpIHx8IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfRW1iZWRkZWRNb2RhbF9saXN0ZW5lcnNBdHRhY2hlZCwgXCJmXCIpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgY2xvc2VycyA9IFsuLi5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0VtYmVkZGVkTW9kYWxfcm9vdCwgXCJmXCIpLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW1vZGFsLWNsb3NlXScpXTtcbiAgICBjbG9zZXJzLmZvckVhY2goY2xvc2VyID0+IGNsb3NlciA9PT0gbnVsbCB8fCBjbG9zZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuY2xvc2UpKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuY2xvc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0VtYmVkZGVkTW9kYWxfaGFuZGxlS2V5RG93biwgXCJmXCIpKTtcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDEodGhpcywgX0VtYmVkZGVkTW9kYWxfbGlzdGVuZXJzQXR0YWNoZWQsIHRydWUsIFwiZlwiKTtcbn0sIF9FbWJlZGRlZE1vZGFsX3JlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX0VtYmVkZGVkTW9kYWxfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0VtYmVkZGVkTW9kYWxfbGlzdGVuZXJzQXR0YWNoZWQsIFwiZlwiKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5jbG9zZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfRW1iZWRkZWRNb2RhbF9oYW5kbGVLZXlEb3duLCBcImZcIikpO1xuICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9FbWJlZGRlZE1vZGFsX3Jvb3QsIFwiZlwiKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNsb3NlcnMgPSBbLi4uX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9FbWJlZGRlZE1vZGFsX3Jvb3QsIFwiZlwiKS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1tb2RhbC1jbG9zZV0nKV07XG4gICAgY2xvc2Vycy5mb3JFYWNoKGNsb3NlciA9PiBjbG9zZXIgPT09IG51bGwgfHwgY2xvc2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsb3NlKSk7XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9FbWJlZGRlZE1vZGFsX2xpc3RlbmVyc0F0dGFjaGVkLCBmYWxzZSwgXCJmXCIpO1xufTtcblxuY2xhc3MgUmVtb3RlQ29ubmVjdGlvbk1vZGFsIGV4dGVuZHMgRW1iZWRkZWRNb2RhbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY29udGVudFN0eWxlcyA9IGNzcyQxO1xuICAgICAgICB0aGlzLmNvbnRlbnRIdG1sID0gUVJDb2RlSHRtbDtcbiAgICB9XG4gICAgaW5pdFdpdGhRUihxckNvZGUpIHtcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBpbml0OiB7IGdldDogKCkgPT4gc3VwZXIuaW5pdCB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgX3N1cGVyLmluaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGVRUkNvZGUocXJDb2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvcHVsYXRlUVJDb2RlKHFyVXJsKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHFyY29kZUNvbnRhaW5lciA9IChfYSA9IHRoaXMuZG9tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0RWxlbWVudEJ5SWQoJ21vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1xci1jb2RlLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgaWYgKHFyY29kZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHFyQ29kZUVsZW1lbnQgPSB5aWVsZCBRUkNvZGUudG9DYW52YXMocXJVcmwsIHsgd2lkdGg6IDIwMCwgbWFyZ2luOiAwIH0pO1xuICAgICAgICAgICAgICAgIGlmIChxcmNvZGVDb250YWluZXIuZmlyc3RFbGVtZW50Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcXJjb2RlQ29udGFpbmVyLnJlcGxhY2VDaGlsZChxckNvZGVFbGVtZW50LCBxcmNvZGVDb250YWluZXIuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHFyY29kZUNvbnRhaW5lci5hcHBlbmRDaGlsZChxckNvZGVFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1FSQ29kZSBDb250YWluZXIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNvbnN0IFFSQ29kZUh0bWwgPSBgXG48ZGl2IGNsYXNzPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXFyLWNvbnRlbnRcIj5cbiAgICA8ZGl2PlxuICAgICAgICA8c3ZnIGNsYXNzPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWljb25cIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCI+XG4gICAgICAgICAgICA8Y2lyY2xlIHI9XCI1MlwiIGN4PVwiNTNcIiBjeT1cIjUzXCIgZmlsbD1cIiM5OWIzYmVcIiBzdHJva2U9XCIjMDAwMDAwXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJtIDUzLDgyLjczMDUgYyAtMy4zMTE2LDAgLTYuMTM2MSwtMS4xNjkgLTguNDczNSwtMy41MDcgLTIuMzM4LC0yLjMzOCAtMy41MDcsLTUuMTYyNSAtMy41MDcsLTguNDczNSAwLC0zLjMxMTYgMS4xNjksLTYuMTM2NCAzLjUwNywtOC40NzQ0IDIuMzM3NCwtMi4zMzggNS4xNjE5LC0zLjUwNyA4LjQ3MzUsLTMuNTA3IDMuMzExNiwwIDYuMTM2MSwxLjE2OSA4LjQ3MzUsMy41MDcgMi4zMzgsMi4zMzggMy41MDcsNS4xNjI4IDMuNTA3LDguNDc0NCAwLDMuMzExIC0xLjE2OSw2LjEzNTUgLTMuNTA3LDguNDczNSAtMi4zMzc0LDIuMzM4IC01LjE2MTksMy41MDcgLTguNDczNSwzLjUwNyB6IG0gMC4wMDcsLTUuMjUgYyAxLjg1MzIsMCAzLjQzNywtMC42NTk4IDQuNzUxMiwtMS45NzkzIDEuMzE0OSwtMS4zMTk1IDEuOTcyMywtMi45MDU4IDEuOTcyMywtNC43NTkxIDAsLTEuODUyNiAtMC42NTk4LC0zLjQzNjQgLTEuOTc5MywtNC43NTEyIC0xLjMxOTUsLTEuMzE0OSAtMi45MDU1LC0xLjk3MjMgLTQuNzU4MiwtMS45NzIzIC0xLjg1MzMsMCAtMy40MzcsMC42NTk4IC00Ljc1MTMsMS45NzkzIC0xLjMxNDgsMS4zMTk1IC0xLjk3MjIsMi45MDU4IC0xLjk3MjIsNC43NTkxIDAsMS44NTI3IDAuNjU5NywzLjQzNjQgMS45NzkyLDQuNzUxMiAxLjMxOTUsMS4zMTQ5IDIuOTA1NiwxLjk3MjMgNC43NTgzLDEuOTcyMyB6IG0gLTI4LC0zMy41NzI5IC0zLjg1LC0zLjYzNDcgYyA0LjExOTUsLTQuMDI1IDguODc5MiwtNy4xOTg0IDE0LjI3OTEsLTkuNTIgNS40MDA1LC0yLjMyMjMgMTEuMjU1MSwtMy40ODM0IDE3LjU2MzksLTMuNDgzNCA2LjMwODcsMCAxMi4xNjM0LDEuMTYxMSAxNy41NjM5LDMuNDgzNCA1LjM5OTksMi4zMjE2IDEwLjE1OTYsNS40OTUgMTQuMjc5MSw5LjUyIGwgLTMuODUsMy42MzQ3IEMgNzcuMjk5OSw0MC4zNTggNzMuMDY4NCwzNy41NzI2IDY4LjI5ODUsMzUuNTUxNCA2My41MjkyLDMzLjUzMDEgNTguNDI5NiwzMi41MTk1IDUzLDMyLjUxOTUgYyAtNS40Mjk3LDAgLTEwLjUyOTIsMS4wMTA2IC0xNS4yOTg1LDMuMDMxOSAtNC43Njk5LDIuMDIxMiAtOS4wMDE0LDQuODA2NiAtMTIuNjk0NSw4LjM1NjIgeiBtIDQ0LjYyNSwxMC44NzcxIGMgLTIuMjcwOSwtMi4xMDQ2IC00Ljc5NjIsLTMuNzE2NyAtNy41NzU4LC00LjgzNjEgLTIuNzc5NSwtMS4xMiAtNS43OTgzLC0xLjY4IC05LjA1NjIsLTEuNjggLTMuMjU3OSwwIC02LjI2MjEsMC41NiAtOS4wMTI1LDEuNjggLTIuNzUwNCwxLjExOTQgLTUuMjkwMywyLjczMTUgLTcuNjE5NSw0LjgzNjEgTCAzMi41MTg5LDUxLjE1IGMgMi44MzU1LC0yLjYwMjggNS45Nzc3LC00LjYwODYgOS40MjYzLC02LjAxNzQgMy40NDgxLC0xLjQwODcgNy4xMzMsLTIuMTEzMSAxMS4wNTQ4LC0yLjExMzEgMy45MjE3LDAgNy41OTc5LDAuNzA0NCAxMS4wMjg1LDIuMTEzMSAzLjQzLDEuNDA4OCA2LjU2MzEsMy40MTQ2IDkuMzk5Miw2LjAxNzQgelwiLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtdGl0bGVcIj5SZW1vdGUgTW9iaWxlIFdhbGxldCBBZGFwdGVyPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdj5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxoNCBjbGFzcz1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1xci1sYWJlbFwiPlxuICAgICAgICAgICAgICAgIE9wZW4geW91ciB3YWxsZXQgYW5kIHNjYW4gdGhpcyBjb2RlXG4gICAgICAgICAgICA8L2g0PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1xci1jb2RlLWNvbnRhaW5lclwiIGNsYXNzPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXFyLWNvZGUtY29udGFpbmVyXCI+PC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5cbjxkaXYgY2xhc3M9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtZGl2aWRlclwiPjxocj48L2Rpdj5cbjxkaXYgY2xhc3M9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtZm9vdGVyXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1zdWJ0aXRsZVwiPlxuICAgICAgICBGb2xsb3cgdGhlIGluc3RydWN0aW9ucyBvbiB5b3VyIGRldmljZS4gV2hlbiB5b3UncmUgZmluaXNoZWQsIHRoaXMgc2NyZWVuIHdpbGwgdXBkYXRlLlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtcHJvZ3Jlc3MtYmFkZ2VcIj5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzcGlubmVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxlZnRXcmFwcGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyaWdodFdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2lyY2xlXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2PldhaXRpbmcgZm9yIHNjYW48L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYDtcbmNvbnN0IGNzcyQxID0gYFxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1xci1jb250ZW50IHtcbiAgICBkaXNwbGF5OiBmbGV4OyBcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICAgIHBhZGRpbmc6IDEwcHg7XG59XG5cbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtcXItY29udGVudCA+IGRpdjpmaXJzdC1jaGlsZCB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGZsZXg6IDI7XG4gICAgbWFyZ2luLXRvcDogYXV0bztcbiAgICBtYXJnaW4tcmlnaHQ6IDMwcHg7XG59XG5cbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtcXItY29udGVudCA+IGRpdjpudGgtY2hpbGQoMikge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBmbGV4OiAxO1xuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xufVxuXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWZvb3RlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwYWRkaW5nOiAxMHB4O1xufVxuXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWljb24ge31cblxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC10aXRsZSB7XG4gICAgY29sb3I6ICMwMDAwMDA7XG4gICAgZm9udC1zaXplOiAyLjVlbTtcbiAgICBmb250LXdlaWdodDogNjAwO1xufVxuXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXFyLWxhYmVsIHtcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICBjb2xvcjogIzAwMDAwMDtcbn1cblxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1xci1jb2RlLWNvbnRhaW5lciB7XG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XG59XG5cbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtZGl2aWRlciB7XG4gICAgbWFyZ2luLXRvcDogMjBweDtcbiAgICBwYWRkaW5nLWxlZnQ6IDEwcHg7XG4gICAgcGFkZGluZy1yaWdodDogMTBweDtcbn1cblxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1kaXZpZGVyIGhyIHtcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgI0Q5REVERTtcbn1cblxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1zdWJ0aXRsZSB7XG4gICAgbWFyZ2luOiBhdXRvO1xuICAgIG1hcmdpbi1yaWdodDogNjBweDtcbiAgICBwYWRkaW5nOiAyMHB4O1xuICAgIGNvbG9yOiAjNkU4Mjg2O1xufVxuXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXByb2dyZXNzLWJhZGdlIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGJhY2tncm91bmQ6ICNGN0Y4Rjg7XG4gICAgaGVpZ2h0OiA1NnB4O1xuICAgIG1pbi13aWR0aDogMjAwcHg7XG4gICAgbWFyZ2luOiBhdXRvO1xuICAgIHBhZGRpbmctbGVmdDogMjBweDtcbiAgICBwYWRkaW5nLXJpZ2h0OiAyMHB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDE4cHg7XG4gICAgY29sb3I6ICNBOEI2Qjg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cblxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1wcm9ncmVzcy1iYWRnZSA+IGRpdjpmaXJzdC1jaGlsZCB7XG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XG4gICAgbWFyZ2luLXJpZ2h0OiAyMHB4O1xufVxuXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXByb2dyZXNzLWJhZGdlID4gZGl2Om50aC1jaGlsZCgyKSB7XG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xufVxuXG4vKiBTbWFsbGVyIHNjcmVlbnMgKi9cbkBtZWRpYSBhbGwgYW5kIChtYXgtd2lkdGg6IDYwMHB4KSB7XG4gICAgLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jYXJkIHtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIH1cbiAgICAubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXFyLWNvbnRlbnQge1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIH1cbiAgICAubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXFyLWNvbnRlbnQgPiBkaXY6Zmlyc3QtY2hpbGQge1xuICAgICAgICBtYXJnaW46IGF1dG87XG4gICAgfVxuICAgIC5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtcXItY29udGVudCA+IGRpdjpudGgtY2hpbGQoMikge1xuICAgICAgICBtYXJnaW46IGF1dG87XG4gICAgICAgIGZsZXg6IDIgYXV0bztcbiAgICB9XG4gICAgLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1mb290ZXIge1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIH1cbiAgICAubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWljb24ge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgICAubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXRpdGxlIHtcbiAgICAgICAgZm9udC1zaXplOiAxLjVlbTtcbiAgICB9XG4gICAgLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1zdWJ0aXRsZSB7XG4gICAgICAgIG1hcmdpbi1yaWdodDogdW5zZXQ7XG4gICAgfVxuICAgIC5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtcXItbGFiZWwge1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfVxuICAgIC5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtcXItY29kZS1jb250YWluZXIge1xuICAgICAgICBtYXJnaW46IGF1dG87XG4gICAgfVxufVxuXG4vKiBTcGlubmVyICovXG5Aa2V5ZnJhbWVzIHNwaW5MZWZ0IHtcbiAgICAwJSB7XG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDIwZGVnKTtcbiAgICB9XG4gICAgNTAlIHtcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMTYwZGVnKTtcbiAgICB9XG4gICAgMTAwJSB7XG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDIwZGVnKTtcbiAgICB9XG59XG5Aa2V5ZnJhbWVzIHNwaW5SaWdodCB7XG4gICAgMCUge1xuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxNjBkZWcpO1xuICAgIH1cbiAgICA1MCUge1xuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgyMGRlZyk7XG4gICAgfVxuICAgIDEwMCUge1xuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxNjBkZWcpO1xuICAgIH1cbn1cbkBrZXlmcmFtZXMgc3BpbiB7XG4gICAgMCUge1xuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcbiAgICB9XG4gICAgMTAwJSB7XG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDI1MjBkZWcpO1xuICAgIH1cbn1cblxuLnNwaW5uZXIge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB3aWR0aDogMS41ZW07XG4gICAgaGVpZ2h0OiAxLjVlbTtcbiAgICBtYXJnaW46IGF1dG87XG4gICAgYW5pbWF0aW9uOiBzcGluIDEwcyBsaW5lYXIgaW5maW5pdGU7XG59XG4uc3Bpbm5lcjo6YmVmb3JlIHtcbiAgICBjb250ZW50OiBcIlwiO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgcmlnaHQ6IDA7XG59XG4ucmlnaHQsIC5yaWdodFdyYXBwZXIsIC5sZWZ0LCAubGVmdFdyYXBwZXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB3aWR0aDogLjc1ZW07XG4gICAgaGVpZ2h0OiAxLjVlbTtcbn1cbi5sZWZ0LCAubGVmdFdyYXBwZXIge1xuICAgIGxlZnQ6IDA7XG59XG4ucmlnaHQge1xuICAgIGxlZnQ6IC0xMnB4O1xufVxuLnJpZ2h0V3JhcHBlciB7XG4gICAgcmlnaHQ6IDA7XG59XG4uY2lyY2xlIHtcbiAgICBib3JkZXI6IC4xMjVlbSBzb2xpZCAjQThCNkI4O1xuICAgIHdpZHRoOiAxLjI1ZW07IC8qIDEuNWVtIC0gMiowLjEyNWVtIGJvcmRlciAqL1xuICAgIGhlaWdodDogMS4yNWVtOyAvKiAxLjVlbSAtIDIqMC4xMjVlbSBib3JkZXIgKi9cbiAgICBib3JkZXItcmFkaXVzOiAwLjc1ZW07IC8qIDAuNSoxLjVlbSBzcGlubmVyIHNpemUgOCAqL1xufVxuLmxlZnQge1xuICAgIHRyYW5zZm9ybS1vcmlnaW46IDEwMCUgNTAlO1xuICAgIGFuaW1hdGlvbjogc3BpbkxlZnQgMi41cyBjdWJpYy1iZXppZXIoLjIsMCwuOCwxKSBpbmZpbml0ZTtcbn1cbi5yaWdodCB7XG4gICAgdHJhbnNmb3JtLW9yaWdpbjogMTAwJSA1MCU7XG4gICAgYW5pbWF0aW9uOiBzcGluUmlnaHQgMi41cyBjdWJpYy1iZXppZXIoLjIsMCwuOCwxKSBpbmZpbml0ZTtcbn1cbmA7XG5cbmNvbnN0IGljb24gPSAnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpRaUlHaGxhV2RvZEQwaU1qUWlJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0S1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazAzSURJdU5VZ3hOME14Tnk0NE1qZzBJREl1TlNBeE9DNDFJRE11TVRjeE5UY2dNVGd1TlNBMFZqSXdRekU0TGpVZ01qQXVPREk0TkNBeE55NDRNamcwSURJeExqVWdNVGNnTWpFdU5VZzNRell1TVRjeE5UY2dNakV1TlNBMUxqVWdNakF1T0RJNE5DQTFMalVnTWpCV05FTTFMalVnTXk0eE56RTFOeUEyTGpFM01UVTNJREl1TlNBM0lESXVOVnBOTXlBMFF6TWdNUzQzT1RBNE5pQTBMamM1TURnMklEQWdOeUF3U0RFM1F6RTVMakl3T1RFZ01DQXlNU0F4TGpjNU1EZzJJREl4SURSV01qQkRNakVnTWpJdU1qQTVNU0F4T1M0eU1Ea3hJREkwSURFM0lESTBTRGRETkM0M09UQTROaUF5TkNBeklESXlMakl3T1RFZ015QXlNRlkwV2sweE1TQTBMall4TlRNNFF6RXdMalEwTnpjZ05DNDJNVFV6T0NBeE1DQTFMakEyTXpFZ01UQWdOUzQyTVRVek9GWTJMak00TkRZeVF6RXdJRFl1T1RNMk9TQXhNQzQwTkRjM0lEY3VNemcwTmpJZ01URWdOeTR6T0RRMk1rZ3hNME14TXk0MU5USXpJRGN1TXpnME5qSWdNVFFnTmk0NU16WTVJREUwSURZdU16ZzBOakpXTlM0Mk1UVXpPRU14TkNBMUxqQTJNekVnTVRNdU5UVXlNeUEwTGpZeE5UTTRJREV6SURRdU5qRTFNemhJTVRGYUlpQm1hV3hzUFNJalJFTkNPRVpHSWk4K0Nqd3ZjM1puUGdvPSc7XG5cbmZ1bmN0aW9uIGZyb21VaW50OEFycmF5KGJ5dGVBcnJheSkge1xuICAgIHJldHVybiB3aW5kb3cuYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlLmNhbGwobnVsbCwgLi4uYnl0ZUFycmF5KSk7XG59XG5mdW5jdGlvbiB0b1VpbnQ4QXJyYXkoYmFzZTY0RW5jb2RlZEJ5dGVBcnJheSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh3aW5kb3dcbiAgICAgICAgLmF0b2IoYmFzZTY0RW5jb2RlZEJ5dGVBcnJheSlcbiAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAubWFwKChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbn1cblxudmFyIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaW5zdGFuY2VzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2xpc3RlbmVycywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF92ZXJzaW9uLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X25hbWUsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdXJsLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2ljb24sIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXBwSWRlbnRpdHksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbiwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uQ2FjaGUsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY29ubmVjdGluZywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jb25uZWN0aW9uR2VuZXJhdGlvbiwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jaGFpbnMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY2hhaW5TZWxlY3RvciwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9vcHRpb25hbEZlYXR1cmVzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X29uV2FsbGV0Tm90Rm91bmQsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb24sIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfZW1pdCwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9vZmYsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY29ubmVjdCwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtQXV0aG9yaXphdGlvbiwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9oYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0LCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2hhbmRsZVdhbGxldENhcGFiaWxpdGllc1Jlc3VsdCwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtUmVhdXRob3JpemF0aW9uLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Rpc2Nvbm5lY3QsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdHJhbnNhY3QsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXNzZXJ0SXNBdXRob3JpemVkLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2FjY291bnRzVG9XYWxsZXRTdGFuZGFyZEFjY291bnRzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1TaWduVHJhbnNhY3Rpb25zLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1TaWduQW5kU2VuZFRyYW5zYWN0aW9uLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3NpZ25BbmRTZW5kVHJhbnNhY3Rpb24sIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnblRyYW5zYWN0aW9uLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3NpZ25NZXNzYWdlLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3NpZ25JbiwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtU2lnbkluLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9pbnN0YW5jZXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2xpc3RlbmVycywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdmVyc2lvbiwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfbmFtZSwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdXJsLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9pY29uLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hcHBJZGVudGl0eSwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbiwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbkNhY2hlLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jb25uZWN0aW5nLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jb25uZWN0aW9uR2VuZXJhdGlvbiwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY2hhaW5zLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jaGFpblNlbGVjdG9yLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9vcHRpb25hbEZlYXR1cmVzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9vbldhbGxldE5vdEZvdW5kLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9ob3N0QXV0aG9yaXR5LCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zZXNzaW9uLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9vbiwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfZW1pdCwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb2ZmLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jb25uZWN0LCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtQXV0aG9yaXphdGlvbiwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdCwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaGFuZGxlV2FsbGV0Q2FwYWJpbGl0aWVzUmVzdWx0LCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtUmVhdXRob3JpemF0aW9uLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9kaXNjb25uZWN0LCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF90cmFuc2FjdCwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXNzZXJ0SXNBdXRob3JpemVkLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hY2NvdW50c1RvV2FsbGV0U3RhbmRhcmRBY2NvdW50cywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfcGVyZm9ybVNpZ25UcmFuc2FjdGlvbnMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1TaWduQW5kU2VuZFRyYW5zYWN0aW9uLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zaWduQW5kU2VuZFRyYW5zYWN0aW9uLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zaWduVHJhbnNhY3Rpb24sIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3NpZ25NZXNzYWdlLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zaWduSW4sIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1TaWduSW47XG5jb25zdCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZSA9ICdNb2JpbGUgV2FsbGV0IEFkYXB0ZXInO1xuY29uc3QgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclJlbW90ZVdhbGxldE5hbWUgPSAnUmVtb3RlIE1vYmlsZSBXYWxsZXQgQWRhcHRlcic7XG5jb25zdCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTID0gNjQ7XG5jb25zdCBERUZBVUxUX0ZFQVRVUkVTID0gW1NvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24sIFNvbGFuYVNpZ25UcmFuc2FjdGlvbiwgU29sYW5hU2lnbk1lc3NhZ2UsIFNvbGFuYVNpZ25Jbl07XG5jbGFzcyBMb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2luc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfbGlzdGVuZXJzLnNldCh0aGlzLCB7fSk7XG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdmVyc2lvbi5zZXQodGhpcywgJzEuMC4wJyk7IC8vIHdhbGxldC1zdGFuZGFyZCB2ZXJzaW9uXG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfbmFtZS5zZXQodGhpcywgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWUpO1xuICAgICAgICBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3VybC5zZXQodGhpcywgJ2h0dHBzOi8vc29sYW5hbW9iaWxlLmNvbS93YWxsZXRzJyk7XG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaWNvbi5zZXQodGhpcywgaWNvbik7XG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXBwSWRlbnRpdHkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbi5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uQ2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY29ubmVjdGluZy5zZXQodGhpcywgZmFsc2UpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlcnkgdGltZSB0aGUgY29ubmVjdGlvbiBpcyByZWN5Y2xlZCBpbiBzb21lIHdheSAoZWcuIGBkaXNjb25uZWN0KClgIGlzIGNhbGxlZClcbiAgICAgICAgICogaW5jcmVtZW50IHRoaXMgYW5kIHVzZSBpdCB0byBtYWtlIHN1cmUgdGhhdCBgdHJhbnNhY3RgIGNhbGxzIGZyb20gdGhlIHByZXZpb3VzXG4gICAgICAgICAqICdnZW5lcmF0aW9uJyBkb24ndCBjb250aW51ZSB0byBkbyB3b3JrIGFuZCB0aHJvdyBleGNlcHRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jb25uZWN0aW9uR2VuZXJhdGlvbi5zZXQodGhpcywgMCk7XG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY2hhaW5zLnNldCh0aGlzLCBbXSk7XG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY2hhaW5TZWxlY3Rvci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9vcHRpb25hbEZlYXR1cmVzLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X29uV2FsbGV0Tm90Rm91bmQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb24uc2V0KHRoaXMsIChldmVudCwgbGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICgoX2EgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wdXNoKGxpc3RlbmVyKSkgfHwgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2xpc3RlbmVycywgXCJmXCIpW2V2ZW50XSA9IFtsaXN0ZW5lcl0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2luc3RhbmNlcywgXCJtXCIsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb2ZmKS5jYWxsKHRoaXMsIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgICAgICBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Nvbm5lY3Quc2V0KHRoaXMsICh7IHNpbGVudCB9ID0ge30pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jb25uZWN0aW5nLCBcImZcIikgfHwgdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBhY2NvdW50czogdGhpcy5hY2NvdW50cyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY29ubmVjdGluZywgdHJ1ZSwgXCJmXCIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZEF1dGhvcml6YXRpb24gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uQ2FjaGUsIFwiZlwiKS5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZEF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2hhbmRsZVdhbGxldENhcGFiaWxpdGllc1Jlc3VsdCwgXCJmXCIpLmNhbGwodGhpcywgY2FjaGVkQXV0aG9yaXphdGlvbi5jYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdCwgXCJmXCIpLmNhbGwodGhpcywgY2FjaGVkQXV0aG9yaXphdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBhY2NvdW50czogdGhpcy5hY2NvdW50cyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtQXV0aG9yaXphdGlvbiwgXCJmXCIpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jb25uZWN0aW5nLCBmYWxzZSwgXCJmXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgYWNjb3VudHM6IHRoaXMuYWNjb3VudHMgfTtcbiAgICAgICAgfSkpO1xuICAgICAgICBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1BdXRob3JpemF0aW9uLnNldCh0aGlzLCAoc2lnbkluUGF5bG9hZCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbkNhY2hlLCBcImZcIikuZ2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2hhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQsIFwiZlwiKS5jYWxsKHRoaXMsIGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRDaGFpbiA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2NoYWluU2VsZWN0b3IsIFwiZlwiKS5zZWxlY3QoX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY2hhaW5zLCBcImZcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF90cmFuc2FjdCwgXCJmXCIpLmNhbGwodGhpcywgKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbY2FwYWJpbGl0aWVzLCBtd2FBdXRob3JpemF0aW9uUmVzdWx0XSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldC5nZXRDYXBhYmlsaXRpZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldC5hdXRob3JpemUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluOiBzZWxlY3RlZENoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aXR5OiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hcHBJZGVudGl0eSwgXCJmXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25faW5fcGF5bG9hZDogc2lnbkluUGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2FjY291bnRzVG9XYWxsZXRTdGFuZGFyZEFjY291bnRzLCBcImZcIikuY2FsbCh0aGlzLCBtd2FBdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbXdhQXV0aG9yaXphdGlvblJlc3VsdCksIHsgYWNjb3VudHMsIGNoYWluOiBzZWxlY3RlZENoYWluLCBjYXBhYmlsaXRpZXM6IGNhcGFiaWxpdGllcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2hhbmRsZVdhbGxldENhcGFiaWxpdGllc1Jlc3VsdCwgXCJmXCIpLmNhbGwodGhpcywgY2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb25DYWNoZSwgXCJmXCIpLnNldChhdXRob3JpemF0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2hhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQsIFwiZlwiKS5jYWxsKHRoaXMsIGF1dGhvcml6YXRpb24pLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dGhvcml6YXRpb247XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9oYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0LnNldCh0aGlzLCAoYXV0aG9yaXphdGlvbikgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgZGlkUHVibGljS2V5c0NoYW5nZSA9IFxuICAgICAgICAgICAgLy8gQ2FzZSAxOiBXZSBzdGFydGVkIGZyb20gaGF2aW5nIG5vIGF1dGhvcml6YXRpb24uXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uLCBcImZcIikgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIC8vIENhc2UgMjogVGhlIG51bWJlciBvZiBhdXRob3JpemVkIGFjY291bnRzIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgKChfYSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb24sIFwiZlwiKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY291bnRzLmxlbmd0aCkgIT09IGF1dGhvcml6YXRpb24uYWNjb3VudHMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgLy8gQ2FzZSAzOiBUaGUgbmV3IGxpc3Qgb2YgYWRkcmVzc2VzIGlzbid0IGV4YWN0bHkgdGhlIHNhbWUgYXMgdGhlIG9sZCBsaXN0LCBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uLCBcImZcIikuYWNjb3VudHMuc29tZSgoYWNjb3VudCwgaWkpID0+IGFjY291bnQuYWRkcmVzcyAhPT0gYXV0aG9yaXphdGlvbi5hY2NvdW50c1tpaV0uYWRkcmVzcyk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uLCBhdXRob3JpemF0aW9uLCBcImZcIik7XG4gICAgICAgICAgICBpZiAoZGlkUHVibGljS2V5c0NoYW5nZSkge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2luc3RhbmNlcywgXCJtXCIsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfZW1pdCkuY2FsbCh0aGlzLCAnY2hhbmdlJywgeyBhY2NvdW50czogdGhpcy5hY2NvdW50cyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2hhbmRsZVdhbGxldENhcGFiaWxpdGllc1Jlc3VsdC5zZXQodGhpcywgKGNhcGFiaWxpdGllcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgd2h5IHVzaW5nIFNvbGFuYVNpZ25UcmFuc2FjdGlvbnMgY29uc3RhbnQgYnJlYWtzIHRyZWVzaGFraW5nXG4gICAgICAgICAgICBjb25zdCBzdXBwb3J0c1NpZ25UcmFuc2FjdGlvbiA9IGNhcGFiaWxpdGllcy5mZWF0dXJlcy5pbmNsdWRlcygnc29sYW5hOnNpZ25UcmFuc2FjdGlvbnMnKTsgLy9Tb2xhbmFTaWduVHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRzU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiA9IGNhcGFiaWxpdGllcy5zdXBwb3J0c19zaWduX2FuZF9zZW5kX3RyYW5zYWN0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGRpZENhcGFiaWxpdGllc0NoYW5nZSA9IFNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gaW4gdGhpcy5mZWF0dXJlcyAhPT0gc3VwcG9ydHNTaWduQW5kU2VuZFRyYW5zYWN0aW9uIHx8XG4gICAgICAgICAgICAgICAgU29sYW5hU2lnblRyYW5zYWN0aW9uIGluIHRoaXMuZmVhdHVyZXMgIT09IHN1cHBvcnRzU2lnblRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb3B0aW9uYWxGZWF0dXJlcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoKHN1cHBvcnRzU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiB8fCAoIXN1cHBvcnRzU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiAmJiAhc3VwcG9ydHNTaWduVHJhbnNhY3Rpb24pKSAmJiB7XG4gICAgICAgICAgICAgICAgW1NvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb25dOiB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnM6IFsnbGVnYWN5JywgMF0sXG4gICAgICAgICAgICAgICAgICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb246IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3NpZ25BbmRTZW5kVHJhbnNhY3Rpb24sIFwiZlwiKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkpLCAoc3VwcG9ydHNTaWduVHJhbnNhY3Rpb24gJiYge1xuICAgICAgICAgICAgICAgIFtTb2xhbmFTaWduVHJhbnNhY3Rpb25dOiB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnM6IFsnbGVnYWN5JywgMF0sXG4gICAgICAgICAgICAgICAgICAgIHNpZ25UcmFuc2FjdGlvbjogX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnblRyYW5zYWN0aW9uLCBcImZcIiksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKSwgXCJmXCIpO1xuICAgICAgICAgICAgaWYgKGRpZENhcGFiaWxpdGllc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2luc3RhbmNlcywgXCJtXCIsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfZW1pdCkuY2FsbCh0aGlzLCAnY2hhbmdlJywgeyBmZWF0dXJlczogdGhpcy5mZWF0dXJlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1SZWF1dGhvcml6YXRpb24uc2V0KHRoaXMsICh3YWxsZXQsIGF1dGhUb2tlbiwgY2hhaW4pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYiwgX2M7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjYXBhYmlsaXRpZXMsIG13YUF1dGhvcml6YXRpb25SZXN1bHRdID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICAoX2MgPSAoX2IgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uLCBcImZcIikpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXBhYmlsaXRpZXMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHlpZWxkIHdhbGxldC5nZXRDYXBhYmlsaXRpZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0LmF1dGhvcml6ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoX3Rva2VuOiBhdXRoVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGl0eTogX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXBwSWRlbnRpdHksIFwiZlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluOiBjaGFpblxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYWNjb3VudHNUb1dhbGxldFN0YW5kYXJkQWNjb3VudHMsIFwiZlwiKS5jYWxsKHRoaXMsIG13YUF1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG13YUF1dGhvcml6YXRpb25SZXN1bHQpLCB7IGFjY291bnRzOiBhY2NvdW50cywgY2hhaW46IGNoYWluLCBjYXBhYmlsaXRpZXM6IGNhcGFiaWxpdGllcyB9KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBFdmFsdWF0ZSB3aGV0aGVyIHRoZXJlJ3MgYW55IHRocmVhdCB0byBub3QgYGF3YWl0aW5nYCB0aGlzIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb25DYWNoZSwgXCJmXCIpLnNldChhdXRob3JpemF0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdCwgXCJmXCIpLmNhbGwodGhpcywgYXV0aG9yaXphdGlvbiksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Rpc2Nvbm5lY3QsIFwiZlwiKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSkgfHwgJ1Vua25vd24gZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Rpc2Nvbm5lY3Quc2V0KHRoaXMsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfZDtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb25DYWNoZSwgXCJmXCIpLmNsZWFyKCk7IC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY29ubmVjdGluZywgZmFsc2UsIFwiZlwiKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Nvbm5lY3Rpb25HZW5lcmF0aW9uLCAoX2QgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jb25uZWN0aW9uR2VuZXJhdGlvbiwgXCJmXCIpLCBfZCsrLCBfZCksIFwiZlwiKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb24sIHVuZGVmaW5lZCwgXCJmXCIpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaW5zdGFuY2VzLCBcIm1cIiwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9lbWl0KS5jYWxsKHRoaXMsICdjaGFuZ2UnLCB7IGFjY291bnRzOiB0aGlzLmFjY291bnRzIH0pO1xuICAgICAgICB9KSk7XG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdHJhbnNhY3Quc2V0KHRoaXMsIChjYWxsYmFjaykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9lO1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0VXJpQmFzZSA9IChfZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb24sIFwiZlwiKSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLndhbGxldF91cmlfYmFzZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHdhbGxldFVyaUJhc2UgPyB7IGJhc2VVcmk6IHdhbGxldFVyaUJhc2UgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb25uZWN0aW9uR2VuZXJhdGlvbiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Nvbm5lY3Rpb25HZW5lcmF0aW9uLCBcImZcIik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0cmFuc2FjdChjYWxsYmFjaywgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Nvbm5lY3Rpb25HZW5lcmF0aW9uLCBcImZcIikgIT09IGN1cnJlbnRDb25uZWN0aW9uR2VuZXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZSgoKSA9PiB7IH0pOyAvLyBOZXZlciByZXNvbHZlLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIGUubmFtZSA9PT0gJ1NvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcicgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5jb2RlID09PSAnRVJST1JfV0FMTEVUX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb25XYWxsZXROb3RGb3VuZCwgXCJmXCIpLmNhbGwodGhpcywgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hc3NlcnRJc0F1dGhvcml6ZWQuc2V0KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbiwgXCJmXCIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiB7IGF1dGhUb2tlbjogX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbiwgXCJmXCIpLmF1dGhfdG9rZW4sIGNoYWluOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uLCBcImZcIikuY2hhaW4gfTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYWNjb3VudHNUb1dhbGxldFN0YW5kYXJkQWNjb3VudHMuc2V0KHRoaXMsIChhY2NvdW50cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnRzLm1hcCgoYWNjb3VudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gdG9VaW50OEFycmF5KGFjY291bnQuYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogYmFzZTU4LmVuY29kZShwdWJsaWNLZXkpLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBhY2NvdW50LmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiBhY2NvdW50Lmljb24sXG4gICAgICAgICAgICAgICAgICAgIGNoYWluczogKF9hID0gYWNjb3VudC5jaGFpbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2NoYWlucywgXCJmXCIpLFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBnZXQgc3VwcG9ydGVkIGZlYXR1cmVzIGZyb20gZ2V0Q2FwYWJpbGl0aWVzIEFQSSBcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXM6IChfYiA9IGFjY291bnQuZmVhdHVyZXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERFRkFVTFRfRkVBVFVSRVNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1TaWduVHJhbnNhY3Rpb25zLnNldCh0aGlzLCAodHJhbnNhY3Rpb25zKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhUb2tlbiwgY2hhaW4gfSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Fzc2VydElzQXV0aG9yaXplZCwgXCJmXCIpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NFRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7IHJldHVybiBmcm9tVWludDhBcnJheSh0eCk7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF90cmFuc2FjdCwgXCJmXCIpLmNhbGwodGhpcywgKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtUmVhdXRob3JpemF0aW9uLCBcImZcIikuY2FsbCh0aGlzLCB3YWxsZXQsIGF1dGhUb2tlbiwgY2hhaW4pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbnMgPSAoeWllbGQgd2FsbGV0LnNpZ25UcmFuc2FjdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZHM6IGJhc2U2NFRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgfSkpLnNpZ25lZF9wYXlsb2Fkcy5tYXAodG9VaW50OEFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9ucztcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSkgfHwgJ1Vua25vd24gZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1TaWduQW5kU2VuZFRyYW5zYWN0aW9uLnNldCh0aGlzLCAodHJhbnNhY3Rpb24sIG9wdGlvbnMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0aFRva2VuLCBjaGFpbiB9ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXNzZXJ0SXNBdXRob3JpemVkLCBcImZcIikuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3RyYW5zYWN0LCBcImZcIikuY2FsbCh0aGlzLCAod2FsbGV0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtjYXBhYmlsaXRpZXMsIF8xXSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldC5nZXRDYXBhYmlsaXRpZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1SZWF1dGhvcml6YXRpb24sIFwiZlwiKS5jYWxsKHRoaXMsIHdhbGxldCwgYXV0aFRva2VuLCBjaGFpbilcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXBhYmlsaXRpZXMuc3VwcG9ydHNfc2lnbl9hbmRfc2VuZF90cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NFRyYW5zYWN0aW9uID0gZnJvbVVpbnQ4QXJyYXkodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9ICh5aWVsZCB3YWxsZXQuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBwYXlsb2FkczogW2Jhc2U2NFRyYW5zYWN0aW9uXSB9KSkpLnNpZ25hdHVyZXMubWFwKHRvVWludDhBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29ubmVjdGVkIHdhbGxldCBkb2VzIG5vdCBzdXBwb3J0IHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlKSB8fCAnVW5rbm93biBlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnbkFuZFNlbmRUcmFuc2FjdGlvbi5zZXQodGhpcywgKC4uLmlucHV0cykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiwgXCJmXCIpLmNhbGwodGhpcywgaW5wdXQudHJhbnNhY3Rpb24sIGlucHV0Lm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaCh7IHNpZ25hdHVyZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgICAgICB9KSk7XG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnblRyYW5zYWN0aW9uLnNldCh0aGlzLCAoLi4uaW5wdXRzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1TaWduVHJhbnNhY3Rpb25zLCBcImZcIikuY2FsbCh0aGlzLCBpbnB1dHMubWFwKCh7IHRyYW5zYWN0aW9uIH0pID0+IHRyYW5zYWN0aW9uKSkpXG4gICAgICAgICAgICAgICAgLm1hcCgoc2lnbmVkVHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzaWduZWRUcmFuc2FjdGlvbiB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zaWduTWVzc2FnZS5zZXQodGhpcywgKC4uLmlucHV0cykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhdXRoVG9rZW4sIGNoYWluIH0gPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hc3NlcnRJc0F1dGhvcml6ZWQsIFwiZlwiKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gaW5wdXRzLm1hcCgoeyBhY2NvdW50IH0pID0+IGZyb21VaW50OEFycmF5KGFjY291bnQucHVibGljS2V5KSk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGlucHV0cy5tYXAoKHsgbWVzc2FnZSB9KSA9PiBmcm9tVWludDhBcnJheShtZXNzYWdlKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF90cmFuc2FjdCwgXCJmXCIpLmNhbGwodGhpcywgKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtUmVhdXRob3JpemF0aW9uLCBcImZcIikuY2FsbCh0aGlzLCB3YWxsZXQsIGF1dGhUb2tlbiwgY2hhaW4pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRNZXNzYWdlcyA9ICh5aWVsZCB3YWxsZXQuc2lnbk1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NlczogYWRkcmVzc2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZHM6IG1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICB9KSkuc2lnbmVkX3BheWxvYWRzLm1hcCh0b1VpbnQ4QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkTWVzc2FnZXMubWFwKChzaWduZWRNZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzaWduZWRNZXNzYWdlOiBzaWduZWRNZXNzYWdlLCBzaWduYXR1cmU6IHNpZ25lZE1lc3NhZ2Uuc2xpY2UoLVNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlKSB8fCAnVW5rbm93biBlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnbkluLnNldCh0aGlzLCAoLi4uaW5wdXRzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gW107XG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2goeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfcGVyZm9ybVNpZ25JbiwgXCJmXCIpLmNhbGwodGhpcywgaW5wdXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3lpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1TaWduSW4sIFwiZlwiKS5jYWxsKHRoaXMsIGlucHV0c1swXSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtU2lnbkluLnNldCh0aGlzLCAoaW5wdXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfZiwgX2csIF9oO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY29ubmVjdGluZywgdHJ1ZSwgXCJmXCIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfcGVyZm9ybUF1dGhvcml6YXRpb24sIFwiZlwiKS5jYWxsKHRoaXMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5wdXQpLCB7IGRvbWFpbjogKF9mID0gaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0LmRvbWFpbikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogd2luZG93LmxvY2F0aW9uLmhvc3QgfSkpO1xuICAgICAgICAgICAgICAgIGlmICghYXV0aG9yaXphdGlvblJlc3VsdC5zaWduX2luX3Jlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWduIGluIGZhaWxlZCwgbm8gc2lnbiBpbiByZXN1bHQgcmV0dXJuZWQgYnkgd2FsbGV0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRJbkFkZHJlc3MgPSBhdXRob3JpemF0aW9uUmVzdWx0LnNpZ25faW5fcmVzdWx0LmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkSW5BY2NvdW50ID0gYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50cy5maW5kKGFjYyA9PiBhY2MuYWRkcmVzcyA9PSBzaWduZWRJbkFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2lnbmVkSW5BY2NvdW50ICE9PSBudWxsICYmIHNpZ25lZEluQWNjb3VudCAhPT0gdm9pZCAwID8gc2lnbmVkSW5BY2NvdW50IDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogYmFzZTU4LmVuY29kZSh0b1VpbnQ4QXJyYXkoc2lnbmVkSW5BZGRyZXNzKSlcbiAgICAgICAgICAgICAgICAgICAgfSksIHsgcHVibGljS2V5OiB0b1VpbnQ4QXJyYXkoc2lnbmVkSW5BZGRyZXNzKSwgY2hhaW5zOiAoX2cgPSBzaWduZWRJbkFjY291bnQgPT09IG51bGwgfHwgc2lnbmVkSW5BY2NvdW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaWduZWRJbkFjY291bnQuY2hhaW5zKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jaGFpbnMsIFwiZlwiKSwgZmVhdHVyZXM6IChfaCA9IHNpZ25lZEluQWNjb3VudCA9PT0gbnVsbCB8fCBzaWduZWRJbkFjY291bnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNpZ25lZEluQWNjb3VudC5mZWF0dXJlcykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogYXV0aG9yaXphdGlvblJlc3VsdC5jYXBhYmlsaXRpZXMuZmVhdHVyZXMgfSksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25lZE1lc3NhZ2U6IHRvVWludDhBcnJheShhdXRob3JpemF0aW9uUmVzdWx0LnNpZ25faW5fcmVzdWx0LnNpZ25lZF9tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiB0b1VpbnQ4QXJyYXkoYXV0aG9yaXphdGlvblJlc3VsdC5zaWduX2luX3Jlc3VsdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlKSB8fCAnVW5rbm93biBlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY29ubmVjdGluZywgZmFsc2UsIFwiZlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uQ2FjaGUsIGNvbmZpZy5hdXRob3JpemF0aW9uQ2FjaGUsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXBwSWRlbnRpdHksIGNvbmZpZy5hcHBJZGVudGl0eSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jaGFpbnMsIGNvbmZpZy5jaGFpbnMsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY2hhaW5TZWxlY3RvciwgY29uZmlnLmNoYWluU2VsZWN0b3IsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb25XYWxsZXROb3RGb3VuZCwgY29uZmlnLm9uV2FsbGV0Tm90Rm91bmQsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb3B0aW9uYWxGZWF0dXJlcywge1xuICAgICAgICAgICAgLy8gSW4gTVdBIDEuMCwgc2lnbkFuZFNlbmQgaXMgb3B0aW9uYWwgYW5kIHNpZ25UcmFuc2FjdGlvbiBpcyBtYW5kYXRvcnkuIFdoZXJlYXMgaW4gTVdBIDIuMCssXG4gICAgICAgICAgICAvLyBzaWduQW5kU2VuZCBpcyBtYW5kYXRvcnkgYW5kIHNpZ25UcmFuc2FjdGlvbiBpcyBvcHRpb25hbCAoYW5kIHNvZnQgZGVwcmVjYXRlZCkuIEFzIG9mIG1pZFxuICAgICAgICAgICAgLy8gMjAyNSwgYWxsIE1XQSB3YWxsZXRzIHN1cHBvcnQgYm90aCBzaWduQW5kU2VuZFRyYW5zYWN0aW9uIGFuZCBzaWduVHJhbnNhY3Rpb24gc28gaXRzIHNhZmVcbiAgICAgICAgICAgIC8vIGFzc3VtZSBib3RoIGFyZSBzdXBwb3J0ZWQgaGVyZS4gVGhlIGZlYXR1cmVzIHdpbGwgYmUgdXBkYXRlZCBiYXNlZCBvbiB0aGUgYWN0dWFsIGNvbm5lY3RlZCBcbiAgICAgICAgICAgIC8vIHdhbGxldHMgY2FwYWJpbGl0aWVzIGR1cmluZyBjb25uZWN0aW9uIHJlZ2FyZGxlc3MsIHNvIHRoaXMgaXMgc2FmZS4gXG4gICAgICAgICAgICBbU29sYW5hU2lnbkFuZFNlbmRUcmFuc2FjdGlvbl06IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICAgICAgICAgIHN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnM6IFsnbGVnYWN5JywgMF0sXG4gICAgICAgICAgICAgICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbjogX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnbkFuZFNlbmRUcmFuc2FjdGlvbiwgXCJmXCIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtTb2xhbmFTaWduVHJhbnNhY3Rpb25dOiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zOiBbJ2xlZ2FjeScsIDBdLFxuICAgICAgICAgICAgICAgIHNpZ25UcmFuc2FjdGlvbjogX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnblRyYW5zYWN0aW9uLCBcImZcIiksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCBcImZcIik7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdmVyc2lvbiwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X25hbWUsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IHVybCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3VybCwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgaWNvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2ljb24sIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGNoYWlucygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2NoYWlucywgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgZmVhdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgW1N0YW5kYXJkQ29ubmVjdF06IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Q6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Nvbm5lY3QsIFwiZlwiKSxcbiAgICAgICAgICAgIH0sIFtTdGFuZGFyZERpc2Nvbm5lY3RdOiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0OiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9kaXNjb25uZWN0LCBcImZcIiksXG4gICAgICAgICAgICB9LCBbU3RhbmRhcmRFdmVudHNdOiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgICAgICAgICBvbjogX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb24sIFwiZlwiKSxcbiAgICAgICAgICAgIH0sIFtTb2xhbmFTaWduTWVzc2FnZV06IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICAgICAgICAgIHNpZ25NZXNzYWdlOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zaWduTWVzc2FnZSwgXCJmXCIpLFxuICAgICAgICAgICAgfSwgW1NvbGFuYVNpZ25Jbl06IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICAgICAgICAgIHNpZ25JbjogX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnbkluLCBcImZcIiksXG4gICAgICAgICAgICB9IH0sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X29wdGlvbmFsRmVhdHVyZXMsIFwiZlwiKSk7XG4gICAgfVxuICAgIGdldCBhY2NvdW50cygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb24sIFwiZlwiKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY291bnRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICB9XG4gICAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuICEhX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbiwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgaXNBdXRob3JpemVkKCkge1xuICAgICAgICByZXR1cm4gISFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBjdXJyZW50QXV0aG9yaXphdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb24sIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uQ2FjaGUsIFwiZlwiKS5nZXQoKTtcbiAgICB9XG59XG5fTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2xpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdmVyc2lvbiA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfbmFtZSA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdXJsID0gbmV3IFdlYWtNYXAoKSwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9pY29uID0gbmV3IFdlYWtNYXAoKSwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hcHBJZGVudGl0eSA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbiA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbkNhY2hlID0gbmV3IFdlYWtNYXAoKSwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jb25uZWN0aW5nID0gbmV3IFdlYWtNYXAoKSwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jb25uZWN0aW9uR2VuZXJhdGlvbiA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY2hhaW5zID0gbmV3IFdlYWtNYXAoKSwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jaGFpblNlbGVjdG9yID0gbmV3IFdlYWtNYXAoKSwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9vcHRpb25hbEZlYXR1cmVzID0gbmV3IFdlYWtNYXAoKSwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9vbldhbGxldE5vdEZvdW5kID0gbmV3IFdlYWtNYXAoKSwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9vbiA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY29ubmVjdCA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfcGVyZm9ybUF1dGhvcml6YXRpb24gPSBuZXcgV2Vha01hcCgpLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2hhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQgPSBuZXcgV2Vha01hcCgpLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2hhbmRsZVdhbGxldENhcGFiaWxpdGllc1Jlc3VsdCA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfcGVyZm9ybVJlYXV0aG9yaXphdGlvbiA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfZGlzY29ubmVjdCA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdHJhbnNhY3QgPSBuZXcgV2Vha01hcCgpLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Fzc2VydElzQXV0aG9yaXplZCA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYWNjb3VudHNUb1dhbGxldFN0YW5kYXJkQWNjb3VudHMgPSBuZXcgV2Vha01hcCgpLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1TaWduVHJhbnNhY3Rpb25zID0gbmV3IFdlYWtNYXAoKSwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnbkFuZFNlbmRUcmFuc2FjdGlvbiA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnblRyYW5zYWN0aW9uID0gbmV3IFdlYWtNYXAoKSwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zaWduTWVzc2FnZSA9IG5ldyBXZWFrTWFwKCksIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnbkluID0gbmV3IFdlYWtNYXAoKSwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtU2lnbkluID0gbmV3IFdlYWtNYXAoKSwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2VtaXQgPSBmdW5jdGlvbiBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2VtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICAoX2EgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIuYXBwbHkobnVsbCwgYXJncykpO1xufSwgX0xvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9vZmYgPSBmdW5jdGlvbiBfTG9jYWxTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X29mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdID0gKF9hID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9Mb2NhbFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKChleGlzdGluZ0xpc3RlbmVyKSA9PiBsaXN0ZW5lciAhPT0gZXhpc3RpbmdMaXN0ZW5lcik7XG59O1xuY2xhc3MgUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2luc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgICAgIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2xpc3RlbmVycy5zZXQodGhpcywge30pO1xuICAgICAgICBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF92ZXJzaW9uLnNldCh0aGlzLCAnMS4wLjAnKTsgLy8gd2FsbGV0LXN0YW5kYXJkIHZlcnNpb25cbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfbmFtZS5zZXQodGhpcywgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclJlbW90ZVdhbGxldE5hbWUpO1xuICAgICAgICBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF91cmwuc2V0KHRoaXMsICdodHRwczovL3NvbGFuYW1vYmlsZS5jb20vd2FsbGV0cycpO1xuICAgICAgICBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9pY29uLnNldCh0aGlzLCBpY29uKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXBwSWRlbnRpdHkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb24uc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb25DYWNoZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY29ubmVjdGluZy5zZXQodGhpcywgZmFsc2UpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlcnkgdGltZSB0aGUgY29ubmVjdGlvbiBpcyByZWN5Y2xlZCBpbiBzb21lIHdheSAoZWcuIGBkaXNjb25uZWN0KClgIGlzIGNhbGxlZClcbiAgICAgICAgICogaW5jcmVtZW50IHRoaXMgYW5kIHVzZSBpdCB0byBtYWtlIHN1cmUgdGhhdCBgdHJhbnNhY3RgIGNhbGxzIGZyb20gdGhlIHByZXZpb3VzXG4gICAgICAgICAqICdnZW5lcmF0aW9uJyBkb24ndCBjb250aW51ZSB0byBkbyB3b3JrIGFuZCB0aHJvdyBleGNlcHRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY29ubmVjdGlvbkdlbmVyYXRpb24uc2V0KHRoaXMsIDApO1xuICAgICAgICBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jaGFpbnMuc2V0KHRoaXMsIFtdKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY2hhaW5TZWxlY3Rvci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb3B0aW9uYWxGZWF0dXJlcy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb25XYWxsZXROb3RGb3VuZC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaG9zdEF1dGhvcml0eS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2Vzc2lvbi5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb24uc2V0KHRoaXMsIChldmVudCwgbGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICgoX2EgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVzaChsaXN0ZW5lcikpIHx8IChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdID0gW2xpc3RlbmVyXSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2luc3RhbmNlcywgXCJtXCIsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X29mZikuY2FsbCh0aGlzLCBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY29ubmVjdC5zZXQodGhpcywgKHsgc2lsZW50IH0gPSB7fSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jb25uZWN0aW5nLCBcImZcIikgfHwgdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBhY2NvdW50czogdGhpcy5hY2NvdW50cyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Nvbm5lY3RpbmcsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1BdXRob3JpemF0aW9uLCBcImZcIikuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlKSB8fCAnVW5rbm93biBlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Nvbm5lY3RpbmcsIGZhbHNlLCBcImZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBhY2NvdW50czogdGhpcy5hY2NvdW50cyB9O1xuICAgICAgICB9KSk7XG4gICAgICAgIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1BdXRob3JpemF0aW9uLnNldCh0aGlzLCAoc2lnbkluUGF5bG9hZCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb25DYWNoZSwgXCJmXCIpLmdldCgpO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdCwgXCJmXCIpLmNhbGwodGhpcywgY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3Nlc3Npb24sIFwiZlwiKSlcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3Nlc3Npb24sIHVuZGVmaW5lZCwgXCJmXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkQ2hhaW4gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY2hhaW5TZWxlY3RvciwgXCJmXCIpLnNlbGVjdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY2hhaW5zLCBcImZcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdHJhbnNhY3QsIFwiZlwiKS5jYWxsKHRoaXMsICh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2NhcGFiaWxpdGllcywgbXdhQXV0aG9yaXphdGlvblJlc3VsdF0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQuZ2V0Q2FwYWJpbGl0aWVzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQuYXV0aG9yaXplKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbjogc2VsZWN0ZWRDaGFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGl0eTogX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2FwcElkZW50aXR5LCBcImZcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbl9pbl9wYXlsb2FkOiBzaWduSW5QYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2FjY291bnRzVG9XYWxsZXRTdGFuZGFyZEFjY291bnRzLCBcImZcIikuY2FsbCh0aGlzLCBtd2FBdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvblJlc3VsdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbXdhQXV0aG9yaXphdGlvblJlc3VsdCksIHsgYWNjb3VudHMsIGNoYWluOiBzZWxlY3RlZENoYWluLCBjYXBhYmlsaXRpZXM6IGNhcGFiaWxpdGllcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9oYW5kbGVXYWxsZXRDYXBhYmlsaXRpZXNSZXN1bHQsIFwiZlwiKS5jYWxsKHRoaXMsIGNhcGFiaWxpdGllcyksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbkNhY2hlLCBcImZcIikuc2V0KGF1dGhvcml6YXRpb25SZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2hhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQsIFwiZlwiKS5jYWxsKHRoaXMsIGF1dGhvcml6YXRpb25SZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdC5zZXQodGhpcywgKGF1dGhvcml6YXRpb24pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGRpZFB1YmxpY0tleXNDaGFuZ2UgPSBcbiAgICAgICAgICAgIC8vIENhc2UgMTogV2Ugc3RhcnRlZCBmcm9tIGhhdmluZyBubyBhdXRob3JpemF0aW9uLlxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb24sIFwiZlwiKSA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgLy8gQ2FzZSAyOiBUaGUgbnVtYmVyIG9mIGF1dGhvcml6ZWQgYWNjb3VudHMgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAoKF9hID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb24sIFwiZlwiKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY291bnRzLmxlbmd0aCkgIT09IGF1dGhvcml6YXRpb24uYWNjb3VudHMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgLy8gQ2FzZSAzOiBUaGUgbmV3IGxpc3Qgb2YgYWRkcmVzc2VzIGlzbid0IGV4YWN0bHkgdGhlIHNhbWUgYXMgdGhlIG9sZCBsaXN0LCBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbiwgXCJmXCIpLmFjY291bnRzLnNvbWUoKGFjY291bnQsIGlpKSA9PiBhY2NvdW50LmFkZHJlc3MgIT09IGF1dGhvcml6YXRpb24uYWNjb3VudHNbaWldLmFkZHJlc3MpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb24sIGF1dGhvcml6YXRpb24sIFwiZlwiKTtcbiAgICAgICAgICAgIGlmIChkaWRQdWJsaWNLZXlzQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2luc3RhbmNlcywgXCJtXCIsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2VtaXQpLmNhbGwodGhpcywgJ2NoYW5nZScsIHsgYWNjb3VudHM6IHRoaXMuYWNjb3VudHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaGFuZGxlV2FsbGV0Q2FwYWJpbGl0aWVzUmVzdWx0LnNldCh0aGlzLCAoY2FwYWJpbGl0aWVzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpbnZlc3RpZ2F0ZSB3aHkgdXNpbmcgU29sYW5hU2lnblRyYW5zYWN0aW9ucyBjb25zdGFudCBicmVha3MgdHJlZXNoYWtpbmdcbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRzU2lnblRyYW5zYWN0aW9uID0gY2FwYWJpbGl0aWVzLmZlYXR1cmVzLmluY2x1ZGVzKCdzb2xhbmE6c2lnblRyYW5zYWN0aW9ucycpOyAvL1NvbGFuYVNpZ25UcmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydHNTaWduQW5kU2VuZFRyYW5zYWN0aW9uID0gY2FwYWJpbGl0aWVzLnN1cHBvcnRzX3NpZ25fYW5kX3NlbmRfdHJhbnNhY3Rpb25zIHx8XG4gICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzLmZlYXR1cmVzLmluY2x1ZGVzKCdzb2xhbmE6c2lnbkFuZFNlbmRUcmFuc2FjdGlvbicpO1xuICAgICAgICAgICAgY29uc3QgZGlkQ2FwYWJpbGl0aWVzQ2hhbmdlID0gU29sYW5hU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiBpbiB0aGlzLmZlYXR1cmVzICE9PSBzdXBwb3J0c1NpZ25BbmRTZW5kVHJhbnNhY3Rpb24gfHxcbiAgICAgICAgICAgICAgICBTb2xhbmFTaWduVHJhbnNhY3Rpb24gaW4gdGhpcy5mZWF0dXJlcyAhPT0gc3VwcG9ydHNTaWduVHJhbnNhY3Rpb247XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb3B0aW9uYWxGZWF0dXJlcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoc3VwcG9ydHNTaWduQW5kU2VuZFRyYW5zYWN0aW9uICYmIHtcbiAgICAgICAgICAgICAgICBbU29sYW5hU2lnbkFuZFNlbmRUcmFuc2FjdGlvbl06IHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uczogY2FwYWJpbGl0aWVzLnN1cHBvcnRlZF90cmFuc2FjdGlvbl92ZXJzaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbjogX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3NpZ25BbmRTZW5kVHJhbnNhY3Rpb24sIFwiZlwiKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkpLCAoc3VwcG9ydHNTaWduVHJhbnNhY3Rpb24gJiYge1xuICAgICAgICAgICAgICAgIFtTb2xhbmFTaWduVHJhbnNhY3Rpb25dOiB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnM6IGNhcGFiaWxpdGllcy5zdXBwb3J0ZWRfdHJhbnNhY3Rpb25fdmVyc2lvbnMsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25UcmFuc2FjdGlvbjogX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3NpZ25UcmFuc2FjdGlvbiwgXCJmXCIpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSksIFwiZlwiKTtcbiAgICAgICAgICAgIGlmIChkaWRDYXBhYmlsaXRpZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaW5zdGFuY2VzLCBcIm1cIiwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfZW1pdCkuY2FsbCh0aGlzLCAnY2hhbmdlJywgeyBmZWF0dXJlczogdGhpcy5mZWF0dXJlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtUmVhdXRob3JpemF0aW9uLnNldCh0aGlzLCAod2FsbGV0LCBhdXRoVG9rZW4sIGNoYWluKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY2FwYWJpbGl0aWVzLCBtd2FBdXRob3JpemF0aW9uUmVzdWx0XSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgKF9jID0gKF9iID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb24sIFwiZlwiKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhcGFiaWxpdGllcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogeWllbGQgd2FsbGV0LmdldENhcGFiaWxpdGllcygpLFxuICAgICAgICAgICAgICAgICAgICB3YWxsZXQuYXV0aG9yaXplKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhfdG9rZW46IGF1dGhUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aXR5OiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXBwSWRlbnRpdHksIFwiZlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluOiBjaGFpblxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2FjY291bnRzVG9XYWxsZXRTdGFuZGFyZEFjY291bnRzLCBcImZcIikuY2FsbCh0aGlzLCBtd2FBdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtd2FBdXRob3JpemF0aW9uUmVzdWx0KSwgeyBhY2NvdW50czogYWNjb3VudHMsIGNoYWluOiBjaGFpbiwgY2FwYWJpbGl0aWVzOiBjYXBhYmlsaXRpZXMgfSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbkNhY2hlLCBcImZcIikuc2V0KGF1dGhvcml6YXRpb24pLFxuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdCwgXCJmXCIpLmNhbGwodGhpcywgYXV0aG9yaXphdGlvbiksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9kaXNjb25uZWN0LCBcImZcIikuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfZGlzY29ubmVjdC5zZXQodGhpcywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9kO1xuICAgICAgICAgICAgdmFyIF9lO1xuICAgICAgICAgICAgKF9kID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3Nlc3Npb24sIFwiZlwiKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNsb3NlKCk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbkNhY2hlLCBcImZcIikuY2xlYXIoKTsgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY29ubmVjdGluZywgZmFsc2UsIFwiZlwiKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jb25uZWN0aW9uR2VuZXJhdGlvbiwgKF9lID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Nvbm5lY3Rpb25HZW5lcmF0aW9uLCBcImZcIiksIF9lKyssIF9lKSwgXCJmXCIpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb24sIHVuZGVmaW5lZCwgXCJmXCIpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3Nlc3Npb24sIHVuZGVmaW5lZCwgXCJmXCIpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2luc3RhbmNlcywgXCJtXCIsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2VtaXQpLmNhbGwodGhpcywgJ2NoYW5nZScsIHsgYWNjb3VudHM6IHRoaXMuYWNjb3VudHMgfSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdHJhbnNhY3Quc2V0KHRoaXMsIChjYWxsYmFjaykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9mO1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0VXJpQmFzZSA9IChfZiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uLCBcImZcIikpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi53YWxsZXRfdXJpX2Jhc2U7XG4gICAgICAgICAgICBjb25zdCBiYXNlQ29uZmlnID0gd2FsbGV0VXJpQmFzZSA/IHsgYmFzZVVyaTogd2FsbGV0VXJpQmFzZSB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlQ29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlQ29uZmlnKSwgeyByZW1vdGVIb3N0QXV0aG9yaXR5OiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaG9zdEF1dGhvcml0eSwgXCJmXCIpIH0pO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbm5lY3Rpb25HZW5lcmF0aW9uID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Nvbm5lY3Rpb25HZW5lcmF0aW9uLCBcImZcIik7XG4gICAgICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBSZW1vdGVDb25uZWN0aW9uTW9kYWwoKTtcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2Vzc2lvbiwgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zZXNzaW9uLCBcImZcIikud2FsbGV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhc3NvY2lhdGlvblVybCwgY2xvc2UsIHdhbGxldCB9ID0geWllbGQgc3RhcnRSZW1vdGVTY2VuYXJpbyhyZW1vdGVDb25maWcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZUNsb3NlTGlzdGVuZXIgPSBtb2RhbC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1vZGFsLmluaXRXaXRoUVIoYXNzb2NpYXRpb25VcmwudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgbW9kYWwub3BlbigpO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zZXNzaW9uLCB7IGNsb3NlLCB3YWxsZXQ6IHlpZWxkIHdhbGxldCB9LCBcImZcIik7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xvc2VMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgIG1vZGFsLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zZXNzaW9uLCBcImZcIikud2FsbGV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Nvbm5lY3Rpb25HZW5lcmF0aW9uLCBcImZcIikgIT09IGN1cnJlbnRDb25uZWN0aW9uR2VuZXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZSgoKSA9PiB7IH0pOyAvLyBOZXZlciByZXNvbHZlLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIGUubmFtZSA9PT0gJ1NvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcicgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5jb2RlID09PSAnRVJST1JfV0FMTEVUX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X29uV2FsbGV0Tm90Rm91bmQsIFwiZlwiKS5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Fzc2VydElzQXV0aG9yaXplZC5zZXQodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbiwgXCJmXCIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiB7IGF1dGhUb2tlbjogX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb24sIFwiZlwiKS5hdXRoX3Rva2VuLCBjaGFpbjogX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb24sIFwiZlwiKS5jaGFpbiB9O1xuICAgICAgICB9KTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYWNjb3VudHNUb1dhbGxldFN0YW5kYXJkQWNjb3VudHMuc2V0KHRoaXMsIChhY2NvdW50cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnRzLm1hcCgoYWNjb3VudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gdG9VaW50OEFycmF5KGFjY291bnQuYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogYmFzZTU4LmVuY29kZShwdWJsaWNLZXkpLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBhY2NvdW50LmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiBhY2NvdW50Lmljb24sXG4gICAgICAgICAgICAgICAgICAgIGNoYWluczogKF9hID0gYWNjb3VudC5jaGFpbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jaGFpbnMsIFwiZlwiKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZ2V0IHN1cHBvcnRlZCBmZWF0dXJlcyBmcm9tIGdldENhcGFiaWxpdGllcyBBUEkgXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzOiAoX2IgPSBhY2NvdW50LmZlYXR1cmVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBERUZBVUxUX0ZFQVRVUkVTXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfcGVyZm9ybVNpZ25UcmFuc2FjdGlvbnMuc2V0KHRoaXMsICh0cmFuc2FjdGlvbnMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0aFRva2VuLCBjaGFpbiB9ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Fzc2VydElzQXV0aG9yaXplZCwgXCJmXCIpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdHJhbnNhY3QsIFwiZlwiKS5jYWxsKHRoaXMsICh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1SZWF1dGhvcml6YXRpb24sIFwiZlwiKS5jYWxsKHRoaXMsIHdhbGxldCwgYXV0aFRva2VuLCBjaGFpbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9ICh5aWVsZCB3YWxsZXQuc2lnblRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkczogdHJhbnNhY3Rpb25zLm1hcChmcm9tVWludDhBcnJheSksXG4gICAgICAgICAgICAgICAgICAgIH0pKS5zaWduZWRfcGF5bG9hZHMubWFwKHRvVWludDhBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbnM7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfcGVyZm9ybVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24uc2V0KHRoaXMsICh0cmFuc2FjdGlvbiwgb3B0aW9ucykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhdXRoVG9rZW4sIGNoYWluIH0gPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXNzZXJ0SXNBdXRob3JpemVkLCBcImZcIikuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF90cmFuc2FjdCwgXCJmXCIpLmNhbGwodGhpcywgKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbY2FwYWJpbGl0aWVzLCBfMV0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQuZ2V0Q2FwYWJpbGl0aWVzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfcGVyZm9ybVJlYXV0aG9yaXphdGlvbiwgXCJmXCIpLmNhbGwodGhpcywgd2FsbGV0LCBhdXRoVG9rZW4sIGNoYWluKVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcGFiaWxpdGllcy5zdXBwb3J0c19zaWduX2FuZF9zZW5kX3RyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9ICh5aWVsZCB3YWxsZXQuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBwYXlsb2FkczogW2Zyb21VaW50OEFycmF5KHRyYW5zYWN0aW9uKV0gfSkpKS5zaWduYXR1cmVzLm1hcCh0b1VpbnQ4QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nvbm5lY3RlZCB3YWxsZXQgZG9lcyBub3Qgc3VwcG9ydCBzaWduQW5kU2VuZFRyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSkgfHwgJ1Vua25vd24gZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zaWduQW5kU2VuZFRyYW5zYWN0aW9uLnNldCh0aGlzLCAoLi4uaW5wdXRzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9ICh5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfcGVyZm9ybVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24sIFwiZlwiKS5jYWxsKHRoaXMsIGlucHV0LnRyYW5zYWN0aW9uLCBpbnB1dC5vcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHsgc2lnbmF0dXJlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnblRyYW5zYWN0aW9uLnNldCh0aGlzLCAoLi4uaW5wdXRzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtU2lnblRyYW5zYWN0aW9ucywgXCJmXCIpLmNhbGwodGhpcywgaW5wdXRzLm1hcCgoeyB0cmFuc2FjdGlvbiB9KSA9PiB0cmFuc2FjdGlvbikpKVxuICAgICAgICAgICAgICAgIC5tYXAoKHNpZ25lZFRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc2lnbmVkVHJhbnNhY3Rpb24gfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgICAgIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3NpZ25NZXNzYWdlLnNldCh0aGlzLCAoLi4uaW5wdXRzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhUb2tlbiwgY2hhaW4gfSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hc3NlcnRJc0F1dGhvcml6ZWQsIFwiZlwiKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gaW5wdXRzLm1hcCgoeyBhY2NvdW50IH0pID0+IGZyb21VaW50OEFycmF5KGFjY291bnQucHVibGljS2V5KSk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGlucHV0cy5tYXAoKHsgbWVzc2FnZSB9KSA9PiBmcm9tVWludDhBcnJheShtZXNzYWdlKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdHJhbnNhY3QsIFwiZlwiKS5jYWxsKHRoaXMsICh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1SZWF1dGhvcml6YXRpb24sIFwiZlwiKS5jYWxsKHRoaXMsIHdhbGxldCwgYXV0aFRva2VuLCBjaGFpbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2VzID0gKHlpZWxkIHdhbGxldC5zaWduTWVzc2FnZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBhZGRyZXNzZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkczogbWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgIH0pKS5zaWduZWRfcGF5bG9hZHMubWFwKHRvVWludDhBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRNZXNzYWdlcy5tYXAoKHNpZ25lZE1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHNpZ25lZE1lc3NhZ2U6IHNpZ25lZE1lc3NhZ2UsIHNpZ25hdHVyZTogc2lnbmVkTWVzc2FnZS5zbGljZSgtU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUykgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnbkluLnNldCh0aGlzLCAoLi4uaW5wdXRzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gW107XG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2goeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1TaWduSW4sIFwiZlwiKS5jYWxsKHRoaXMsIGlucHV0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfcGVyZm9ybVNpZ25JbiwgXCJmXCIpLmNhbGwodGhpcywgaW5wdXRzWzBdKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICAgICAgfSkpO1xuICAgICAgICBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtU2lnbkluLnNldCh0aGlzLCAoaW5wdXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfZywgX2gsIF9qO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Nvbm5lY3RpbmcsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtQXV0aG9yaXphdGlvbiwgXCJmXCIpLmNhbGwodGhpcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnB1dCksIHsgZG9tYWluOiAoX2cgPSBpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXQuZG9tYWluKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiB3aW5kb3cubG9jYXRpb24uaG9zdCB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKCFhdXRob3JpemF0aW9uUmVzdWx0LnNpZ25faW5fcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ24gaW4gZmFpbGVkLCBubyBzaWduIGluIHJlc3VsdCByZXR1cm5lZCBieSB3YWxsZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZEluQWRkcmVzcyA9IGF1dGhvcml6YXRpb25SZXN1bHQuc2lnbl9pbl9yZXN1bHQuYWRkcmVzcztcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRJbkFjY291bnQgPSBhdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzLmZpbmQoYWNjID0+IGFjYy5hZGRyZXNzID09IHNpZ25lZEluQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaWduZWRJbkFjY291bnQgIT09IG51bGwgJiYgc2lnbmVkSW5BY2NvdW50ICE9PSB2b2lkIDAgPyBzaWduZWRJbkFjY291bnQgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBiYXNlNTguZW5jb2RlKHRvVWludDhBcnJheShzaWduZWRJbkFkZHJlc3MpKVxuICAgICAgICAgICAgICAgICAgICB9KSwgeyBwdWJsaWNLZXk6IHRvVWludDhBcnJheShzaWduZWRJbkFkZHJlc3MpLCBjaGFpbnM6IChfaCA9IHNpZ25lZEluQWNjb3VudCA9PT0gbnVsbCB8fCBzaWduZWRJbkFjY291bnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNpZ25lZEluQWNjb3VudC5jaGFpbnMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jaGFpbnMsIFwiZlwiKSwgZmVhdHVyZXM6IChfaiA9IHNpZ25lZEluQWNjb3VudCA9PT0gbnVsbCB8fCBzaWduZWRJbkFjY291bnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNpZ25lZEluQWNjb3VudC5mZWF0dXJlcykgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogYXV0aG9yaXphdGlvblJlc3VsdC5jYXBhYmlsaXRpZXMuZmVhdHVyZXMgfSksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25lZE1lc3NhZ2U6IHRvVWludDhBcnJheShhdXRob3JpemF0aW9uUmVzdWx0LnNpZ25faW5fcmVzdWx0LnNpZ25lZF9tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiB0b1VpbnQ4QXJyYXkoYXV0aG9yaXphdGlvblJlc3VsdC5zaWduX2luX3Jlc3VsdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlKSB8fCAnVW5rbm93biBlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Nvbm5lY3RpbmcsIGZhbHNlLCBcImZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb25DYWNoZSwgY29uZmlnLmF1dGhvcml6YXRpb25DYWNoZSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXBwSWRlbnRpdHksIGNvbmZpZy5hcHBJZGVudGl0eSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY2hhaW5zLCBjb25maWcuY2hhaW5zLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jaGFpblNlbGVjdG9yLCBjb25maWcuY2hhaW5TZWxlY3RvciwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaG9zdEF1dGhvcml0eSwgY29uZmlnLnJlbW90ZUhvc3RBdXRob3JpdHksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X29uV2FsbGV0Tm90Rm91bmQsIGNvbmZpZy5vbldhbGxldE5vdEZvdW5kLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9vcHRpb25hbEZlYXR1cmVzLCB7XG4gICAgICAgICAgICAvLyBJbiBNV0EgMS4wLCBzaWduQW5kU2VuZCBpcyBvcHRpb25hbCBhbmQgc2lnblRyYW5zYWN0aW9uIGlzIG1hbmRhdG9yeS4gV2hlcmVhcyBpbiBNV0EgMi4wKyxcbiAgICAgICAgICAgIC8vIHNpZ25BbmRTZW5kIGlzIG1hbmRhdG9yeSBhbmQgc2lnblRyYW5zYWN0aW9uIGlzIG9wdGlvbmFsIChhbmQgc29mdCBkZXByZWNhdGVkKS4gQXMgb2YgbWlkXG4gICAgICAgICAgICAvLyAyMDI1LCBhbGwgTVdBIHdhbGxldHMgc3VwcG9ydCBib3RoIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gYW5kIHNpZ25UcmFuc2FjdGlvbiBzbyBpdHMgc2FmZVxuICAgICAgICAgICAgLy8gYXNzdW1lIGJvdGggYXJlIHN1cHBvcnRlZCBoZXJlLiBUaGUgZmVhdHVyZXMgd2lsbCBiZSB1cGRhdGVkIGJhc2VkIG9uIHRoZSBhY3R1YWwgY29ubmVjdGVkIFxuICAgICAgICAgICAgLy8gd2FsbGV0cyBjYXBhYmlsaXRpZXMgZHVyaW5nIGNvbm5lY3Rpb24gcmVnYXJkbGVzcywgc28gdGhpcyBpcyBzYWZlLiBcbiAgICAgICAgICAgIFtTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uXToge1xuICAgICAgICAgICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uczogWydsZWdhY3knLCAwXSxcbiAgICAgICAgICAgICAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnbkFuZFNlbmRUcmFuc2FjdGlvbiwgXCJmXCIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtTb2xhbmFTaWduVHJhbnNhY3Rpb25dOiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zOiBbJ2xlZ2FjeScsIDBdLFxuICAgICAgICAgICAgICAgIHNpZ25UcmFuc2FjdGlvbjogX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3NpZ25UcmFuc2FjdGlvbiwgXCJmXCIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgdmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF92ZXJzaW9uLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X25hbWUsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IHVybCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF91cmwsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGljb24oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaWNvbiwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgY2hhaW5zKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2NoYWlucywgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgZmVhdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgW1N0YW5kYXJkQ29ubmVjdF06IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Q6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jb25uZWN0LCBcImZcIiksXG4gICAgICAgICAgICB9LCBbU3RhbmRhcmREaXNjb25uZWN0XToge1xuICAgICAgICAgICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdDogX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2Rpc2Nvbm5lY3QsIFwiZlwiKSxcbiAgICAgICAgICAgIH0sIFtTdGFuZGFyZEV2ZW50c106IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICAgICAgICAgIG9uOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb24sIFwiZlwiKSxcbiAgICAgICAgICAgIH0sIFtTb2xhbmFTaWduTWVzc2FnZV06IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICAgICAgICAgIHNpZ25NZXNzYWdlOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnbk1lc3NhZ2UsIFwiZlwiKSxcbiAgICAgICAgICAgIH0sIFtTb2xhbmFTaWduSW5dOiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgICAgICAgICBzaWduSW46IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zaWduSW4sIFwiZlwiKSxcbiAgICAgICAgICAgIH0gfSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X29wdGlvbmFsRmVhdHVyZXMsIFwiZlwiKSk7XG4gICAgfVxuICAgIGdldCBhY2NvdW50cygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uLCBcImZcIikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2NvdW50cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgfVxuICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhIV9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zZXNzaW9uLCBcImZcIikgJiYgISFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbiwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgaXNBdXRob3JpemVkKCkge1xuICAgICAgICByZXR1cm4gISFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbiwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEF1dGhvcml6YXRpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfYXV0aG9yaXphdGlvbiwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uQ2FjaGUsIFwiZlwiKS5nZXQoKTtcbiAgICB9XG59XG5fUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9saXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF92ZXJzaW9uID0gbmV3IFdlYWtNYXAoKSwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfbmFtZSA9IG5ldyBXZWFrTWFwKCksIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3VybCA9IG5ldyBXZWFrTWFwKCksIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2ljb24gPSBuZXcgV2Vha01hcCgpLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hcHBJZGVudGl0eSA9IG5ldyBXZWFrTWFwKCksIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2F1dGhvcml6YXRpb24gPSBuZXcgV2Vha01hcCgpLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hdXRob3JpemF0aW9uQ2FjaGUgPSBuZXcgV2Vha01hcCgpLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jb25uZWN0aW5nID0gbmV3IFdlYWtNYXAoKSwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY29ubmVjdGlvbkdlbmVyYXRpb24gPSBuZXcgV2Vha01hcCgpLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jaGFpbnMgPSBuZXcgV2Vha01hcCgpLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9jaGFpblNlbGVjdG9yID0gbmV3IFdlYWtNYXAoKSwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfb3B0aW9uYWxGZWF0dXJlcyA9IG5ldyBXZWFrTWFwKCksIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X29uV2FsbGV0Tm90Rm91bmQgPSBuZXcgV2Vha01hcCgpLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9ob3N0QXV0aG9yaXR5ID0gbmV3IFdlYWtNYXAoKSwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2Vzc2lvbiA9IG5ldyBXZWFrTWFwKCksIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X29uID0gbmV3IFdlYWtNYXAoKSwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfY29ubmVjdCA9IG5ldyBXZWFrTWFwKCksIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1BdXRob3JpemF0aW9uID0gbmV3IFdlYWtNYXAoKSwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdCA9IG5ldyBXZWFrTWFwKCksIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2hhbmRsZVdhbGxldENhcGFiaWxpdGllc1Jlc3VsdCA9IG5ldyBXZWFrTWFwKCksIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1SZWF1dGhvcml6YXRpb24gPSBuZXcgV2Vha01hcCgpLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9kaXNjb25uZWN0ID0gbmV3IFdlYWtNYXAoKSwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfdHJhbnNhY3QgPSBuZXcgV2Vha01hcCgpLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hc3NlcnRJc0F1dGhvcml6ZWQgPSBuZXcgV2Vha01hcCgpLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9hY2NvdW50c1RvV2FsbGV0U3RhbmRhcmRBY2NvdW50cyA9IG5ldyBXZWFrTWFwKCksIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X3BlcmZvcm1TaWduVHJhbnNhY3Rpb25zID0gbmV3IFdlYWtNYXAoKSwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfcGVyZm9ybVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gPSBuZXcgV2Vha01hcCgpLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zaWduQW5kU2VuZFRyYW5zYWN0aW9uID0gbmV3IFdlYWtNYXAoKSwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnblRyYW5zYWN0aW9uID0gbmV3IFdlYWtNYXAoKSwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfc2lnbk1lc3NhZ2UgPSBuZXcgV2Vha01hcCgpLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9zaWduSW4gPSBuZXcgV2Vha01hcCgpLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9wZXJmb3JtU2lnbkluID0gbmV3IFdlYWtNYXAoKSwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfZW1pdCA9IGZ1bmN0aW9uIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2VtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICAoX2EgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0JDEodGhpcywgX1JlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXRfbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyLmFwcGx5KG51bGwsIGFyZ3MpKTtcbn0sIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X29mZiA9IGZ1bmN0aW9uIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X29mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCQxKHRoaXMsIF9SZW1vdGVTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0X2xpc3RlbmVycywgXCJmXCIpW2V2ZW50XSA9IChfYSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQkMSh0aGlzLCBfUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldF9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIoKGV4aXN0aW5nTGlzdGVuZXIpID0+IGxpc3RlbmVyICE9PSBleGlzdGluZ0xpc3RlbmVyKTtcbn07XG5cbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9SZWdpc3RlcldhbGxldEV2ZW50X2RldGFpbDtcbi8qKlxuICogUmVnaXN0ZXIgYSB7QGxpbmsgXCJAd2FsbGV0LXN0YW5kYXJkL2Jhc2VcIi5XYWxsZXR9IGFzIGEgU3RhbmRhcmQgV2FsbGV0IHdpdGggdGhlIGFwcC5cbiAqXG4gKiBUaGlzIGRpc3BhdGNoZXMgYSB7QGxpbmsgXCJAd2FsbGV0LXN0YW5kYXJkL2Jhc2VcIi5XaW5kb3dSZWdpc3RlcldhbGxldEV2ZW50fSB0byBub3RpZnkgdGhlIGFwcCB0aGF0IHRoZSBXYWxsZXQgaXNcbiAqIHJlYWR5IHRvIGJlIHJlZ2lzdGVyZWQuXG4gKlxuICogVGhpcyBhbHNvIGFkZHMgYSBsaXN0ZW5lciBmb3Ige0BsaW5rIFwiQHdhbGxldC1zdGFuZGFyZC9iYXNlXCIuV2luZG93QXBwUmVhZHlFdmVudH0gdG8gbGlzdGVuIGZvciBhIG5vdGlmaWNhdGlvbiBmcm9tXG4gKiB0aGUgYXBwIHRoYXQgdGhlIGFwcCBpcyByZWFkeSB0byByZWdpc3RlciB0aGUgV2FsbGV0LlxuICpcbiAqIFRoaXMgY29tYmluYXRpb24gb2YgZXZlbnQgZGlzcGF0Y2ggYW5kIGxpc3RlbmVyIGd1YXJhbnRlZXMgdGhhdCB0aGUgV2FsbGV0IHdpbGwgYmUgcmVnaXN0ZXJlZCBzeW5jaHJvbm91c2x5IGFzIHNvb25cbiAqIGFzIHRoZSBhcHAgaXMgcmVhZHkgd2hldGhlciB0aGUgV2FsbGV0IGxvYWRzIGJlZm9yZSBvciBhZnRlciB0aGUgYXBwLlxuICpcbiAqIEBwYXJhbSB3YWxsZXQgV2FsbGV0IHRvIHJlZ2lzdGVyLlxuICpcbiAqIEBncm91cCBXYWxsZXRcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJXYWxsZXQod2FsbGV0KSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoeyByZWdpc3RlciB9KSA9PiByZWdpc3Rlcih3YWxsZXQpO1xuICAgIHRyeSB7XG4gICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBSZWdpc3RlcldhbGxldEV2ZW50KGNhbGxiYWNrKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCd3YWxsZXQtc3RhbmRhcmQ6cmVnaXN0ZXItd2FsbGV0IGV2ZW50IGNvdWxkIG5vdCBiZSBkaXNwYXRjaGVkXFxuJywgZXJyb3IpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignd2FsbGV0LXN0YW5kYXJkOmFwcC1yZWFkeScsICh7IGRldGFpbDogYXBpIH0pID0+IGNhbGxiYWNrKGFwaSkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignd2FsbGV0LXN0YW5kYXJkOmFwcC1yZWFkeSBldmVudCBsaXN0ZW5lciBjb3VsZCBub3QgYmUgYWRkZWRcXG4nLCBlcnJvcik7XG4gICAgfVxufVxuY2xhc3MgUmVnaXN0ZXJXYWxsZXRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICAgICAgICBzdXBlcignd2FsbGV0LXN0YW5kYXJkOnJlZ2lzdGVyLXdhbGxldCcsIHtcbiAgICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb21wb3NlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBfUmVnaXN0ZXJXYWxsZXRFdmVudF9kZXRhaWwuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1JlZ2lzdGVyV2FsbGV0RXZlbnRfZGV0YWlsLCBjYWxsYmFjaywgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgZGV0YWlsKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUmVnaXN0ZXJXYWxsZXRFdmVudF9kZXRhaWwsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnd2FsbGV0LXN0YW5kYXJkOnJlZ2lzdGVyLXdhbGxldCc7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZXZlbnREZWZhdWx0IGNhbm5vdCBiZSBjYWxsZWQnKTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiBjYW5ub3QgYmUgY2FsbGVkJyk7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdG9wUHJvcGFnYXRpb24gY2Fubm90IGJlIGNhbGxlZCcpO1xuICAgIH1cbn1cbl9SZWdpc3RlcldhbGxldEV2ZW50X2RldGFpbCA9IG5ldyBXZWFrTWFwKCk7XG5cbih1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbih1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG5cbmZ1bmN0aW9uIGdldElzTG9jYWxBc3NvY2lhdGlvblN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHdpbmRvdy5pc1NlY3VyZUNvbnRleHQgJiZcbiAgICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvYW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpO1xufVxuZnVuY3Rpb24gZ2V0SXNSZW1vdGVBc3NvY2lhdGlvblN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHdpbmRvdy5pc1NlY3VyZUNvbnRleHQgJiZcbiAgICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAhL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKTtcbn1cbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FuemEteHl6L3dhbGxldC1hZGFwdGVyL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL2NvcmUvcmVhY3Qvc3JjL2dldEVudmlyb25tZW50LnRzI0wxNFxuLy8gVGhpcyBpcyB0aGUgc2FtZSBpbXBsZW1lbnRhdGlvbiB0aGF0IGdhdGVkIE1XQSBpbiB0aGUgQW56YSB3YWxsZXQtYWRhcHRlci1yZWFjdCBsaWJyYXJ5LlxuZnVuY3Rpb24gaXNXZWJWaWV3KHVzZXJBZ2VudFN0cmluZykge1xuICAgIHJldHVybiAvKFdlYlZpZXd8VmVyc2lvblxcLy4rKENocm9tZSlcXC8oXFxkKylcXC4oXFxkKylcXC4oXFxkKylcXC4oXFxkKyl8OyB3dlxcKS4rKENocm9tZSlcXC8oXFxkKylcXC4oXFxkKylcXC4oXFxkKylcXC4oXFxkKykpL2kudGVzdCh1c2VyQWdlbnRTdHJpbmcpO1xufVxuXG5mdW5jdGlvbiByZWdpc3Rlck13YShjb25maWcpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBNV0Egbm90IHJlZ2lzdGVyZWQ6IG5vIHdpbmRvdyBvYmplY3RgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXdpbmRvdy5pc1NlY3VyZUNvbnRleHQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBNV0Egbm90IHJlZ2lzdGVyZWQ6IHNlY3VyZSBjb250ZXh0IHJlcXVpcmVkIChodHRwcylgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBMb2NhbCBhc3NvY2lhdGlvbiB0ZWNobmljYWxseSBpcyBwb3NzaWJsZSBpbiBhIHdlYnZpZXcsIGJ1dCB3ZSBwcmV2ZW50IHJlZ2lzdHJhdGlvblxuICAgIC8vIGJ5IGRlZmF1bHQgYmVjYXVzZSBpdCB1c3VhbGx5IGZhaWxzIGluIHRoZSBtb3N0IGNvbW1vbiBjYXNlcyAoZS5nIHdhbGxldCBicm93c2VycykuXG4gICAgaWYgKGdldElzTG9jYWxBc3NvY2lhdGlvblN1cHBvcnRlZCgpICYmICFpc1dlYlZpZXcobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgcmVnaXN0ZXJXYWxsZXQobmV3IExvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldChjb25maWcpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2V0SXNSZW1vdGVBc3NvY2lhdGlvblN1cHBvcnRlZCgpICYmIGNvbmZpZy5yZW1vdGVIb3N0QXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVnaXN0ZXJXYWxsZXQobmV3IFJlbW90ZVNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25maWcpLCB7IHJlbW90ZUhvc3RBdXRob3JpdHk6IGNvbmZpZy5yZW1vdGVIb3N0QXV0aG9yaXR5IH0pKSk7XG4gICAgfVxuICAgIGVsc2UgO1xufVxuXG5jb25zdCBXQUxMRVRfTk9UX0ZPVU5EX0VSUk9SX01FU1NBR0UgPSAnVG8gdXNlIG1vYmlsZSB3YWxsZXQgYWRhcHRlciwgeW91IG11c3QgaGF2ZSBhIGNvbXBhdGlibGUgbW9iaWxlIHdhbGxldCBhcHBsaWNhdGlvbiBpbnN0YWxsZWQgb24geW91ciBkZXZpY2UuJztcbmNvbnN0IEJST1dTRVJfTk9UX1NVUFBPUlRFRF9FUlJPUl9NRVNTQUdFID0gJ1RoaXMgYnJvd3NlciBhcHBlYXJzIHRvIGJlIGluY29tcGF0aWJsZSB3aXRoIG1vYmlsZSB3YWxsZXQgYWRhcHRlci4gT3BlbiB0aGlzIHBhZ2UgaW4gYSBjb21wYXRpYmxlIG1vYmlsZSBicm93c2VyIGFwcCBhbmQgdHJ5IGFnYWluLic7XG5jbGFzcyBFcnJvck1vZGFsIGV4dGVuZHMgRW1iZWRkZWRNb2RhbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY29udGVudFN0eWxlcyA9IGNzcztcbiAgICAgICAgdGhpcy5jb250ZW50SHRtbCA9IEVycm9yRGlhbG9nSHRtbDtcbiAgICB9XG4gICAgaW5pdFdpdGhFcnJvcihlcnJvcikge1xuICAgICAgICBzdXBlci5pbml0KCk7XG4gICAgICAgIHRoaXMucG9wdWxhdGVFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIHBvcHVsYXRlRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlRWxlbWVudCA9IChfYSA9IHRoaXMuZG9tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0RWxlbWVudEJ5SWQoJ21vYmlsZS13YWxsZXQtYWRhcHRlci1lcnJvci1tZXNzYWdlJyk7XG4gICAgICAgIGNvbnN0IGFjdGlvbkJ0biA9IChfYiA9IHRoaXMuZG9tKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0RWxlbWVudEJ5SWQoJ21vYmlsZS13YWxsZXQtYWRhcHRlci1lcnJvci1hY3Rpb24nKTtcbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yJykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdFUlJPUl9XQUxMRVRfTk9UX0ZPVU5EJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZUVsZW1lbnQuaW5uZXJIVE1MID0gV0FMTEVUX05PVF9GT1VORF9FUlJPUl9NRVNTQUdFO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbkJ0bilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25CdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJ2h0dHBzOi8vc29sYW5hbW9iaWxlLmNvbS93YWxsZXRzJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRVJST1JfQlJPV1NFUl9OT1RfU1VQUE9SVEVEJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZUVsZW1lbnQuaW5uZXJIVE1MID0gQlJPV1NFUl9OT1RfU1VQUE9SVEVEX0VSUk9SX01FU1NBR0U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uQnRuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkJ0bi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yTWVzc2FnZUVsZW1lbnQuaW5uZXJIVE1MID0gYEFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQ6ICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBsb2NhdGUgZXJyb3IgZGlhbG9nIGVsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IEVycm9yRGlhbG9nSHRtbCA9IGBcbjxzdmcgY2xhc3M9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtZXJyb3ItaWNvblwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBoZWlnaHQ9XCI1MHB4XCIgdmlld0JveD1cIjAgLTk2MCA5NjAgOTYwXCIgd2lkdGg9XCI1MHB4XCIgZmlsbD1cIiMwMDAwMDBcIj48cGF0aCBkPVwiTSAyODAsLTgwIFEgMTk3LC04MCAxMzguNSwtMTM4LjUgODAsLTE5NyA4MCwtMjgwIDgwLC0zNjMgMTM4LjUsLTQyMS41IDE5NywtNDgwIDI4MCwtNDgwIHEgODMsMCAxNDEuNSw1OC41IDU4LjUsNTguNSA1OC41LDE0MS41IDAsODMgLTU4LjUsMTQxLjUgUSAzNjMsLTgwIDI4MCwtODAgWiBNIDgyNCwtMTIwIDU2OCwtMzc2IFEgNTU2LC0zODkgNTQyLjUsLTQwMi41IDUyOSwtNDE2IDUxNiwtNDI4IHEgMzgsLTI0IDYxLC02NCAyMywtNDAgMjMsLTg4IDAsLTc1IC01Mi41LC0xMjcuNSBRIDQ5NSwtNzYwIDQyMCwtNzYwIDM0NSwtNzYwIDI5Mi41LC03MDcuNSAyNDAsLTY1NSAyNDAsLTU4MCBxIDAsNiAwLjUsMTEuNSAwLjUsNS41IDEuNSwxMS41IC0xOCwyIC0zOS41LDggLTIxLjUsNiAtMzguNSwxNCAtMiwtMTEgLTMsLTIyIC0xLC0xMSAtMSwtMjMgMCwtMTA5IDc1LjUsLTE4NC41IFEgMzExLC04NDAgNDIwLC04NDAgcSAxMDksMCAxODQuNSw3NS41IDc1LjUsNzUuNSA3NS41LDE4NC41IDAsNDMgLTEzLjUsODEuNSBRIDY1MywtNDYwIDYyOSwtNDI4IGwgMjUxLDI1MiB6IG0gLTYxNSwtNjEgNzEsLTcxIDcwLDcxIDI5LC0yOCAtNzEsLTcxIDcxLC03MSAtMjgsLTI4IC03MSw3MSAtNzEsLTcxIC0yOCwyOCA3MSw3MSAtNzEsNzEgelwiLz48L3N2Zz5cbjxkaXYgY2xhc3M9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtdGl0bGVcIj5XZSBjYW4ndCBmaW5kIGEgd2FsbGV0LjwvZGl2PlxuPGRpdiBpZD1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lcnJvci1tZXNzYWdlXCIgY2xhc3M9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtc3VidGl0bGVcIj48L2Rpdj5cbjxkaXY+XG4gICAgPGJ1dHRvbiBkYXRhLWVycm9yLWFjdGlvbiBpZD1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lcnJvci1hY3Rpb25cIiBjbGFzcz1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1lcnJvci1hY3Rpb25cIj5cbiAgICAgICAgRmluZCBhIHdhbGxldFxuICAgIDwvYnV0dG9uPlxuPC9kaXY+XG5gO1xuY29uc3QgY3NzID0gYFxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jb250ZW50IHtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG59XG5cbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtZXJyb3ItaWNvbiB7XG4gICAgbWFyZ2luLXRvcDogMjRweDtcbn1cblxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC10aXRsZSB7XG4gICAgbWFyZ2luOiAxOHB4IDEwMHB4IGF1dG8gMTAwcHg7XG4gICAgY29sb3I6ICMwMDAwMDA7XG4gICAgZm9udC1zaXplOiAyLjc1ZW07XG4gICAgZm9udC13ZWlnaHQ6IDYwMDtcbn1cblxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1zdWJ0aXRsZSB7XG4gICAgbWFyZ2luOiAzMHB4IDYwcHggNDBweCA2MHB4O1xuICAgIGNvbG9yOiAjMDAwMDAwO1xuICAgIGZvbnQtc2l6ZTogMS4yNWVtO1xuICAgIGZvbnQtd2VpZ2h0OiA0MDA7XG59XG5cbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtZXJyb3ItYWN0aW9uIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDU2cHg7XG4gICAgLyptYXJnaW4tdG9wOiA0MHB4OyovXG4gICAgZm9udC1zaXplOiAxLjI1ZW07XG4gICAgLypsaW5lLWhlaWdodDogMjRweDsqL1xuICAgIC8qbGV0dGVyLXNwYWNpbmc6IC0xJTsqL1xuICAgIGJhY2tncm91bmQ6ICMwMDAwMDA7XG4gICAgY29sb3I6ICNGRkZGRkY7XG4gICAgYm9yZGVyLXJhZGl1czogMThweDtcbn1cblxuLyogU21hbGxlciBzY3JlZW5zICovXG5AbWVkaWEgYWxsIGFuZCAobWF4LXdpZHRoOiA2MDBweCkge1xuICAgIC5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtdGl0bGUge1xuICAgICAgICBmb250LXNpemU6IDEuNWVtO1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDEycHg7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAxMnB4O1xuICAgIH1cbiAgICAubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXN1YnRpdGxlIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAxMnB4O1xuICAgICAgICBtYXJnaW4tbGVmdDogMTJweDtcbiAgICB9XG59XG5gO1xuXG5mdW5jdGlvbiBkZWZhdWx0RXJyb3JNb2RhbFdhbGxldE5vdEZvdW5kSGFuZGxlcigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJBZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvckRpYWxvZyA9IG5ldyBFcnJvck1vZGFsKCk7XG4gICAgICAgICAgICBpZiAodXNlckFnZW50LmluY2x1ZGVzKCd3dicpKSB7IC8vIEFuZHJvaWQgV2ViVmlld1xuICAgICAgICAgICAgICAgIC8vIE1XQSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlciBzbyB3ZSBpbmZvcm0gdGhlIHVzZXJcbiAgICAgICAgICAgICAgICAvLyBlcnJvckRpYWxvZy5pbml0V2l0aEVycm9yKFxuICAgICAgICAgICAgICAgIC8vICAgICBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9CUk9XU0VSX05PVF9TVVBQT1JURUQsIFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgJydcbiAgICAgICAgICAgICAgICAvLyAgICAgKVxuICAgICAgICAgICAgICAgIC8vICk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgd2h5IGluc3RhbnRpYXRpbmcgYSBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yIGhlcmUgYnJlYWtzIHRyZWVzaGFraW5nIFxuICAgICAgICAgICAgICAgIGVycm9yRGlhbG9nLmluaXRXaXRoRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0JST1dTRVJfTk9UX1NVUFBPUlRFRCcsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gQnJvd3NlciwgdXNlciBkb2VzIG5vdCBoYXZlIGEgd2FsbGV0IGluc3RhbGxlZC5cbiAgICAgICAgICAgICAgICAvLyBlcnJvckRpYWxvZy5pbml0V2l0aEVycm9yKFxuICAgICAgICAgICAgICAgIC8vICAgICBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9XQUxMRVRfTk9UX0ZPVU5ELCBcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgLy8gICAgIClcbiAgICAgICAgICAgICAgICAvLyApO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGludmVzdGlnYXRlIHdoeSBpbnN0YW50aWF0aW5nIGEgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvciBoZXJlIGJyZWFrcyB0cmVlc2hha2luZyBcbiAgICAgICAgICAgICAgICBlcnJvckRpYWxvZy5pbml0V2l0aEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1NvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9XQUxMRVRfTk9UX0ZPVU5EJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yRGlhbG9nLm9wZW4oKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlcigpIHtcbiAgICByZXR1cm4gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyBkZWZhdWx0RXJyb3JNb2RhbFdhbGxldE5vdEZvdW5kSGFuZGxlcigpOyB9KTtcbn1cblxuY29uc3QgQ0FDSEVfS0VZID0gJ1NvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJEZWZhdWx0QXV0aG9yaXphdGlvbkNhY2hlJztcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uQ2FjaGUoKSB7XG4gICAgbGV0IHN0b3JhZ2U7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH1cbiAgICBjYXRjaCAoX2EpIHsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNsZWFyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oQ0FDSEVfS0VZKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JhZ2UuZ2V0SXRlbShDQUNIRV9LRVkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZCAmJiBwYXJzZWQuYWNjb3VudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFjY291bnRzID0gcGFyc2VkLmFjY291bnRzLm1hcCgoYWNjb3VudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjY291bnQpLCB7IHB1YmxpY0tleTogJ3B1YmxpY0tleScgaW4gYWNjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgVWludDhBcnJheShPYmplY3QudmFsdWVzKGFjY291bnQucHVibGljS2V5KSkgLy8gUmVidWlsZCBwdWJsaWNLZXkgZm9yIFdhbGxldEFjY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYmFzZTU4LmRlY29kZShhY2NvdW50LmFkZHJlc3MpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJzZWQpLCB7IGFjY291bnRzOiBwYXJzZWRBY2NvdW50cyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKENBQ0hFX0tFWSwgSlNPTi5zdHJpbmdpZnkoYXV0aG9yaXphdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRDaGFpblNlbGVjdG9yKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdChjaGFpbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYWlucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhaW5zLmluY2x1ZGVzKFNPTEFOQV9NQUlOTkVUX0NIQUlOKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU09MQU5BX01BSU5ORVRfQ0hBSU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluc1swXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmV4cG9ydCB7IExvY2FsU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldCwgUmVtb3RlU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldCwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclJlbW90ZVdhbGxldE5hbWUsIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lLCBjcmVhdGVEZWZhdWx0QXV0aG9yaXphdGlvbkNhY2hlLCBjcmVhdGVEZWZhdWx0Q2hhaW5TZWxlY3RvciwgY3JlYXRlRGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlciwgZGVmYXVsdEVycm9yTW9kYWxXYWxsZXROb3RGb3VuZEhhbmRsZXIsIHJlZ2lzdGVyTXdhIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/wallet-standard-mobile/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/wallet-standard-mobile/node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/wallet-standard-mobile/node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaCloneAuthorization: () => (/* binding */ SolanaCloneAuthorization),\n/* harmony export */   SolanaMobileWalletAdapterError: () => (/* binding */ SolanaMobileWalletAdapterError),\n/* harmony export */   SolanaMobileWalletAdapterErrorCode: () => (/* binding */ SolanaMobileWalletAdapterErrorCode),\n/* harmony export */   SolanaMobileWalletAdapterProtocolError: () => (/* binding */ SolanaMobileWalletAdapterProtocolError),\n/* harmony export */   SolanaMobileWalletAdapterProtocolErrorCode: () => (/* binding */ SolanaMobileWalletAdapterProtocolErrorCode),\n/* harmony export */   SolanaSignInWithSolana: () => (/* binding */ SolanaSignInWithSolana),\n/* harmony export */   SolanaSignTransactions: () => (/* binding */ SolanaSignTransactions),\n/* harmony export */   startRemoteScenario: () => (/* binding */ startRemoteScenario),\n/* harmony export */   transact: () => (/* binding */ transact)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-standard-util */ \"(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/signIn.js\");\n/* harmony import */ var _solana_codecs_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/codecs-strings */ \"(ssr)/./node_modules/@solana/codecs-strings/dist/index.node.mjs\");\n\n\n\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaMobileWalletAdapterErrorCode = {\n    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: 'ERROR_ASSOCIATION_PORT_OUT_OF_RANGE',\n    ERROR_REFLECTOR_ID_OUT_OF_RANGE: 'ERROR_REFLECTOR_ID_OUT_OF_RANGE',\n    ERROR_FORBIDDEN_WALLET_BASE_URL: 'ERROR_FORBIDDEN_WALLET_BASE_URL',\n    ERROR_SECURE_CONTEXT_REQUIRED: 'ERROR_SECURE_CONTEXT_REQUIRED',\n    ERROR_SESSION_CLOSED: 'ERROR_SESSION_CLOSED',\n    ERROR_SESSION_TIMEOUT: 'ERROR_SESSION_TIMEOUT',\n    ERROR_WALLET_NOT_FOUND: 'ERROR_WALLET_NOT_FOUND',\n    ERROR_INVALID_PROTOCOL_VERSION: 'ERROR_INVALID_PROTOCOL_VERSION',\n    ERROR_BROWSER_NOT_SUPPORTED: 'ERROR_BROWSER_NOT_SUPPORTED',\n};\nclass SolanaMobileWalletAdapterError extends Error {\n    constructor(...args) {\n        const [code, message, data] = args;\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.name = 'SolanaMobileWalletAdapterError';\n    }\n}\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaMobileWalletAdapterProtocolErrorCode = {\n    // Keep these in sync with `mobilewalletadapter/common/ProtocolContract.java`.\n    ERROR_AUTHORIZATION_FAILED: -1,\n    ERROR_INVALID_PAYLOADS: -2,\n    ERROR_NOT_SIGNED: -3,\n    ERROR_NOT_SUBMITTED: -4,\n    ERROR_TOO_MANY_PAYLOADS: -5,\n    ERROR_ATTEST_ORIGIN_ANDROID: -100,\n};\nclass SolanaMobileWalletAdapterProtocolError extends Error {\n    constructor(...args) {\n        const [jsonRpcMessageId, code, message, data] = args;\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.jsonRpcMessageId = jsonRpcMessageId;\n        this.name = 'SolanaMobileWalletAdapterProtocolError';\n    }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nfunction encode(input) {\n    return window.btoa(input);\n}\nfunction fromUint8Array$1(byteArray, urlsafe) {\n    const base64 = window.btoa(String.fromCharCode.call(null, ...byteArray));\n    if (urlsafe) {\n        return base64\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_')\n            .replace(/=+$/, '');\n    }\n    else\n        return base64;\n}\nfunction toUint8Array(base64EncodedByteArray) {\n    return new Uint8Array(window\n        .atob(base64EncodedByteArray)\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n}\n\nfunction createHelloReq(ecdhPublicKey, associationKeypairPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const publicKeyBuffer = yield crypto.subtle.exportKey('raw', ecdhPublicKey);\n        const signatureBuffer = yield crypto.subtle.sign({ hash: 'SHA-256', name: 'ECDSA' }, associationKeypairPrivateKey, publicKeyBuffer);\n        const response = new Uint8Array(publicKeyBuffer.byteLength + signatureBuffer.byteLength);\n        response.set(new Uint8Array(publicKeyBuffer), 0);\n        response.set(new Uint8Array(signatureBuffer), publicKeyBuffer.byteLength);\n        return response;\n    });\n}\n\nfunction createSIWSMessage(payload) {\n    return (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_0__.createSignInMessageText)(payload);\n}\nfunction createSIWSMessageBase64Url(payload) {\n    return encode(createSIWSMessage(payload))\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_')\n        .replace(/=+$/, ''); // convert to base64url encoding;\n}\n\n// optional features\nconst SolanaSignTransactions = 'solana:signTransactions';\nconst SolanaCloneAuthorization = 'solana:cloneAuthorization';\nconst SolanaSignInWithSolana = 'solana:signInWithSolana';\n\nfunction fromUint8Array(byteArray) {\n    return (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_1__.getBase58Decoder)().decode(byteArray);\n}\nfunction base64ToBase58(base64EncodedString) {\n    return fromUint8Array(toUint8Array(base64EncodedString));\n}\n\n/**\n * Creates a {@link MobileWallet} proxy that handles backwards compatibility and API to RPC conversion.\n *\n * @param protocolVersion the protocol version in use for this session/request\n * @param protocolRequestHandler callback function that handles sending the RPC request to the wallet endpoint.\n * @returns a {@link MobileWallet} proxy\n */\nfunction createMobileWalletProxy(protocolVersion, protocolRequestHandler) {\n    return new Proxy({}, {\n        get(target, p) {\n            // Wrapping a Proxy in a promise results in the Proxy being asked for a 'then' property so must \n            // return null if 'then' is called on this proxy to let the 'resolve()' call know this is not a promise.\n            // see: https://stackoverflow.com/a/53890904\n            //@ts-ignore\n            if (p === 'then') {\n                return null;\n            }\n            if (target[p] == null) {\n                target[p] = function (inputParams) {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        const { method, params } = handleMobileWalletRequest(p, inputParams, protocolVersion);\n                        const result = yield protocolRequestHandler(method, params);\n                        // if the request tried to sign in but the wallet did not return a sign in result, fallback on message signing\n                        if (method === 'authorize' && params.sign_in_payload && !result.sign_in_result) {\n                            result['sign_in_result'] = yield signInFallback(params.sign_in_payload, result, protocolRequestHandler);\n                        }\n                        return handleMobileWalletResponse(p, result, protocolVersion);\n                    });\n                };\n            }\n            return target[p];\n        },\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n    });\n}\n/**\n * Handles all {@link MobileWallet} API requests and determines the correct MWA RPC method and params to call.\n * This handles backwards compatibility, based on the provided @protocolVersion.\n *\n * @param methodName the name of {@link MobileWallet} method that was called\n * @param methodParams the parameters that were passed to the method\n * @param protocolVersion the protocol version in use for this session/request\n * @returns the RPC request method and params that should be sent to the wallet endpoint\n */\nfunction handleMobileWalletRequest(methodName, methodParams, protocolVersion) {\n    let params = methodParams;\n    let method = methodName\n        .toString()\n        .replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)\n        .toLowerCase();\n    switch (methodName) {\n        case 'authorize': {\n            let { chain } = params;\n            if (protocolVersion === 'legacy') {\n                switch (chain) {\n                    case 'solana:testnet': {\n                        chain = 'testnet';\n                        break;\n                    }\n                    case 'solana:devnet': {\n                        chain = 'devnet';\n                        break;\n                    }\n                    case 'solana:mainnet': {\n                        chain = 'mainnet-beta';\n                        break;\n                    }\n                    default: {\n                        chain = params.cluster;\n                    }\n                }\n                params.cluster = chain;\n            }\n            else {\n                switch (chain) {\n                    case 'testnet':\n                    case 'devnet': {\n                        chain = `solana:${chain}`;\n                        break;\n                    }\n                    case 'mainnet-beta': {\n                        chain = 'solana:mainnet';\n                        break;\n                    }\n                }\n                params.chain = chain;\n            }\n        }\n        case 'reauthorize': {\n            const { auth_token, identity } = params;\n            if (auth_token) {\n                switch (protocolVersion) {\n                    case 'legacy': {\n                        method = 'reauthorize';\n                        params = { auth_token: auth_token, identity: identity };\n                        break;\n                    }\n                    default: {\n                        method = 'authorize';\n                        break;\n                    }\n                }\n            }\n            break;\n        }\n    }\n    return { method, params };\n}\n/**\n * Handles all {@link MobileWallet} API responses and modifies the response for backwards compatibility, if needed\n *\n * @param method the {@link MobileWallet} method that was called\n * @param response the original response that was returned by the method call\n * @param protocolVersion the protocol version in use for this session/request\n * @returns the possibly modified response\n */\nfunction handleMobileWalletResponse(method, response, protocolVersion) {\n    switch (method) {\n        case 'getCapabilities': {\n            const capabilities = response;\n            switch (protocolVersion) {\n                case 'legacy': {\n                    const features = [SolanaSignTransactions];\n                    if (capabilities.supports_clone_authorization === true) {\n                        features.push(SolanaCloneAuthorization);\n                    }\n                    return Object.assign(Object.assign({}, capabilities), { features: features });\n                }\n                case 'v1': {\n                    return Object.assign(Object.assign({}, capabilities), { supports_sign_and_send_transactions: true, supports_clone_authorization: capabilities.features.includes(SolanaCloneAuthorization) });\n                }\n            }\n        }\n    }\n    return response;\n}\nfunction signInFallback(signInPayload, authorizationResult, protocolRequestHandler) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        const domain = (_a = signInPayload.domain) !== null && _a !== void 0 ? _a : window.location.host;\n        const address = authorizationResult.accounts[0].address;\n        const siwsMessage = createSIWSMessageBase64Url(Object.assign(Object.assign({}, signInPayload), { domain, address: base64ToBase58(address) }));\n        const signMessageResult = yield protocolRequestHandler('sign_messages', {\n            addresses: [address],\n            payloads: [siwsMessage]\n        });\n        const signedPayload = toUint8Array(signMessageResult.signed_payloads[0]);\n        const signedMessage = fromUint8Array$1(signedPayload.slice(0, signedPayload.length - 64));\n        const signature = fromUint8Array$1(signedPayload.slice(signedPayload.length - 64));\n        const signInResult = {\n            address: address,\n            // Workaround: some wallets have been observed to only reply with the message signature.\n            // This is non-compliant with the spec, but in the interest of maximizing compatibility,\n            // detect this case and reuse the original message.\n            signed_message: signedMessage.length == 0 ? siwsMessage : signedMessage,\n            signature\n        };\n        return signInResult;\n    });\n}\n\nconst SEQUENCE_NUMBER_BYTES = 4;\nfunction createSequenceNumberVector(sequenceNumber) {\n    if (sequenceNumber >= 4294967296) {\n        throw new Error('Outbound sequence number overflow. The maximum sequence number is 32-bytes.');\n    }\n    const byteArray = new ArrayBuffer(SEQUENCE_NUMBER_BYTES);\n    const view = new DataView(byteArray);\n    view.setUint32(0, sequenceNumber, /* littleEndian */ false);\n    return new Uint8Array(byteArray);\n}\n\nconst INITIALIZATION_VECTOR_BYTES = 12;\nconst ENCODED_PUBLIC_KEY_LENGTH_BYTES = 65;\nfunction encryptMessage(plaintext, sequenceNumber, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const sequenceNumberVector = createSequenceNumberVector(sequenceNumber);\n        const initializationVector = new Uint8Array(INITIALIZATION_VECTOR_BYTES);\n        crypto.getRandomValues(initializationVector);\n        const ciphertext = yield crypto.subtle.encrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, new TextEncoder().encode(plaintext));\n        const response = new Uint8Array(sequenceNumberVector.byteLength + initializationVector.byteLength + ciphertext.byteLength);\n        response.set(new Uint8Array(sequenceNumberVector), 0);\n        response.set(new Uint8Array(initializationVector), sequenceNumberVector.byteLength);\n        response.set(new Uint8Array(ciphertext), sequenceNumberVector.byteLength + initializationVector.byteLength);\n        return response;\n    });\n}\nfunction decryptMessage(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const sequenceNumberVector = message.slice(0, SEQUENCE_NUMBER_BYTES);\n        const initializationVector = message.slice(SEQUENCE_NUMBER_BYTES, SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);\n        const ciphertext = message.slice(SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);\n        const plaintextBuffer = yield crypto.subtle.decrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, ciphertext);\n        const plaintext = getUtf8Decoder().decode(plaintextBuffer);\n        return plaintext;\n    });\n}\nfunction getAlgorithmParams(sequenceNumber, initializationVector) {\n    return {\n        additionalData: sequenceNumber,\n        iv: initializationVector,\n        name: 'AES-GCM',\n        tagLength: 128, // 16 byte tag => 128 bits\n    };\n}\nlet _utf8Decoder;\nfunction getUtf8Decoder() {\n    if (_utf8Decoder === undefined) {\n        _utf8Decoder = new TextDecoder('utf-8');\n    }\n    return _utf8Decoder;\n}\n\nfunction generateAssociationKeypair() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield crypto.subtle.generateKey({\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n        }, false /* extractable */, ['sign'] /* keyUsages */);\n    });\n}\n\nfunction generateECDHKeypair() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield crypto.subtle.generateKey({\n            name: 'ECDH',\n            namedCurve: 'P-256',\n        }, false /* extractable */, ['deriveKey', 'deriveBits'] /* keyUsages */);\n    });\n}\n\n// https://stackoverflow.com/a/9458996/802047\nfunction arrayBufferToBase64String(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    const len = bytes.byteLength;\n    for (let ii = 0; ii < len; ii++) {\n        binary += String.fromCharCode(bytes[ii]);\n    }\n    return window.btoa(binary);\n}\n\nfunction getRandomAssociationPort() {\n    return assertAssociationPort(49152 + Math.floor(Math.random() * (65535 - 49152 + 1)));\n}\nfunction assertAssociationPort(port) {\n    if (port < 49152 || port > 65535) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE, `Association port number must be between 49152 and 65535. ${port} given.`, { port });\n    }\n    return port;\n}\n\nfunction getStringWithURLUnsafeCharactersReplaced(unsafeBase64EncodedString) {\n    return unsafeBase64EncodedString.replace(/[/+=]/g, (m) => ({\n        '/': '_',\n        '+': '-',\n        '=': '.',\n    }[m]));\n}\n\nconst INTENT_NAME = 'solana-wallet';\nfunction getPathParts(pathString) {\n    return (pathString\n        // Strip leading and trailing slashes\n        .replace(/(^\\/+|\\/+$)/g, '')\n        // Return an array of directories\n        .split('/'));\n}\nfunction getIntentURL(methodPathname, intentUrlBase) {\n    let baseUrl = null;\n    if (intentUrlBase) {\n        try {\n            baseUrl = new URL(intentUrlBase);\n        }\n        catch (_a) { } // eslint-disable-line no-empty\n        if ((baseUrl === null || baseUrl === void 0 ? void 0 : baseUrl.protocol) !== 'https:') {\n            throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Base URLs supplied by wallets must be valid `https` URLs');\n        }\n    }\n    baseUrl || (baseUrl = new URL(`${INTENT_NAME}:/`));\n    const pathname = methodPathname.startsWith('/')\n        ? // Method is an absolute path. Replace it wholesale.\n            methodPathname\n        : // Method is a relative path. Merge it with the existing one.\n            [...getPathParts(baseUrl.pathname), ...getPathParts(methodPathname)].join('/');\n    return new URL(pathname, baseUrl);\n}\nfunction getAssociateAndroidIntentURL(associationPublicKey, putativePort, associationURLBase, protocolVersions = ['v1']) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const associationPort = assertAssociationPort(putativePort);\n        const exportedKey = yield crypto.subtle.exportKey('raw', associationPublicKey);\n        const encodedKey = arrayBufferToBase64String(exportedKey);\n        const url = getIntentURL('v1/associate/local', associationURLBase);\n        url.searchParams.set('association', getStringWithURLUnsafeCharactersReplaced(encodedKey));\n        url.searchParams.set('port', `${associationPort}`);\n        protocolVersions.forEach((version) => {\n            url.searchParams.set('v', version);\n        });\n        return url;\n    });\n}\nfunction getRemoteAssociateAndroidIntentURL(associationPublicKey, hostAuthority, reflectorId, associationURLBase, protocolVersions = ['v1']) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const exportedKey = yield crypto.subtle.exportKey('raw', associationPublicKey);\n        const encodedKey = arrayBufferToBase64String(exportedKey);\n        const url = getIntentURL('v1/associate/remote', associationURLBase);\n        url.searchParams.set('association', getStringWithURLUnsafeCharactersReplaced(encodedKey));\n        url.searchParams.set('reflector', `${hostAuthority}`);\n        url.searchParams.set('id', `${fromUint8Array$1(reflectorId, true)}`);\n        protocolVersions.forEach((version) => {\n            url.searchParams.set('v', version);\n        });\n        return url;\n    });\n}\n\nfunction encryptJsonRpcMessage(jsonRpcMessage, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const plaintext = JSON.stringify(jsonRpcMessage);\n        const sequenceNumber = jsonRpcMessage.id;\n        return encryptMessage(plaintext, sequenceNumber, sharedSecret);\n    });\n}\nfunction decryptJsonRpcMessage(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const plaintext = yield decryptMessage(message, sharedSecret);\n        const jsonRpcMessage = JSON.parse(plaintext);\n        if (Object.hasOwnProperty.call(jsonRpcMessage, 'error')) {\n            throw new SolanaMobileWalletAdapterProtocolError(jsonRpcMessage.id, jsonRpcMessage.error.code, jsonRpcMessage.error.message);\n        }\n        return jsonRpcMessage;\n    });\n}\n\nfunction parseHelloRsp(payloadBuffer, // The X9.62-encoded wallet endpoint ephemeral ECDH public keypoint.\nassociationPublicKey, ecdhPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [associationPublicKeyBuffer, walletPublicKey] = yield Promise.all([\n            crypto.subtle.exportKey('raw', associationPublicKey),\n            crypto.subtle.importKey('raw', payloadBuffer.slice(0, ENCODED_PUBLIC_KEY_LENGTH_BYTES), { name: 'ECDH', namedCurve: 'P-256' }, false /* extractable */, [] /* keyUsages */),\n        ]);\n        const sharedSecret = yield crypto.subtle.deriveBits({ name: 'ECDH', public: walletPublicKey }, ecdhPrivateKey, 256);\n        const ecdhSecretKey = yield crypto.subtle.importKey('raw', sharedSecret, 'HKDF', false /* extractable */, ['deriveKey'] /* keyUsages */);\n        const aesKeyMaterialVal = yield crypto.subtle.deriveKey({\n            name: 'HKDF',\n            hash: 'SHA-256',\n            salt: new Uint8Array(associationPublicKeyBuffer),\n            info: new Uint8Array(),\n        }, ecdhSecretKey, { name: 'AES-GCM', length: 128 }, false /* extractable */, ['encrypt', 'decrypt']);\n        return aesKeyMaterialVal;\n    });\n}\n\nfunction parseSessionProps(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const plaintext = yield decryptMessage(message, sharedSecret);\n        const jsonProperties = JSON.parse(plaintext);\n        let protocolVersion = 'legacy';\n        if (Object.hasOwnProperty.call(jsonProperties, 'v')) {\n            switch (jsonProperties.v) {\n                case 1:\n                case '1':\n                case 'v1':\n                    protocolVersion = 'v1';\n                    break;\n                case 'legacy':\n                    protocolVersion = 'legacy';\n                    break;\n                default:\n                    throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_INVALID_PROTOCOL_VERSION, `Unknown/unsupported protocol version: ${jsonProperties.v}`);\n            }\n        }\n        return ({\n            protocol_version: protocolVersion\n        });\n    });\n}\n\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst Browser = {\n    Firefox: 0,\n    Other: 1,\n};\nfunction assertUnreachable(x) {\n    return x;\n}\nfunction getBrowser() {\n    return navigator.userAgent.indexOf('Firefox/') !== -1 ? Browser.Firefox : Browser.Other;\n}\nfunction getDetectionPromise() {\n    // Chrome and others silently fail if a custom protocol is not supported.\n    // For these, we wait to see if the browser is navigated away from in\n    // a reasonable amount of time (ie. the native wallet opened).\n    return new Promise((resolve, reject) => {\n        function cleanup() {\n            clearTimeout(timeoutId);\n            window.removeEventListener('blur', handleBlur);\n        }\n        function handleBlur() {\n            cleanup();\n            resolve();\n        }\n        window.addEventListener('blur', handleBlur);\n        const timeoutId = setTimeout(() => {\n            cleanup();\n            reject();\n        }, 3000);\n    });\n}\nlet _frame = null;\nfunction launchUrlThroughHiddenFrame(url) {\n    if (_frame == null) {\n        _frame = document.createElement('iframe');\n        _frame.style.display = 'none';\n        document.body.appendChild(_frame);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    _frame.contentWindow.location.href = url.toString();\n}\nfunction launchAssociation(associationUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (associationUrl.protocol === 'https:') {\n            // The association URL is an Android 'App Link' or iOS 'Universal Link'.\n            // These are regular web URLs that are designed to launch an app if it\n            // is installed or load the actual target webpage if not.\n            window.location.assign(associationUrl);\n        }\n        else {\n            // The association URL has a custom protocol (eg. `solana-wallet:`)\n            try {\n                const browser = getBrowser();\n                switch (browser) {\n                    case Browser.Firefox:\n                        // If a custom protocol is not supported in Firefox, it throws.\n                        launchUrlThroughHiddenFrame(associationUrl);\n                        // If we reached this line, it's supported.\n                        break;\n                    case Browser.Other: {\n                        const detectionPromise = getDetectionPromise();\n                        window.location.assign(associationUrl);\n                        yield detectionPromise;\n                        break;\n                    }\n                    default:\n                        assertUnreachable(browser);\n                }\n            }\n            catch (e) {\n                throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_WALLET_NOT_FOUND, 'Found no installed wallet that supports the mobile wallet protocol.');\n            }\n        }\n    });\n}\nfunction startSession(associationPublicKey, associationURLBase) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const randomAssociationPort = getRandomAssociationPort();\n        const associationUrl = yield getAssociateAndroidIntentURL(associationPublicKey, randomAssociationPort, associationURLBase);\n        yield launchAssociation(associationUrl);\n        return randomAssociationPort;\n    });\n}\n\nconst WEBSOCKET_CONNECTION_CONFIG = {\n    /**\n     * 300 milliseconds is a generally accepted threshold for what someone\n     * would consider an acceptable response time for a user interface\n     * after having performed a low-attention tapping task. We set the initial\n     * interval at which we wait for the wallet to set up the websocket at\n     * half this, as per the Nyquist frequency, with a progressive backoff\n     * sequence from there. The total wait time is 30s, which allows for the\n     * user to be presented with a disambiguation dialog, select a wallet, and\n     * for the wallet app to subsequently start.\n     */\n    retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1000],\n    timeoutMs: 30000,\n};\nconst WEBSOCKET_PROTOCOL_BINARY = 'com.solana.mobilewalletadapter.v1';\nconst WEBSOCKET_PROTOCOL_BASE64 = 'com.solana.mobilewalletadapter.v1.base64';\nfunction assertSecureContext() {\n    if (typeof window === 'undefined' || window.isSecureContext !== true) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SECURE_CONTEXT_REQUIRED, 'The mobile wallet adapter protocol must be used in a secure context (`https`).');\n    }\n}\nfunction assertSecureEndpointSpecificURI(walletUriBase) {\n    let url;\n    try {\n        url = new URL(walletUriBase);\n    }\n    catch (_a) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Invalid base URL supplied by wallet');\n    }\n    if (url.protocol !== 'https:') {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Base URLs supplied by wallets must be valid `https` URLs');\n    }\n}\nfunction getSequenceNumberFromByteArray(byteArray) {\n    const view = new DataView(byteArray);\n    return view.getUint32(0, /* littleEndian */ false);\n}\nfunction decodeVarLong(byteArray) {\n    var bytes = new Uint8Array(byteArray), l = byteArray.byteLength, limit = 10, value = 0, offset = 0, b;\n    do {\n        if (offset >= l || offset > limit)\n            throw new RangeError('Failed to decode varint');\n        b = bytes[offset++];\n        value |= (b & 0x7F) << (7 * offset);\n    } while (b >= 0x80);\n    return { value, offset };\n}\nfunction getReflectorIdFromByteArray(byteArray) {\n    let { value: length, offset } = decodeVarLong(byteArray);\n    return new Uint8Array(byteArray.slice(offset, offset + length));\n}\nfunction transact(callback, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assertSecureContext();\n        const associationKeypair = yield generateAssociationKeypair();\n        const sessionPort = yield startSession(associationKeypair.publicKey, config === null || config === void 0 ? void 0 : config.baseUri);\n        const websocketURL = `ws://localhost:${sessionPort}/solana-wallet`;\n        let connectionStartTime;\n        const getNextRetryDelayMs = (() => {\n            const schedule = [...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs];\n            return () => (schedule.length > 1 ? schedule.shift() : schedule[0]);\n        })();\n        let nextJsonRpcMessageId = 1;\n        let lastKnownInboundSequenceNumber = 0;\n        let state = { __type: 'disconnected' };\n        return new Promise((resolve, reject) => {\n            let socket;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const jsonRpcResponsePromises = {};\n            const handleOpen = () => __awaiter(this, void 0, void 0, function* () {\n                if (state.__type !== 'connecting') {\n                    console.warn('Expected adapter state to be `connecting` at the moment the websocket opens. ' +\n                        `Got \\`${state.__type}\\`.`);\n                    return;\n                }\n                socket.removeEventListener('open', handleOpen);\n                // previous versions of this library and walletlib incorrectly implemented the MWA session \n                // establishment protocol for local connections. The dapp is supposed to wait for the \n                // APP_PING message before sending the HELLO_REQ. Instead, the dapp was sending the HELLO_REQ \n                // immediately upon connection to the websocket server regardless of wether or not an \n                // APP_PING was sent by the wallet/websocket server. We must continue to support this behavior \n                // in case the user is using a wallet that has not updated their walletlib implementation. \n                const { associationKeypair } = state;\n                const ecdhKeypair = yield generateECDHKeypair();\n                socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));\n                state = {\n                    __type: 'hello_req_sent',\n                    associationPublicKey: associationKeypair.publicKey,\n                    ecdhPrivateKey: ecdhKeypair.privateKey,\n                };\n            });\n            const handleClose = (evt) => {\n                if (evt.wasClean) {\n                    state = { __type: 'disconnected' };\n                }\n                else {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, { closeEvent: evt }));\n                }\n                disposeSocket();\n            };\n            const handleError = (_evt) => __awaiter(this, void 0, void 0, function* () {\n                disposeSocket();\n                if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket at ${websocketURL}.`));\n                }\n                else {\n                    yield new Promise((resolve) => {\n                        const retryDelayMs = getNextRetryDelayMs();\n                        retryWaitTimeoutId = window.setTimeout(resolve, retryDelayMs);\n                    });\n                    attemptSocketConnection();\n                }\n            });\n            const handleMessage = (evt) => __awaiter(this, void 0, void 0, function* () {\n                const responseBuffer = yield evt.data.arrayBuffer();\n                switch (state.__type) {\n                    case 'connecting':\n                        if (responseBuffer.byteLength !== 0) {\n                            throw new Error('Encountered unexpected message while connecting');\n                        }\n                        const ecdhKeypair = yield generateECDHKeypair();\n                        socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));\n                        state = {\n                            __type: 'hello_req_sent',\n                            associationPublicKey: associationKeypair.publicKey,\n                            ecdhPrivateKey: ecdhKeypair.privateKey,\n                        };\n                        break;\n                    case 'connected':\n                        try {\n                            const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                            const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                            if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {\n                                throw new Error('Encrypted message has invalid sequence number');\n                            }\n                            lastKnownInboundSequenceNumber = sequenceNumber;\n                            const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);\n                            const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];\n                            delete jsonRpcResponsePromises[jsonRpcMessage.id];\n                            responsePromise.resolve(jsonRpcMessage.result);\n                        }\n                        catch (e) {\n                            if (e instanceof SolanaMobileWalletAdapterProtocolError) {\n                                const responsePromise = jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                delete jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                responsePromise.reject(e);\n                            }\n                            else {\n                                throw e;\n                            }\n                        }\n                        break;\n                    case 'hello_req_sent': {\n                        // if we receive an APP_PING message (empty message), resend the HELLO_REQ (see above)\n                        if (responseBuffer.byteLength === 0) {\n                            const ecdhKeypair = yield generateECDHKeypair();\n                            socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));\n                            state = {\n                                __type: 'hello_req_sent',\n                                associationPublicKey: associationKeypair.publicKey,\n                                ecdhPrivateKey: ecdhKeypair.privateKey,\n                            };\n                            break;\n                        }\n                        const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);\n                        const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);\n                        const sessionProperties = sessionPropertiesBuffer.byteLength !== 0\n                            ? yield (() => __awaiter(this, void 0, void 0, function* () {\n                                const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {\n                                    throw new Error('Encrypted message has invalid sequence number');\n                                }\n                                lastKnownInboundSequenceNumber = sequenceNumber;\n                                return parseSessionProps(sessionPropertiesBuffer, sharedSecret);\n                            }))() : { protocol_version: 'legacy' };\n                        state = { __type: 'connected', sharedSecret, sessionProperties };\n                        const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params) => __awaiter(this, void 0, void 0, function* () {\n                            const id = nextJsonRpcMessageId++;\n                            socket.send(yield encryptJsonRpcMessage({\n                                id,\n                                jsonrpc: '2.0',\n                                method,\n                                params: params !== null && params !== void 0 ? params : {},\n                            }, sharedSecret));\n                            return new Promise((resolve, reject) => {\n                                jsonRpcResponsePromises[id] = {\n                                    resolve(result) {\n                                        switch (method) {\n                                            case 'authorize':\n                                            case 'reauthorize': {\n                                                const { wallet_uri_base } = result;\n                                                if (wallet_uri_base != null) {\n                                                    try {\n                                                        assertSecureEndpointSpecificURI(wallet_uri_base);\n                                                    }\n                                                    catch (e) {\n                                                        reject(e);\n                                                        return;\n                                                    }\n                                                }\n                                                break;\n                                            }\n                                        }\n                                        resolve(result);\n                                    },\n                                    reject,\n                                };\n                            });\n                        }));\n                        try {\n                            resolve(yield callback(wallet));\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                        finally {\n                            disposeSocket();\n                            socket.close();\n                        }\n                        break;\n                    }\n                }\n            });\n            let disposeSocket;\n            let retryWaitTimeoutId;\n            const attemptSocketConnection = () => {\n                if (disposeSocket) {\n                    disposeSocket();\n                }\n                state = { __type: 'connecting', associationKeypair };\n                if (connectionStartTime === undefined) {\n                    connectionStartTime = Date.now();\n                }\n                socket = new WebSocket(websocketURL, [WEBSOCKET_PROTOCOL_BINARY]);\n                socket.addEventListener('open', handleOpen);\n                socket.addEventListener('close', handleClose);\n                socket.addEventListener('error', handleError);\n                socket.addEventListener('message', handleMessage);\n                disposeSocket = () => {\n                    window.clearTimeout(retryWaitTimeoutId);\n                    socket.removeEventListener('open', handleOpen);\n                    socket.removeEventListener('close', handleClose);\n                    socket.removeEventListener('error', handleError);\n                    socket.removeEventListener('message', handleMessage);\n                };\n            };\n            attemptSocketConnection();\n        });\n    });\n}\nfunction startRemoteScenario(config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assertSecureContext();\n        const associationKeypair = yield generateAssociationKeypair();\n        const websocketURL = `wss://${config === null || config === void 0 ? void 0 : config.remoteHostAuthority}/reflect`;\n        let connectionStartTime;\n        const getNextRetryDelayMs = (() => {\n            const schedule = [...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs];\n            return () => (schedule.length > 1 ? schedule.shift() : schedule[0]);\n        })();\n        let nextJsonRpcMessageId = 1;\n        let lastKnownInboundSequenceNumber = 0;\n        let encoding;\n        let state = { __type: 'disconnected' };\n        let socket;\n        let disposeSocket;\n        let decodeBytes = (evt) => __awaiter(this, void 0, void 0, function* () {\n            if (encoding == 'base64') { // base64 encoding\n                const message = yield evt.data;\n                return toUint8Array(message).buffer;\n            }\n            else {\n                return yield evt.data.arrayBuffer();\n            }\n        });\n        // Reflector Connection Phase\n        // here we connect to the reflector and wait for the REFLECTOR_ID message \n        // so we build the association URL and return that back to the caller\n        const associationUrl = yield new Promise((resolve, reject) => {\n            const handleOpen = () => __awaiter(this, void 0, void 0, function* () {\n                if (state.__type !== 'connecting') {\n                    console.warn('Expected adapter state to be `connecting` at the moment the websocket opens. ' +\n                        `Got \\`${state.__type}\\`.`);\n                    return;\n                }\n                if (socket.protocol.includes(WEBSOCKET_PROTOCOL_BASE64)) {\n                    encoding = 'base64';\n                }\n                else {\n                    encoding = 'binary';\n                }\n                socket.removeEventListener('open', handleOpen);\n            });\n            const handleClose = (evt) => {\n                if (evt.wasClean) {\n                    state = { __type: 'disconnected' };\n                }\n                else {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, { closeEvent: evt }));\n                }\n                disposeSocket();\n            };\n            const handleError = (_evt) => __awaiter(this, void 0, void 0, function* () {\n                disposeSocket();\n                if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket at ${websocketURL}.`));\n                }\n                else {\n                    yield new Promise((resolve) => {\n                        const retryDelayMs = getNextRetryDelayMs();\n                        retryWaitTimeoutId = window.setTimeout(resolve, retryDelayMs);\n                    });\n                    attemptSocketConnection();\n                }\n            });\n            const handleReflectorIdMessage = (evt) => __awaiter(this, void 0, void 0, function* () {\n                const responseBuffer = yield decodeBytes(evt);\n                if (state.__type === 'connecting') {\n                    if (responseBuffer.byteLength == 0) {\n                        throw new Error('Encountered unexpected message while connecting');\n                    }\n                    const reflectorId = getReflectorIdFromByteArray(responseBuffer);\n                    state = {\n                        __type: 'reflector_id_received',\n                        reflectorId: reflectorId\n                    };\n                    const associationUrl = yield getRemoteAssociateAndroidIntentURL(associationKeypair.publicKey, config.remoteHostAuthority, reflectorId, config === null || config === void 0 ? void 0 : config.baseUri);\n                    socket.removeEventListener('message', handleReflectorIdMessage);\n                    resolve(associationUrl);\n                }\n            });\n            let retryWaitTimeoutId;\n            const attemptSocketConnection = () => {\n                if (disposeSocket) {\n                    disposeSocket();\n                }\n                state = { __type: 'connecting', associationKeypair };\n                if (connectionStartTime === undefined) {\n                    connectionStartTime = Date.now();\n                }\n                socket = new WebSocket(websocketURL, [WEBSOCKET_PROTOCOL_BINARY, WEBSOCKET_PROTOCOL_BASE64]);\n                socket.addEventListener('open', handleOpen);\n                socket.addEventListener('close', handleClose);\n                socket.addEventListener('error', handleError);\n                socket.addEventListener('message', handleReflectorIdMessage);\n                disposeSocket = () => {\n                    window.clearTimeout(retryWaitTimeoutId);\n                    socket.removeEventListener('open', handleOpen);\n                    socket.removeEventListener('close', handleClose);\n                    socket.removeEventListener('error', handleError);\n                    socket.removeEventListener('message', handleReflectorIdMessage);\n                };\n            };\n            attemptSocketConnection();\n        });\n        // Wallet Connection Phase\n        // here we return the association URL (containing the reflector ID) to the caller + \n        // a promise that will resolve the MobileWallet object once the wallet connects.\n        let sessionEstablished = false;\n        let handleClose;\n        return { associationUrl, close: () => {\n                socket.close();\n                handleClose();\n            }, wallet: new Promise((resolve, reject) => {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const jsonRpcResponsePromises = {};\n                const handleMessage = (evt) => __awaiter(this, void 0, void 0, function* () {\n                    const responseBuffer = yield decodeBytes(evt);\n                    switch (state.__type) {\n                        case 'reflector_id_received':\n                            if (responseBuffer.byteLength !== 0) {\n                                throw new Error('Encountered unexpected message while awaiting reflection');\n                            }\n                            const ecdhKeypair = yield generateECDHKeypair();\n                            const binaryMsg = yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey);\n                            if (encoding == 'base64') {\n                                socket.send(fromUint8Array$1(binaryMsg));\n                            }\n                            else {\n                                socket.send(binaryMsg);\n                            }\n                            state = {\n                                __type: 'hello_req_sent',\n                                associationPublicKey: associationKeypair.publicKey,\n                                ecdhPrivateKey: ecdhKeypair.privateKey,\n                            };\n                            break;\n                        case 'connected':\n                            try {\n                                const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {\n                                    throw new Error('Encrypted message has invalid sequence number');\n                                }\n                                lastKnownInboundSequenceNumber = sequenceNumber;\n                                const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);\n                                const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];\n                                delete jsonRpcResponsePromises[jsonRpcMessage.id];\n                                responsePromise.resolve(jsonRpcMessage.result);\n                            }\n                            catch (e) {\n                                if (e instanceof SolanaMobileWalletAdapterProtocolError) {\n                                    const responsePromise = jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                    delete jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                    responsePromise.reject(e);\n                                }\n                                else {\n                                    throw e;\n                                }\n                            }\n                            break;\n                        case 'hello_req_sent': {\n                            const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);\n                            const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);\n                            const sessionProperties = sessionPropertiesBuffer.byteLength !== 0\n                                ? yield (() => __awaiter(this, void 0, void 0, function* () {\n                                    const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                    const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                    if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {\n                                        throw new Error('Encrypted message has invalid sequence number');\n                                    }\n                                    lastKnownInboundSequenceNumber = sequenceNumber;\n                                    return parseSessionProps(sessionPropertiesBuffer, sharedSecret);\n                                }))() : { protocol_version: 'legacy' };\n                            state = { __type: 'connected', sharedSecret, sessionProperties };\n                            const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params) => __awaiter(this, void 0, void 0, function* () {\n                                const id = nextJsonRpcMessageId++;\n                                const binaryMsg = yield encryptJsonRpcMessage({\n                                    id,\n                                    jsonrpc: '2.0',\n                                    method,\n                                    params: params !== null && params !== void 0 ? params : {},\n                                }, sharedSecret);\n                                if (encoding == 'base64') {\n                                    socket.send(fromUint8Array$1(binaryMsg));\n                                }\n                                else {\n                                    socket.send(binaryMsg);\n                                }\n                                return new Promise((resolve, reject) => {\n                                    jsonRpcResponsePromises[id] = {\n                                        resolve(result) {\n                                            switch (method) {\n                                                case 'authorize':\n                                                case 'reauthorize': {\n                                                    const { wallet_uri_base } = result;\n                                                    if (wallet_uri_base != null) {\n                                                        try {\n                                                            assertSecureEndpointSpecificURI(wallet_uri_base);\n                                                        }\n                                                        catch (e) {\n                                                            reject(e);\n                                                            return;\n                                                        }\n                                                    }\n                                                    break;\n                                                }\n                                            }\n                                            resolve(result);\n                                        },\n                                        reject,\n                                    };\n                                });\n                            }));\n                            sessionEstablished = true;\n                            try {\n                                resolve(wallet);\n                            }\n                            catch (e) {\n                                reject(e);\n                            }\n                            break;\n                        }\n                    }\n                });\n                socket.addEventListener('message', handleMessage);\n                handleClose = () => {\n                    socket.removeEventListener('message', handleMessage);\n                    disposeSocket();\n                    if (!sessionEstablished) {\n                        reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session was closed before connection.`, { closeEvent: new CloseEvent('socket was closed before connection') }));\n                    }\n                };\n            }) };\n    });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LXN0YW5kYXJkLW1vYmlsZS9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBdUU7QUFDYjs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdDQUFnQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcscUZBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHdFQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMscUJBQXFCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxNQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsbUJBQW1CLG9CQUFvQjtBQUNoRztBQUNBO0FBQ0EseURBQXlELG1CQUFtQixtSUFBbUk7QUFDL007QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixvQkFBb0IsMENBQTBDO0FBQ25KO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUxBQXFMLE1BQU0sV0FBVyxNQUFNO0FBQzVNO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Qsc0NBQXNDLG9DQUFvQztBQUMxRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csbUNBQW1DO0FBQ3pJO0FBQ0EsOERBQThELHVDQUF1QztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFtQiw4QkFBOEI7QUFDMUQ7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5S0FBeUssaUJBQWlCO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixhQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsbUtBQW1LLFNBQVMsSUFBSSxXQUFXLE9BQU8saUJBQWlCO0FBQ25OO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdLQUF3SyxhQUFhO0FBQ3JMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyRUFBMkU7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsbUtBQW1LLFNBQVMsSUFBSSxXQUFXLE9BQU8saUJBQWlCO0FBQ25OO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdLQUF3SyxhQUFhO0FBQ3JMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGtCQUFrQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUxBQWlMLG1FQUFtRTtBQUNwUDtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFMlEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZW4tZm9ydHVuZS1jb29raWUvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LXN0YW5kYXJkLW1vYmlsZS9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sL2xpYi9lc20vaW5kZXguanM/YTIwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVTaWduSW5NZXNzYWdlVGV4dCB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwnO1xuaW1wb3J0IHsgZ2V0QmFzZTU4RGVjb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLXN0cmluZ3MnO1xuXG4vLyBUeXBlc2NyaXB0IGBlbnVtc2AgdGh3YXJ0IHRyZWUtc2hha2luZy4gU2VlIGh0dHBzOi8vYmFyZ3N0ZW4ub3JnL2pzdHMvZW51bXMvXG5jb25zdCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlID0ge1xuICAgIEVSUk9SX0FTU09DSUFUSU9OX1BPUlRfT1VUX09GX1JBTkdFOiAnRVJST1JfQVNTT0NJQVRJT05fUE9SVF9PVVRfT0ZfUkFOR0UnLFxuICAgIEVSUk9SX1JFRkxFQ1RPUl9JRF9PVVRfT0ZfUkFOR0U6ICdFUlJPUl9SRUZMRUNUT1JfSURfT1VUX09GX1JBTkdFJyxcbiAgICBFUlJPUl9GT1JCSURERU5fV0FMTEVUX0JBU0VfVVJMOiAnRVJST1JfRk9SQklEREVOX1dBTExFVF9CQVNFX1VSTCcsXG4gICAgRVJST1JfU0VDVVJFX0NPTlRFWFRfUkVRVUlSRUQ6ICdFUlJPUl9TRUNVUkVfQ09OVEVYVF9SRVFVSVJFRCcsXG4gICAgRVJST1JfU0VTU0lPTl9DTE9TRUQ6ICdFUlJPUl9TRVNTSU9OX0NMT1NFRCcsXG4gICAgRVJST1JfU0VTU0lPTl9USU1FT1VUOiAnRVJST1JfU0VTU0lPTl9USU1FT1VUJyxcbiAgICBFUlJPUl9XQUxMRVRfTk9UX0ZPVU5EOiAnRVJST1JfV0FMTEVUX05PVF9GT1VORCcsXG4gICAgRVJST1JfSU5WQUxJRF9QUk9UT0NPTF9WRVJTSU9OOiAnRVJST1JfSU5WQUxJRF9QUk9UT0NPTF9WRVJTSU9OJyxcbiAgICBFUlJPUl9CUk9XU0VSX05PVF9TVVBQT1JURUQ6ICdFUlJPUl9CUk9XU0VSX05PVF9TVVBQT1JURUQnLFxufTtcbmNsYXNzIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IFtjb2RlLCBtZXNzYWdlLCBkYXRhXSA9IGFyZ3M7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yJztcbiAgICB9XG59XG4vLyBUeXBlc2NyaXB0IGBlbnVtc2AgdGh3YXJ0IHRyZWUtc2hha2luZy4gU2VlIGh0dHBzOi8vYmFyZ3N0ZW4ub3JnL2pzdHMvZW51bXMvXG5jb25zdCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvckNvZGUgPSB7XG4gICAgLy8gS2VlcCB0aGVzZSBpbiBzeW5jIHdpdGggYG1vYmlsZXdhbGxldGFkYXB0ZXIvY29tbW9uL1Byb3RvY29sQ29udHJhY3QuamF2YWAuXG4gICAgRVJST1JfQVVUSE9SSVpBVElPTl9GQUlMRUQ6IC0xLFxuICAgIEVSUk9SX0lOVkFMSURfUEFZTE9BRFM6IC0yLFxuICAgIEVSUk9SX05PVF9TSUdORUQ6IC0zLFxuICAgIEVSUk9SX05PVF9TVUJNSVRURUQ6IC00LFxuICAgIEVSUk9SX1RPT19NQU5ZX1BBWUxPQURTOiAtNSxcbiAgICBFUlJPUl9BVFRFU1RfT1JJR0lOX0FORFJPSUQ6IC0xMDAsXG59O1xuY2xhc3MgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBbanNvblJwY01lc3NhZ2VJZCwgY29kZSwgbWVzc2FnZSwgZGF0YV0gPSBhcmdzO1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5qc29uUnBjTWVzc2FnZUlkID0ganNvblJwY01lc3NhZ2VJZDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1NvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yJztcbiAgICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgICByZXR1cm4gd2luZG93LmJ0b2EoaW5wdXQpO1xufVxuZnVuY3Rpb24gZnJvbVVpbnQ4QXJyYXkkMShieXRlQXJyYXksIHVybHNhZmUpIHtcbiAgICBjb25zdCBiYXNlNjQgPSB3aW5kb3cuYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlLmNhbGwobnVsbCwgLi4uYnl0ZUFycmF5KSk7XG4gICAgaWYgKHVybHNhZmUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U2NFxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcKy9nLCAnLScpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwvL2csICdfJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC89KyQvLCAnJyk7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGJhc2U2NDtcbn1cbmZ1bmN0aW9uIHRvVWludDhBcnJheShiYXNlNjRFbmNvZGVkQnl0ZUFycmF5KSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHdpbmRvd1xuICAgICAgICAuYXRvYihiYXNlNjRFbmNvZGVkQnl0ZUFycmF5KVxuICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgIC5tYXAoKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIZWxsb1JlcShlY2RoUHVibGljS2V5LCBhc3NvY2lhdGlvbktleXBhaXJQcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5QnVmZmVyID0geWllbGQgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ3JhdycsIGVjZGhQdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmVCdWZmZXIgPSB5aWVsZCBjcnlwdG8uc3VidGxlLnNpZ24oeyBoYXNoOiAnU0hBLTI1NicsIG5hbWU6ICdFQ0RTQScgfSwgYXNzb2NpYXRpb25LZXlwYWlyUHJpdmF0ZUtleSwgcHVibGljS2V5QnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgVWludDhBcnJheShwdWJsaWNLZXlCdWZmZXIuYnl0ZUxlbmd0aCArIHNpZ25hdHVyZUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmVzcG9uc2Uuc2V0KG5ldyBVaW50OEFycmF5KHB1YmxpY0tleUJ1ZmZlciksIDApO1xuICAgICAgICByZXNwb25zZS5zZXQobmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlQnVmZmVyKSwgcHVibGljS2V5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNJV1NNZXNzYWdlKHBheWxvYWQpIHtcbiAgICByZXR1cm4gY3JlYXRlU2lnbkluTWVzc2FnZVRleHQocGF5bG9hZCk7XG59XG5mdW5jdGlvbiBjcmVhdGVTSVdTTWVzc2FnZUJhc2U2NFVybChwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGVuY29kZShjcmVhdGVTSVdTTWVzc2FnZShwYXlsb2FkKSlcbiAgICAgICAgLnJlcGxhY2UoL1xcKy9nLCAnLScpXG4gICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJ18nKVxuICAgICAgICAucmVwbGFjZSgvPSskLywgJycpOyAvLyBjb252ZXJ0IHRvIGJhc2U2NHVybCBlbmNvZGluZztcbn1cblxuLy8gb3B0aW9uYWwgZmVhdHVyZXNcbmNvbnN0IFNvbGFuYVNpZ25UcmFuc2FjdGlvbnMgPSAnc29sYW5hOnNpZ25UcmFuc2FjdGlvbnMnO1xuY29uc3QgU29sYW5hQ2xvbmVBdXRob3JpemF0aW9uID0gJ3NvbGFuYTpjbG9uZUF1dGhvcml6YXRpb24nO1xuY29uc3QgU29sYW5hU2lnbkluV2l0aFNvbGFuYSA9ICdzb2xhbmE6c2lnbkluV2l0aFNvbGFuYSc7XG5cbmZ1bmN0aW9uIGZyb21VaW50OEFycmF5KGJ5dGVBcnJheSkge1xuICAgIHJldHVybiBnZXRCYXNlNThEZWNvZGVyKCkuZGVjb2RlKGJ5dGVBcnJheSk7XG59XG5mdW5jdGlvbiBiYXNlNjRUb0Jhc2U1OChiYXNlNjRFbmNvZGVkU3RyaW5nKSB7XG4gICAgcmV0dXJuIGZyb21VaW50OEFycmF5KHRvVWludDhBcnJheShiYXNlNjRFbmNvZGVkU3RyaW5nKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBNb2JpbGVXYWxsZXR9IHByb3h5IHRoYXQgaGFuZGxlcyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBhbmQgQVBJIHRvIFJQQyBjb252ZXJzaW9uLlxuICpcbiAqIEBwYXJhbSBwcm90b2NvbFZlcnNpb24gdGhlIHByb3RvY29sIHZlcnNpb24gaW4gdXNlIGZvciB0aGlzIHNlc3Npb24vcmVxdWVzdFxuICogQHBhcmFtIHByb3RvY29sUmVxdWVzdEhhbmRsZXIgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIHNlbmRpbmcgdGhlIFJQQyByZXF1ZXN0IHRvIHRoZSB3YWxsZXQgZW5kcG9pbnQuXG4gKiBAcmV0dXJucyBhIHtAbGluayBNb2JpbGVXYWxsZXR9IHByb3h5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vYmlsZVdhbGxldFByb3h5KHByb3RvY29sVmVyc2lvbiwgcHJvdG9jb2xSZXF1ZXN0SGFuZGxlcikge1xuICAgIHJldHVybiBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgZ2V0KHRhcmdldCwgcCkge1xuICAgICAgICAgICAgLy8gV3JhcHBpbmcgYSBQcm94eSBpbiBhIHByb21pc2UgcmVzdWx0cyBpbiB0aGUgUHJveHkgYmVpbmcgYXNrZWQgZm9yIGEgJ3RoZW4nIHByb3BlcnR5IHNvIG11c3QgXG4gICAgICAgICAgICAvLyByZXR1cm4gbnVsbCBpZiAndGhlbicgaXMgY2FsbGVkIG9uIHRoaXMgcHJveHkgdG8gbGV0IHRoZSAncmVzb2x2ZSgpJyBjYWxsIGtub3cgdGhpcyBpcyBub3QgYSBwcm9taXNlLlxuICAgICAgICAgICAgLy8gc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTM4OTA5MDRcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKHAgPT09ICd0aGVuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldFtwXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3BdID0gZnVuY3Rpb24gKGlucHV0UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG1ldGhvZCwgcGFyYW1zIH0gPSBoYW5kbGVNb2JpbGVXYWxsZXRSZXF1ZXN0KHAsIGlucHV0UGFyYW1zLCBwcm90b2NvbFZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgcHJvdG9jb2xSZXF1ZXN0SGFuZGxlcihtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcmVxdWVzdCB0cmllZCB0byBzaWduIGluIGJ1dCB0aGUgd2FsbGV0IGRpZCBub3QgcmV0dXJuIGEgc2lnbiBpbiByZXN1bHQsIGZhbGxiYWNrIG9uIG1lc3NhZ2Ugc2lnbmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2F1dGhvcml6ZScgJiYgcGFyYW1zLnNpZ25faW5fcGF5bG9hZCAmJiAhcmVzdWx0LnNpZ25faW5fcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0WydzaWduX2luX3Jlc3VsdCddID0geWllbGQgc2lnbkluRmFsbGJhY2socGFyYW1zLnNpZ25faW5fcGF5bG9hZCwgcmVzdWx0LCBwcm90b2NvbFJlcXVlc3RIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVNb2JpbGVXYWxsZXRSZXNwb25zZShwLCByZXN1bHQsIHByb3RvY29sVmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3BdO1xuICAgICAgICB9LFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEhhbmRsZXMgYWxsIHtAbGluayBNb2JpbGVXYWxsZXR9IEFQSSByZXF1ZXN0cyBhbmQgZGV0ZXJtaW5lcyB0aGUgY29ycmVjdCBNV0EgUlBDIG1ldGhvZCBhbmQgcGFyYW1zIHRvIGNhbGwuXG4gKiBUaGlzIGhhbmRsZXMgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBAcHJvdG9jb2xWZXJzaW9uLlxuICpcbiAqIEBwYXJhbSBtZXRob2ROYW1lIHRoZSBuYW1lIG9mIHtAbGluayBNb2JpbGVXYWxsZXR9IG1ldGhvZCB0aGF0IHdhcyBjYWxsZWRcbiAqIEBwYXJhbSBtZXRob2RQYXJhbXMgdGhlIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhc3NlZCB0byB0aGUgbWV0aG9kXG4gKiBAcGFyYW0gcHJvdG9jb2xWZXJzaW9uIHRoZSBwcm90b2NvbCB2ZXJzaW9uIGluIHVzZSBmb3IgdGhpcyBzZXNzaW9uL3JlcXVlc3RcbiAqIEByZXR1cm5zIHRoZSBSUEMgcmVxdWVzdCBtZXRob2QgYW5kIHBhcmFtcyB0aGF0IHNob3VsZCBiZSBzZW50IHRvIHRoZSB3YWxsZXQgZW5kcG9pbnRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlTW9iaWxlV2FsbGV0UmVxdWVzdChtZXRob2ROYW1lLCBtZXRob2RQYXJhbXMsIHByb3RvY29sVmVyc2lvbikge1xuICAgIGxldCBwYXJhbXMgPSBtZXRob2RQYXJhbXM7XG4gICAgbGV0IG1ldGhvZCA9IG1ldGhvZE5hbWVcbiAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgLnJlcGxhY2UoL1tBLVpdL2csIChsZXR0ZXIpID0+IGBfJHtsZXR0ZXIudG9Mb3dlckNhc2UoKX1gKVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgY2FzZSAnYXV0aG9yaXplJzoge1xuICAgICAgICAgICAgbGV0IHsgY2hhaW4gfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGlmIChwcm90b2NvbFZlcnNpb24gPT09ICdsZWdhY3knKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFpbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzb2xhbmE6dGVzdG5ldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gJ3Rlc3RuZXQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc29sYW5hOmRldm5ldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gJ2Rldm5ldCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzb2xhbmE6bWFpbm5ldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gJ21haW5uZXQtYmV0YSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbiA9IHBhcmFtcy5jbHVzdGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtcy5jbHVzdGVyID0gY2hhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Rlc3RuZXQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkZXZuZXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbiA9IGBzb2xhbmE6JHtjaGFpbn1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFpbm5ldC1iZXRhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSAnc29sYW5hOm1haW5uZXQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNoYWluID0gY2hhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncmVhdXRob3JpemUnOiB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhfdG9rZW4sIGlkZW50aXR5IH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBpZiAoYXV0aF90b2tlbikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvdG9jb2xWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZ2FjeSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdyZWF1dGhvcml6ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7IGF1dGhfdG9rZW46IGF1dGhfdG9rZW4sIGlkZW50aXR5OiBpZGVudGl0eSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gJ2F1dGhvcml6ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1ldGhvZCwgcGFyYW1zIH07XG59XG4vKipcbiAqIEhhbmRsZXMgYWxsIHtAbGluayBNb2JpbGVXYWxsZXR9IEFQSSByZXNwb25zZXMgYW5kIG1vZGlmaWVzIHRoZSByZXNwb25zZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGlmIG5lZWRlZFxuICpcbiAqIEBwYXJhbSBtZXRob2QgdGhlIHtAbGluayBNb2JpbGVXYWxsZXR9IG1ldGhvZCB0aGF0IHdhcyBjYWxsZWRcbiAqIEBwYXJhbSByZXNwb25zZSB0aGUgb3JpZ2luYWwgcmVzcG9uc2UgdGhhdCB3YXMgcmV0dXJuZWQgYnkgdGhlIG1ldGhvZCBjYWxsXG4gKiBAcGFyYW0gcHJvdG9jb2xWZXJzaW9uIHRoZSBwcm90b2NvbCB2ZXJzaW9uIGluIHVzZSBmb3IgdGhpcyBzZXNzaW9uL3JlcXVlc3RcbiAqIEByZXR1cm5zIHRoZSBwb3NzaWJseSBtb2RpZmllZCByZXNwb25zZVxuICovXG5mdW5jdGlvbiBoYW5kbGVNb2JpbGVXYWxsZXRSZXNwb25zZShtZXRob2QsIHJlc3BvbnNlLCBwcm90b2NvbFZlcnNpb24pIHtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICBjYXNlICdnZXRDYXBhYmlsaXRpZXMnOiB7XG4gICAgICAgICAgICBjb25zdCBjYXBhYmlsaXRpZXMgPSByZXNwb25zZTtcbiAgICAgICAgICAgIHN3aXRjaCAocHJvdG9jb2xWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGVnYWN5Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZWF0dXJlcyA9IFtTb2xhbmFTaWduVHJhbnNhY3Rpb25zXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcGFiaWxpdGllcy5zdXBwb3J0c19jbG9uZV9hdXRob3JpemF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKFNvbGFuYUNsb25lQXV0aG9yaXphdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2FwYWJpbGl0aWVzKSwgeyBmZWF0dXJlczogZmVhdHVyZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3YxJzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYXBhYmlsaXRpZXMpLCB7IHN1cHBvcnRzX3NpZ25fYW5kX3NlbmRfdHJhbnNhY3Rpb25zOiB0cnVlLCBzdXBwb3J0c19jbG9uZV9hdXRob3JpemF0aW9uOiBjYXBhYmlsaXRpZXMuZmVhdHVyZXMuaW5jbHVkZXMoU29sYW5hQ2xvbmVBdXRob3JpemF0aW9uKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZnVuY3Rpb24gc2lnbkluRmFsbGJhY2soc2lnbkluUGF5bG9hZCwgYXV0aG9yaXphdGlvblJlc3VsdCwgcHJvdG9jb2xSZXF1ZXN0SGFuZGxlcikge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBkb21haW4gPSAoX2EgPSBzaWduSW5QYXlsb2FkLmRvbWFpbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogd2luZG93LmxvY2F0aW9uLmhvc3Q7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzWzBdLmFkZHJlc3M7XG4gICAgICAgIGNvbnN0IHNpd3NNZXNzYWdlID0gY3JlYXRlU0lXU01lc3NhZ2VCYXNlNjRVcmwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaWduSW5QYXlsb2FkKSwgeyBkb21haW4sIGFkZHJlc3M6IGJhc2U2NFRvQmFzZTU4KGFkZHJlc3MpIH0pKTtcbiAgICAgICAgY29uc3Qgc2lnbk1lc3NhZ2VSZXN1bHQgPSB5aWVsZCBwcm90b2NvbFJlcXVlc3RIYW5kbGVyKCdzaWduX21lc3NhZ2VzJywge1xuICAgICAgICAgICAgYWRkcmVzc2VzOiBbYWRkcmVzc10sXG4gICAgICAgICAgICBwYXlsb2FkczogW3Npd3NNZXNzYWdlXVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2lnbmVkUGF5bG9hZCA9IHRvVWludDhBcnJheShzaWduTWVzc2FnZVJlc3VsdC5zaWduZWRfcGF5bG9hZHNbMF0pO1xuICAgICAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gZnJvbVVpbnQ4QXJyYXkkMShzaWduZWRQYXlsb2FkLnNsaWNlKDAsIHNpZ25lZFBheWxvYWQubGVuZ3RoIC0gNjQpKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZnJvbVVpbnQ4QXJyYXkkMShzaWduZWRQYXlsb2FkLnNsaWNlKHNpZ25lZFBheWxvYWQubGVuZ3RoIC0gNjQpKTtcbiAgICAgICAgY29uc3Qgc2lnbkluUmVzdWx0ID0ge1xuICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgIC8vIFdvcmthcm91bmQ6IHNvbWUgd2FsbGV0cyBoYXZlIGJlZW4gb2JzZXJ2ZWQgdG8gb25seSByZXBseSB3aXRoIHRoZSBtZXNzYWdlIHNpZ25hdHVyZS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbm9uLWNvbXBsaWFudCB3aXRoIHRoZSBzcGVjLCBidXQgaW4gdGhlIGludGVyZXN0IG9mIG1heGltaXppbmcgY29tcGF0aWJpbGl0eSxcbiAgICAgICAgICAgIC8vIGRldGVjdCB0aGlzIGNhc2UgYW5kIHJldXNlIHRoZSBvcmlnaW5hbCBtZXNzYWdlLlxuICAgICAgICAgICAgc2lnbmVkX21lc3NhZ2U6IHNpZ25lZE1lc3NhZ2UubGVuZ3RoID09IDAgPyBzaXdzTWVzc2FnZSA6IHNpZ25lZE1lc3NhZ2UsXG4gICAgICAgICAgICBzaWduYXR1cmVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNpZ25JblJlc3VsdDtcbiAgICB9KTtcbn1cblxuY29uc3QgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTID0gNDtcbmZ1bmN0aW9uIGNyZWF0ZVNlcXVlbmNlTnVtYmVyVmVjdG9yKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgaWYgKHNlcXVlbmNlTnVtYmVyID49IDQyOTQ5NjcyOTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdXRib3VuZCBzZXF1ZW5jZSBudW1iZXIgb3ZlcmZsb3cuIFRoZSBtYXhpbXVtIHNlcXVlbmNlIG51bWJlciBpcyAzMi1ieXRlcy4nKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IEFycmF5QnVmZmVyKFNFUVVFTkNFX05VTUJFUl9CWVRFUyk7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhieXRlQXJyYXkpO1xuICAgIHZpZXcuc2V0VWludDMyKDAsIHNlcXVlbmNlTnVtYmVyLCAvKiBsaXR0bGVFbmRpYW4gKi8gZmFsc2UpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlQXJyYXkpO1xufVxuXG5jb25zdCBJTklUSUFMSVpBVElPTl9WRUNUT1JfQllURVMgPSAxMjtcbmNvbnN0IEVOQ09ERURfUFVCTElDX0tFWV9MRU5HVEhfQllURVMgPSA2NTtcbmZ1bmN0aW9uIGVuY3J5cHRNZXNzYWdlKHBsYWludGV4dCwgc2VxdWVuY2VOdW1iZXIsIHNoYXJlZFNlY3JldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyVmVjdG9yID0gY3JlYXRlU2VxdWVuY2VOdW1iZXJWZWN0b3Ioc2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICBjb25zdCBpbml0aWFsaXphdGlvblZlY3RvciA9IG5ldyBVaW50OEFycmF5KElOSVRJQUxJWkFUSU9OX1ZFQ1RPUl9CWVRFUyk7XG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoaW5pdGlhbGl6YXRpb25WZWN0b3IpO1xuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0geWllbGQgY3J5cHRvLnN1YnRsZS5lbmNyeXB0KGdldEFsZ29yaXRobVBhcmFtcyhzZXF1ZW5jZU51bWJlclZlY3RvciwgaW5pdGlhbGl6YXRpb25WZWN0b3IpLCBzaGFyZWRTZWNyZXQsIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShwbGFpbnRleHQpKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgVWludDhBcnJheShzZXF1ZW5jZU51bWJlclZlY3Rvci5ieXRlTGVuZ3RoICsgaW5pdGlhbGl6YXRpb25WZWN0b3IuYnl0ZUxlbmd0aCArIGNpcGhlcnRleHQuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJlc3BvbnNlLnNldChuZXcgVWludDhBcnJheShzZXF1ZW5jZU51bWJlclZlY3RvciksIDApO1xuICAgICAgICByZXNwb25zZS5zZXQobmV3IFVpbnQ4QXJyYXkoaW5pdGlhbGl6YXRpb25WZWN0b3IpLCBzZXF1ZW5jZU51bWJlclZlY3Rvci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmVzcG9uc2Uuc2V0KG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQpLCBzZXF1ZW5jZU51bWJlclZlY3Rvci5ieXRlTGVuZ3RoICsgaW5pdGlhbGl6YXRpb25WZWN0b3IuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRlY3J5cHRNZXNzYWdlKG1lc3NhZ2UsIHNoYXJlZFNlY3JldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyVmVjdG9yID0gbWVzc2FnZS5zbGljZSgwLCBTRVFVRU5DRV9OVU1CRVJfQllURVMpO1xuICAgICAgICBjb25zdCBpbml0aWFsaXphdGlvblZlY3RvciA9IG1lc3NhZ2Uuc2xpY2UoU0VRVUVOQ0VfTlVNQkVSX0JZVEVTLCBTRVFVRU5DRV9OVU1CRVJfQllURVMgKyBJTklUSUFMSVpBVElPTl9WRUNUT1JfQllURVMpO1xuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbWVzc2FnZS5zbGljZShTRVFVRU5DRV9OVU1CRVJfQllURVMgKyBJTklUSUFMSVpBVElPTl9WRUNUT1JfQllURVMpO1xuICAgICAgICBjb25zdCBwbGFpbnRleHRCdWZmZXIgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmRlY3J5cHQoZ2V0QWxnb3JpdGhtUGFyYW1zKHNlcXVlbmNlTnVtYmVyVmVjdG9yLCBpbml0aWFsaXphdGlvblZlY3RvciksIHNoYXJlZFNlY3JldCwgY2lwaGVydGV4dCk7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IGdldFV0ZjhEZWNvZGVyKCkuZGVjb2RlKHBsYWludGV4dEJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRBbGdvcml0aG1QYXJhbXMoc2VxdWVuY2VOdW1iZXIsIGluaXRpYWxpemF0aW9uVmVjdG9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkaXRpb25hbERhdGE6IHNlcXVlbmNlTnVtYmVyLFxuICAgICAgICBpdjogaW5pdGlhbGl6YXRpb25WZWN0b3IsXG4gICAgICAgIG5hbWU6ICdBRVMtR0NNJyxcbiAgICAgICAgdGFnTGVuZ3RoOiAxMjgsIC8vIDE2IGJ5dGUgdGFnID0+IDEyOCBiaXRzXG4gICAgfTtcbn1cbmxldCBfdXRmOERlY29kZXI7XG5mdW5jdGlvbiBnZXRVdGY4RGVjb2RlcigpIHtcbiAgICBpZiAoX3V0ZjhEZWNvZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3V0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgIH1cbiAgICByZXR1cm4gX3V0ZjhEZWNvZGVyO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUFzc29jaWF0aW9uS2V5cGFpcigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4geWllbGQgY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICAgICAgICBuYW1lOiAnRUNEU0EnLFxuICAgICAgICAgICAgbmFtZWRDdXJ2ZTogJ1AtMjU2JyxcbiAgICAgICAgfSwgZmFsc2UgLyogZXh0cmFjdGFibGUgKi8sIFsnc2lnbiddIC8qIGtleVVzYWdlcyAqLyk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRUNESEtleXBhaXIoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoe1xuICAgICAgICAgICAgbmFtZTogJ0VDREgnLFxuICAgICAgICAgICAgbmFtZWRDdXJ2ZTogJ1AtMjU2JyxcbiAgICAgICAgfSwgZmFsc2UgLyogZXh0cmFjdGFibGUgKi8sIFsnZGVyaXZlS2V5JywgJ2Rlcml2ZUJpdHMnXSAvKiBrZXlVc2FnZXMgKi8pO1xuICAgIH0pO1xufVxuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTQ1ODk5Ni84MDIwNDdcbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9CYXNlNjRTdHJpbmcoYnVmZmVyKSB7XG4gICAgbGV0IGJpbmFyeSA9ICcnO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBsZW4gPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICAgICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaWldKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5idG9hKGJpbmFyeSk7XG59XG5cbmZ1bmN0aW9uIGdldFJhbmRvbUFzc29jaWF0aW9uUG9ydCgpIHtcbiAgICByZXR1cm4gYXNzZXJ0QXNzb2NpYXRpb25Qb3J0KDQ5MTUyICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDY1NTM1IC0gNDkxNTIgKyAxKSkpO1xufVxuZnVuY3Rpb24gYXNzZXJ0QXNzb2NpYXRpb25Qb3J0KHBvcnQpIHtcbiAgICBpZiAocG9ydCA8IDQ5MTUyIHx8IHBvcnQgPiA2NTUzNSkge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfQVNTT0NJQVRJT05fUE9SVF9PVVRfT0ZfUkFOR0UsIGBBc3NvY2lhdGlvbiBwb3J0IG51bWJlciBtdXN0IGJlIGJldHdlZW4gNDkxNTIgYW5kIDY1NTM1LiAke3BvcnR9IGdpdmVuLmAsIHsgcG9ydCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcnQ7XG59XG5cbmZ1bmN0aW9uIGdldFN0cmluZ1dpdGhVUkxVbnNhZmVDaGFyYWN0ZXJzUmVwbGFjZWQodW5zYWZlQmFzZTY0RW5jb2RlZFN0cmluZykge1xuICAgIHJldHVybiB1bnNhZmVCYXNlNjRFbmNvZGVkU3RyaW5nLnJlcGxhY2UoL1svKz1dL2csIChtKSA9PiAoe1xuICAgICAgICAnLyc6ICdfJyxcbiAgICAgICAgJysnOiAnLScsXG4gICAgICAgICc9JzogJy4nLFxuICAgIH1bbV0pKTtcbn1cblxuY29uc3QgSU5URU5UX05BTUUgPSAnc29sYW5hLXdhbGxldCc7XG5mdW5jdGlvbiBnZXRQYXRoUGFydHMocGF0aFN0cmluZykge1xuICAgIHJldHVybiAocGF0aFN0cmluZ1xuICAgICAgICAvLyBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzXG4gICAgICAgIC5yZXBsYWNlKC8oXlxcLyt8XFwvKyQpL2csICcnKVxuICAgICAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgZGlyZWN0b3JpZXNcbiAgICAgICAgLnNwbGl0KCcvJykpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZW50VVJMKG1ldGhvZFBhdGhuYW1lLCBpbnRlbnRVcmxCYXNlKSB7XG4gICAgbGV0IGJhc2VVcmwgPSBudWxsO1xuICAgIGlmIChpbnRlbnRVcmxCYXNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBiYXNlVXJsID0gbmV3IFVSTChpbnRlbnRVcmxCYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgICAgIGlmICgoYmFzZVVybCA9PT0gbnVsbCB8fCBiYXNlVXJsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiYXNlVXJsLnByb3RvY29sKSAhPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9GT1JCSURERU5fV0FMTEVUX0JBU0VfVVJMLCAnQmFzZSBVUkxzIHN1cHBsaWVkIGJ5IHdhbGxldHMgbXVzdCBiZSB2YWxpZCBgaHR0cHNgIFVSTHMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiYXNlVXJsIHx8IChiYXNlVXJsID0gbmV3IFVSTChgJHtJTlRFTlRfTkFNRX06L2ApKTtcbiAgICBjb25zdCBwYXRobmFtZSA9IG1ldGhvZFBhdGhuYW1lLnN0YXJ0c1dpdGgoJy8nKVxuICAgICAgICA/IC8vIE1ldGhvZCBpcyBhbiBhYnNvbHV0ZSBwYXRoLiBSZXBsYWNlIGl0IHdob2xlc2FsZS5cbiAgICAgICAgICAgIG1ldGhvZFBhdGhuYW1lXG4gICAgICAgIDogLy8gTWV0aG9kIGlzIGEgcmVsYXRpdmUgcGF0aC4gTWVyZ2UgaXQgd2l0aCB0aGUgZXhpc3Rpbmcgb25lLlxuICAgICAgICAgICAgWy4uLmdldFBhdGhQYXJ0cyhiYXNlVXJsLnBhdGhuYW1lKSwgLi4uZ2V0UGF0aFBhcnRzKG1ldGhvZFBhdGhuYW1lKV0uam9pbignLycpO1xuICAgIHJldHVybiBuZXcgVVJMKHBhdGhuYW1lLCBiYXNlVXJsKTtcbn1cbmZ1bmN0aW9uIGdldEFzc29jaWF0ZUFuZHJvaWRJbnRlbnRVUkwoYXNzb2NpYXRpb25QdWJsaWNLZXksIHB1dGF0aXZlUG9ydCwgYXNzb2NpYXRpb25VUkxCYXNlLCBwcm90b2NvbFZlcnNpb25zID0gWyd2MSddKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25Qb3J0ID0gYXNzZXJ0QXNzb2NpYXRpb25Qb3J0KHB1dGF0aXZlUG9ydCk7XG4gICAgICAgIGNvbnN0IGV4cG9ydGVkS2V5ID0geWllbGQgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ3JhdycsIGFzc29jaWF0aW9uUHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgZW5jb2RlZEtleSA9IGFycmF5QnVmZmVyVG9CYXNlNjRTdHJpbmcoZXhwb3J0ZWRLZXkpO1xuICAgICAgICBjb25zdCB1cmwgPSBnZXRJbnRlbnRVUkwoJ3YxL2Fzc29jaWF0ZS9sb2NhbCcsIGFzc29jaWF0aW9uVVJMQmFzZSk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdhc3NvY2lhdGlvbicsIGdldFN0cmluZ1dpdGhVUkxVbnNhZmVDaGFyYWN0ZXJzUmVwbGFjZWQoZW5jb2RlZEtleSkpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgncG9ydCcsIGAke2Fzc29jaWF0aW9uUG9ydH1gKTtcbiAgICAgICAgcHJvdG9jb2xWZXJzaW9ucy5mb3JFYWNoKCh2ZXJzaW9uKSA9PiB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgndicsIHZlcnNpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJlbW90ZUFzc29jaWF0ZUFuZHJvaWRJbnRlbnRVUkwoYXNzb2NpYXRpb25QdWJsaWNLZXksIGhvc3RBdXRob3JpdHksIHJlZmxlY3RvcklkLCBhc3NvY2lhdGlvblVSTEJhc2UsIHByb3RvY29sVmVyc2lvbnMgPSBbJ3YxJ10pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBleHBvcnRlZEtleSA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdyYXcnLCBhc3NvY2lhdGlvblB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGVuY29kZWRLZXkgPSBhcnJheUJ1ZmZlclRvQmFzZTY0U3RyaW5nKGV4cG9ydGVkS2V5KTtcbiAgICAgICAgY29uc3QgdXJsID0gZ2V0SW50ZW50VVJMKCd2MS9hc3NvY2lhdGUvcmVtb3RlJywgYXNzb2NpYXRpb25VUkxCYXNlKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2Fzc29jaWF0aW9uJywgZ2V0U3RyaW5nV2l0aFVSTFVuc2FmZUNoYXJhY3RlcnNSZXBsYWNlZChlbmNvZGVkS2V5KSk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdyZWZsZWN0b3InLCBgJHtob3N0QXV0aG9yaXR5fWApO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnaWQnLCBgJHtmcm9tVWludDhBcnJheSQxKHJlZmxlY3RvcklkLCB0cnVlKX1gKTtcbiAgICAgICAgcHJvdG9jb2xWZXJzaW9ucy5mb3JFYWNoKCh2ZXJzaW9uKSA9PiB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgndicsIHZlcnNpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZW5jcnlwdEpzb25ScGNNZXNzYWdlKGpzb25ScGNNZXNzYWdlLCBzaGFyZWRTZWNyZXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBKU09OLnN0cmluZ2lmeShqc29uUnBjTWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0ganNvblJwY01lc3NhZ2UuaWQ7XG4gICAgICAgIHJldHVybiBlbmNyeXB0TWVzc2FnZShwbGFpbnRleHQsIHNlcXVlbmNlTnVtYmVyLCBzaGFyZWRTZWNyZXQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZGVjcnlwdEpzb25ScGNNZXNzYWdlKG1lc3NhZ2UsIHNoYXJlZFNlY3JldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IHlpZWxkIGRlY3J5cHRNZXNzYWdlKG1lc3NhZ2UsIHNoYXJlZFNlY3JldCk7XG4gICAgICAgIGNvbnN0IGpzb25ScGNNZXNzYWdlID0gSlNPTi5wYXJzZShwbGFpbnRleHQpO1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoanNvblJwY01lc3NhZ2UsICdlcnJvcicpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3IoanNvblJwY01lc3NhZ2UuaWQsIGpzb25ScGNNZXNzYWdlLmVycm9yLmNvZGUsIGpzb25ScGNNZXNzYWdlLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uUnBjTWVzc2FnZTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIZWxsb1JzcChwYXlsb2FkQnVmZmVyLCAvLyBUaGUgWDkuNjItZW5jb2RlZCB3YWxsZXQgZW5kcG9pbnQgZXBoZW1lcmFsIEVDREggcHVibGljIGtleXBvaW50LlxuYXNzb2NpYXRpb25QdWJsaWNLZXksIGVjZGhQcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgW2Fzc29jaWF0aW9uUHVibGljS2V5QnVmZmVyLCB3YWxsZXRQdWJsaWNLZXldID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ3JhdycsIGFzc29jaWF0aW9uUHVibGljS2V5KSxcbiAgICAgICAgICAgIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBwYXlsb2FkQnVmZmVyLnNsaWNlKDAsIEVOQ09ERURfUFVCTElDX0tFWV9MRU5HVEhfQllURVMpLCB7IG5hbWU6ICdFQ0RIJywgbmFtZWRDdXJ2ZTogJ1AtMjU2JyB9LCBmYWxzZSAvKiBleHRyYWN0YWJsZSAqLywgW10gLyoga2V5VXNhZ2VzICovKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IHNoYXJlZFNlY3JldCA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZGVyaXZlQml0cyh7IG5hbWU6ICdFQ0RIJywgcHVibGljOiB3YWxsZXRQdWJsaWNLZXkgfSwgZWNkaFByaXZhdGVLZXksIDI1Nik7XG4gICAgICAgIGNvbnN0IGVjZGhTZWNyZXRLZXkgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3Jywgc2hhcmVkU2VjcmV0LCAnSEtERicsIGZhbHNlIC8qIGV4dHJhY3RhYmxlICovLCBbJ2Rlcml2ZUtleSddIC8qIGtleVVzYWdlcyAqLyk7XG4gICAgICAgIGNvbnN0IGFlc0tleU1hdGVyaWFsVmFsID0geWllbGQgY3J5cHRvLnN1YnRsZS5kZXJpdmVLZXkoe1xuICAgICAgICAgICAgbmFtZTogJ0hLREYnLFxuICAgICAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgICAgICAgICAgc2FsdDogbmV3IFVpbnQ4QXJyYXkoYXNzb2NpYXRpb25QdWJsaWNLZXlCdWZmZXIpLFxuICAgICAgICAgICAgaW5mbzogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfSwgZWNkaFNlY3JldEtleSwgeyBuYW1lOiAnQUVTLUdDTScsIGxlbmd0aDogMTI4IH0sIGZhbHNlIC8qIGV4dHJhY3RhYmxlICovLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgICAgICAgcmV0dXJuIGFlc0tleU1hdGVyaWFsVmFsO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNlc3Npb25Qcm9wcyhtZXNzYWdlLCBzaGFyZWRTZWNyZXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSB5aWVsZCBkZWNyeXB0TWVzc2FnZShtZXNzYWdlLCBzaGFyZWRTZWNyZXQpO1xuICAgICAgICBjb25zdCBqc29uUHJvcGVydGllcyA9IEpTT04ucGFyc2UocGxhaW50ZXh0KTtcbiAgICAgICAgbGV0IHByb3RvY29sVmVyc2lvbiA9ICdsZWdhY3knO1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoanNvblByb3BlcnRpZXMsICd2JykpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoanNvblByb3BlcnRpZXMudikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICAgICAgICBjYXNlICd2MSc6XG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sVmVyc2lvbiA9ICd2MSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZ2FjeSc6XG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sVmVyc2lvbiA9ICdsZWdhY3knO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfSU5WQUxJRF9QUk9UT0NPTF9WRVJTSU9OLCBgVW5rbm93bi91bnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke2pzb25Qcm9wZXJ0aWVzLnZ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBwcm90b2NvbF92ZXJzaW9uOiBwcm90b2NvbFZlcnNpb25cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8vIFR5cGVzY3JpcHQgYGVudW1zYCB0aHdhcnQgdHJlZS1zaGFraW5nLiBTZWUgaHR0cHM6Ly9iYXJnc3Rlbi5vcmcvanN0cy9lbnVtcy9cbmNvbnN0IEJyb3dzZXIgPSB7XG4gICAgRmlyZWZveDogMCxcbiAgICBPdGhlcjogMSxcbn07XG5mdW5jdGlvbiBhc3NlcnRVbnJlYWNoYWJsZSh4KSB7XG4gICAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBnZXRCcm93c2VyKCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gvJykgIT09IC0xID8gQnJvd3Nlci5GaXJlZm94IDogQnJvd3Nlci5PdGhlcjtcbn1cbmZ1bmN0aW9uIGdldERldGVjdGlvblByb21pc2UoKSB7XG4gICAgLy8gQ2hyb21lIGFuZCBvdGhlcnMgc2lsZW50bHkgZmFpbCBpZiBhIGN1c3RvbSBwcm90b2NvbCBpcyBub3Qgc3VwcG9ydGVkLlxuICAgIC8vIEZvciB0aGVzZSwgd2Ugd2FpdCB0byBzZWUgaWYgdGhlIGJyb3dzZXIgaXMgbmF2aWdhdGVkIGF3YXkgZnJvbSBpblxuICAgIC8vIGEgcmVhc29uYWJsZSBhbW91bnQgb2YgdGltZSAoaWUuIHRoZSBuYXRpdmUgd2FsbGV0IG9wZW5lZCkuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlQmx1cik7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0sIDMwMDApO1xuICAgIH0pO1xufVxubGV0IF9mcmFtZSA9IG51bGw7XG5mdW5jdGlvbiBsYXVuY2hVcmxUaHJvdWdoSGlkZGVuRnJhbWUodXJsKSB7XG4gICAgaWYgKF9mcmFtZSA9PSBudWxsKSB7XG4gICAgICAgIF9mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICBfZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChfZnJhbWUpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIF9mcmFtZS5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGxhdW5jaEFzc29jaWF0aW9uKGFzc29jaWF0aW9uVXJsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKGFzc29jaWF0aW9uVXJsLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgLy8gVGhlIGFzc29jaWF0aW9uIFVSTCBpcyBhbiBBbmRyb2lkICdBcHAgTGluaycgb3IgaU9TICdVbml2ZXJzYWwgTGluaycuXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgcmVndWxhciB3ZWIgVVJMcyB0aGF0IGFyZSBkZXNpZ25lZCB0byBsYXVuY2ggYW4gYXBwIGlmIGl0XG4gICAgICAgICAgICAvLyBpcyBpbnN0YWxsZWQgb3IgbG9hZCB0aGUgYWN0dWFsIHRhcmdldCB3ZWJwYWdlIGlmIG5vdC5cbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIGFzc29jaWF0aW9uIFVSTCBoYXMgYSBjdXN0b20gcHJvdG9jb2wgKGVnLiBgc29sYW5hLXdhbGxldDpgKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYnJvd3Nlcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEJyb3dzZXIuRmlyZWZveDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGEgY3VzdG9tIHByb3RvY29sIGlzIG5vdCBzdXBwb3J0ZWQgaW4gRmlyZWZveCwgaXQgdGhyb3dzLlxuICAgICAgICAgICAgICAgICAgICAgICAgbGF1bmNoVXJsVGhyb3VnaEhpZGRlbkZyYW1lKGFzc29jaWF0aW9uVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgdGhpcyBsaW5lLCBpdCdzIHN1cHBvcnRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEJyb3dzZXIuT3RoZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRldGVjdGlvblByb21pc2UgPSBnZXREZXRlY3Rpb25Qcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKGFzc29jaWF0aW9uVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGRldGVjdGlvblByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0VW5yZWFjaGFibGUoYnJvd3Nlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfV0FMTEVUX05PVF9GT1VORCwgJ0ZvdW5kIG5vIGluc3RhbGxlZCB3YWxsZXQgdGhhdCBzdXBwb3J0cyB0aGUgbW9iaWxlIHdhbGxldCBwcm90b2NvbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc3RhcnRTZXNzaW9uKGFzc29jaWF0aW9uUHVibGljS2V5LCBhc3NvY2lhdGlvblVSTEJhc2UpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByYW5kb21Bc3NvY2lhdGlvblBvcnQgPSBnZXRSYW5kb21Bc3NvY2lhdGlvblBvcnQoKTtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25VcmwgPSB5aWVsZCBnZXRBc3NvY2lhdGVBbmRyb2lkSW50ZW50VVJMKGFzc29jaWF0aW9uUHVibGljS2V5LCByYW5kb21Bc3NvY2lhdGlvblBvcnQsIGFzc29jaWF0aW9uVVJMQmFzZSk7XG4gICAgICAgIHlpZWxkIGxhdW5jaEFzc29jaWF0aW9uKGFzc29jaWF0aW9uVXJsKTtcbiAgICAgICAgcmV0dXJuIHJhbmRvbUFzc29jaWF0aW9uUG9ydDtcbiAgICB9KTtcbn1cblxuY29uc3QgV0VCU09DS0VUX0NPTk5FQ1RJT05fQ09ORklHID0ge1xuICAgIC8qKlxuICAgICAqIDMwMCBtaWxsaXNlY29uZHMgaXMgYSBnZW5lcmFsbHkgYWNjZXB0ZWQgdGhyZXNob2xkIGZvciB3aGF0IHNvbWVvbmVcbiAgICAgKiB3b3VsZCBjb25zaWRlciBhbiBhY2NlcHRhYmxlIHJlc3BvbnNlIHRpbWUgZm9yIGEgdXNlciBpbnRlcmZhY2VcbiAgICAgKiBhZnRlciBoYXZpbmcgcGVyZm9ybWVkIGEgbG93LWF0dGVudGlvbiB0YXBwaW5nIHRhc2suIFdlIHNldCB0aGUgaW5pdGlhbFxuICAgICAqIGludGVydmFsIGF0IHdoaWNoIHdlIHdhaXQgZm9yIHRoZSB3YWxsZXQgdG8gc2V0IHVwIHRoZSB3ZWJzb2NrZXQgYXRcbiAgICAgKiBoYWxmIHRoaXMsIGFzIHBlciB0aGUgTnlxdWlzdCBmcmVxdWVuY3ksIHdpdGggYSBwcm9ncmVzc2l2ZSBiYWNrb2ZmXG4gICAgICogc2VxdWVuY2UgZnJvbSB0aGVyZS4gVGhlIHRvdGFsIHdhaXQgdGltZSBpcyAzMHMsIHdoaWNoIGFsbG93cyBmb3IgdGhlXG4gICAgICogdXNlciB0byBiZSBwcmVzZW50ZWQgd2l0aCBhIGRpc2FtYmlndWF0aW9uIGRpYWxvZywgc2VsZWN0IGEgd2FsbGV0LCBhbmRcbiAgICAgKiBmb3IgdGhlIHdhbGxldCBhcHAgdG8gc3Vic2VxdWVudGx5IHN0YXJ0LlxuICAgICAqL1xuICAgIHJldHJ5RGVsYXlTY2hlZHVsZU1zOiBbMTUwLCAxNTAsIDIwMCwgNTAwLCA1MDAsIDc1MCwgNzUwLCAxMDAwXSxcbiAgICB0aW1lb3V0TXM6IDMwMDAwLFxufTtcbmNvbnN0IFdFQlNPQ0tFVF9QUk9UT0NPTF9CSU5BUlkgPSAnY29tLnNvbGFuYS5tb2JpbGV3YWxsZXRhZGFwdGVyLnYxJztcbmNvbnN0IFdFQlNPQ0tFVF9QUk9UT0NPTF9CQVNFNjQgPSAnY29tLnNvbGFuYS5tb2JpbGV3YWxsZXRhZGFwdGVyLnYxLmJhc2U2NCc7XG5mdW5jdGlvbiBhc3NlcnRTZWN1cmVDb250ZXh0KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB3aW5kb3cuaXNTZWN1cmVDb250ZXh0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9TRUNVUkVfQ09OVEVYVF9SRVFVSVJFRCwgJ1RoZSBtb2JpbGUgd2FsbGV0IGFkYXB0ZXIgcHJvdG9jb2wgbXVzdCBiZSB1c2VkIGluIGEgc2VjdXJlIGNvbnRleHQgKGBodHRwc2ApLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydFNlY3VyZUVuZHBvaW50U3BlY2lmaWNVUkkod2FsbGV0VXJpQmFzZSkge1xuICAgIGxldCB1cmw7XG4gICAgdHJ5IHtcbiAgICAgICAgdXJsID0gbmV3IFVSTCh3YWxsZXRVcmlCYXNlKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9GT1JCSURERU5fV0FMTEVUX0JBU0VfVVJMLCAnSW52YWxpZCBiYXNlIFVSTCBzdXBwbGllZCBieSB3YWxsZXQnKTtcbiAgICB9XG4gICAgaWYgKHVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkwsICdCYXNlIFVSTHMgc3VwcGxpZWQgYnkgd2FsbGV0cyBtdXN0IGJlIHZhbGlkIGBodHRwc2AgVVJMcycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheShieXRlQXJyYXkpIHtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVBcnJheSk7XG4gICAgcmV0dXJuIHZpZXcuZ2V0VWludDMyKDAsIC8qIGxpdHRsZUVuZGlhbiAqLyBmYWxzZSk7XG59XG5mdW5jdGlvbiBkZWNvZGVWYXJMb25nKGJ5dGVBcnJheSkge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheSksIGwgPSBieXRlQXJyYXkuYnl0ZUxlbmd0aCwgbGltaXQgPSAxMCwgdmFsdWUgPSAwLCBvZmZzZXQgPSAwLCBiO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKG9mZnNldCA+PSBsIHx8IG9mZnNldCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ZhaWxlZCB0byBkZWNvZGUgdmFyaW50Jyk7XG4gICAgICAgIGIgPSBieXRlc1tvZmZzZXQrK107XG4gICAgICAgIHZhbHVlIHw9IChiICYgMHg3RikgPDwgKDcgKiBvZmZzZXQpO1xuICAgIH0gd2hpbGUgKGIgPj0gMHg4MCk7XG4gICAgcmV0dXJuIHsgdmFsdWUsIG9mZnNldCB9O1xufVxuZnVuY3Rpb24gZ2V0UmVmbGVjdG9ySWRGcm9tQnl0ZUFycmF5KGJ5dGVBcnJheSkge1xuICAgIGxldCB7IHZhbHVlOiBsZW5ndGgsIG9mZnNldCB9ID0gZGVjb2RlVmFyTG9uZyhieXRlQXJyYXkpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlQXJyYXkuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpKTtcbn1cbmZ1bmN0aW9uIHRyYW5zYWN0KGNhbGxiYWNrLCBjb25maWcpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBhc3NlcnRTZWN1cmVDb250ZXh0KCk7XG4gICAgICAgIGNvbnN0IGFzc29jaWF0aW9uS2V5cGFpciA9IHlpZWxkIGdlbmVyYXRlQXNzb2NpYXRpb25LZXlwYWlyKCk7XG4gICAgICAgIGNvbnN0IHNlc3Npb25Qb3J0ID0geWllbGQgc3RhcnRTZXNzaW9uKGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksIGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5iYXNlVXJpKTtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0VVJMID0gYHdzOi8vbG9jYWxob3N0OiR7c2Vzc2lvblBvcnR9L3NvbGFuYS13YWxsZXRgO1xuICAgICAgICBsZXQgY29ubmVjdGlvblN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgZ2V0TmV4dFJldHJ5RGVsYXlNcyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlZHVsZSA9IFsuLi5XRUJTT0NLRVRfQ09OTkVDVElPTl9DT05GSUcucmV0cnlEZWxheVNjaGVkdWxlTXNdO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IChzY2hlZHVsZS5sZW5ndGggPiAxID8gc2NoZWR1bGUuc2hpZnQoKSA6IHNjaGVkdWxlWzBdKTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgbGV0IG5leHRKc29uUnBjTWVzc2FnZUlkID0gMTtcbiAgICAgICAgbGV0IGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgICAgIGxldCBzdGF0ZSA9IHsgX190eXBlOiAnZGlzY29ubmVjdGVkJyB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNvY2tldDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjb25zdCBqc29uUnBjUmVzcG9uc2VQcm9taXNlcyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlT3BlbiA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuX190eXBlICE9PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFeHBlY3RlZCBhZGFwdGVyIHN0YXRlIHRvIGJlIGBjb25uZWN0aW5nYCBhdCB0aGUgbW9tZW50IHRoZSB3ZWJzb2NrZXQgb3BlbnMuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYEdvdCBcXGAke3N0YXRlLl9fdHlwZX1cXGAuYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCBoYW5kbGVPcGVuKTtcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyB2ZXJzaW9ucyBvZiB0aGlzIGxpYnJhcnkgYW5kIHdhbGxldGxpYiBpbmNvcnJlY3RseSBpbXBsZW1lbnRlZCB0aGUgTVdBIHNlc3Npb24gXG4gICAgICAgICAgICAgICAgLy8gZXN0YWJsaXNobWVudCBwcm90b2NvbCBmb3IgbG9jYWwgY29ubmVjdGlvbnMuIFRoZSBkYXBwIGlzIHN1cHBvc2VkIHRvIHdhaXQgZm9yIHRoZSBcbiAgICAgICAgICAgICAgICAvLyBBUFBfUElORyBtZXNzYWdlIGJlZm9yZSBzZW5kaW5nIHRoZSBIRUxMT19SRVEuIEluc3RlYWQsIHRoZSBkYXBwIHdhcyBzZW5kaW5nIHRoZSBIRUxMT19SRVEgXG4gICAgICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHkgdXBvbiBjb25uZWN0aW9uIHRvIHRoZSB3ZWJzb2NrZXQgc2VydmVyIHJlZ2FyZGxlc3Mgb2Ygd2V0aGVyIG9yIG5vdCBhbiBcbiAgICAgICAgICAgICAgICAvLyBBUFBfUElORyB3YXMgc2VudCBieSB0aGUgd2FsbGV0L3dlYnNvY2tldCBzZXJ2ZXIuIFdlIG11c3QgY29udGludWUgdG8gc3VwcG9ydCB0aGlzIGJlaGF2aW9yIFxuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIHVzZXIgaXMgdXNpbmcgYSB3YWxsZXQgdGhhdCBoYXMgbm90IHVwZGF0ZWQgdGhlaXIgd2FsbGV0bGliIGltcGxlbWVudGF0aW9uLiBcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFzc29jaWF0aW9uS2V5cGFpciB9ID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZWNkaEtleXBhaXIgPSB5aWVsZCBnZW5lcmF0ZUVDREhLZXlwYWlyKCk7XG4gICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoeWllbGQgY3JlYXRlSGVsbG9SZXEoZWNkaEtleXBhaXIucHVibGljS2V5LCBhc3NvY2lhdGlvbktleXBhaXIucHJpdmF0ZUtleSkpO1xuICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBfX3R5cGU6ICdoZWxsb19yZXFfc2VudCcsXG4gICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uUHVibGljS2V5OiBhc3NvY2lhdGlvbktleXBhaXIucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICBlY2RoUHJpdmF0ZUtleTogZWNkaEtleXBhaXIucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDbG9zZSA9IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZ0Lndhc0NsZWFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyBfX3R5cGU6ICdkaXNjb25uZWN0ZWQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fQ0xPU0VELCBgVGhlIHdhbGxldCBzZXNzaW9uIGRyb3BwZWQgdW5leHBlY3RlZGx5ICgke2V2dC5jb2RlfTogJHtldnQucmVhc29ufSkuYCwgeyBjbG9zZUV2ZW50OiBldnQgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwb3NlU29ja2V0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoX2V2dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGNvbm5lY3Rpb25TdGFydFRpbWUgPj0gV0VCU09DS0VUX0NPTk5FQ1RJT05fQ09ORklHLnRpbWVvdXRNcykge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fVElNRU9VVCwgYEZhaWxlZCB0byBjb25uZWN0IHRvIHRoZSB3YWxsZXQgd2Vic29ja2V0IGF0ICR7d2Vic29ja2V0VVJMfS5gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnlEZWxheU1zID0gZ2V0TmV4dFJldHJ5RGVsYXlNcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlXYWl0VGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheU1zKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVNZXNzYWdlID0gKGV2dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQnVmZmVyID0geWllbGQgZXZ0LmRhdGEuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLl9fdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUJ1ZmZlci5ieXRlTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvdW50ZXJlZCB1bmV4cGVjdGVkIG1lc3NhZ2Ugd2hpbGUgY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNkaEtleXBhaXIgPSB5aWVsZCBnZW5lcmF0ZUVDREhLZXlwYWlyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCh5aWVsZCBjcmVhdGVIZWxsb1JlcShlY2RoS2V5cGFpci5wdWJsaWNLZXksIGFzc29jaWF0aW9uS2V5cGFpci5wcml2YXRlS2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3R5cGU6ICdoZWxsb19yZXFfc2VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb25QdWJsaWNLZXk6IGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWNkaFByaXZhdGVLZXk6IGVjZGhLZXlwYWlyLnByaXZhdGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyVmVjdG9yID0gcmVzcG9uc2VCdWZmZXIuc2xpY2UoMCwgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IGdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheShzZXF1ZW5jZU51bWJlclZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyICE9PSAobGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBoYXMgaW52YWxpZCBzZXF1ZW5jZSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QganNvblJwY01lc3NhZ2UgPSB5aWVsZCBkZWNyeXB0SnNvblJwY01lc3NhZ2UocmVzcG9uc2VCdWZmZXIsIHN0YXRlLnNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0ganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbanNvblJwY01lc3NhZ2UuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tqc29uUnBjTWVzc2FnZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlc29sdmUoanNvblJwY01lc3NhZ2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tlLmpzb25ScGNNZXNzYWdlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbZS5qc29uUnBjTWVzc2FnZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hlbGxvX3JlcV9zZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgcmVjZWl2ZSBhbiBBUFBfUElORyBtZXNzYWdlIChlbXB0eSBtZXNzYWdlKSwgcmVzZW5kIHRoZSBIRUxMT19SRVEgKHNlZSBhYm92ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNkaEtleXBhaXIgPSB5aWVsZCBnZW5lcmF0ZUVDREhLZXlwYWlyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoeWllbGQgY3JlYXRlSGVsbG9SZXEoZWNkaEtleXBhaXIucHVibGljS2V5LCBhc3NvY2lhdGlvbktleXBhaXIucHJpdmF0ZUtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3R5cGU6ICdoZWxsb19yZXFfc2VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uUHVibGljS2V5OiBhc3NvY2lhdGlvbktleXBhaXIucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2RoUHJpdmF0ZUtleTogZWNkaEtleXBhaXIucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0geWllbGQgcGFyc2VIZWxsb1JzcChyZXNwb25zZUJ1ZmZlciwgc3RhdGUuYXNzb2NpYXRpb25QdWJsaWNLZXksIHN0YXRlLmVjZGhQcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyID0gcmVzcG9uc2VCdWZmZXIuc2xpY2UoRU5DT0RFRF9QVUJMSUNfS0VZX0xFTkdUSF9CWVRFUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uUHJvcGVydGllcyA9IHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyLmJ5dGVMZW5ndGggIT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHlpZWxkICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyVmVjdG9yID0gc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIuc2xpY2UoMCwgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSBnZXRTZXF1ZW5jZU51bWJlckZyb21CeXRlQXJyYXkoc2VxdWVuY2VOdW1iZXJWZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXIgIT09IChsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBoYXMgaW52YWxpZCBzZXF1ZW5jZSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU2Vzc2lvblByb3BzKHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyLCBzaGFyZWRTZWNyZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSgpIDogeyBwcm90b2NvbF92ZXJzaW9uOiAnbGVnYWN5JyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Nvbm5lY3RlZCcsIHNoYXJlZFNlY3JldCwgc2Vzc2lvblByb3BlcnRpZXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IGNyZWF0ZU1vYmlsZVdhbGxldFByb3h5KHNlc3Npb25Qcm9wZXJ0aWVzLnByb3RvY29sX3ZlcnNpb24sIChtZXRob2QsIHBhcmFtcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gbmV4dEpzb25ScGNNZXNzYWdlSWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCh5aWVsZCBlbmNyeXB0SnNvblJwY01lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzaGFyZWRTZWNyZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F1dGhvcml6ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlYXV0aG9yaXplJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRfdXJpX2Jhc2UgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YWxsZXRfdXJpX2Jhc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFNlY3VyZUVuZHBvaW50U3BlY2lmaWNVUkkod2FsbGV0X3VyaV9iYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh5aWVsZCBjYWxsYmFjayh3YWxsZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBkaXNwb3NlU29ja2V0O1xuICAgICAgICAgICAgbGV0IHJldHJ5V2FpdFRpbWVvdXRJZDtcbiAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwb3NlU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Nvbm5lY3RpbmcnLCBhc3NvY2lhdGlvbktleXBhaXIgfTtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvblN0YXJ0VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25TdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHdlYnNvY2tldFVSTCwgW1dFQlNPQ0tFVF9QUk9UT0NPTF9CSU5BUlldKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGhhbmRsZUNsb3NlKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBkaXNwb3NlU29ja2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHJldHJ5V2FpdFRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgaGFuZGxlT3Blbik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIGhhbmRsZUNsb3NlKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzdGFydFJlbW90ZVNjZW5hcmlvKGNvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGFzc2VydFNlY3VyZUNvbnRleHQoKTtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25LZXlwYWlyID0geWllbGQgZ2VuZXJhdGVBc3NvY2lhdGlvbktleXBhaXIoKTtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0VVJMID0gYHdzczovLyR7Y29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnJlbW90ZUhvc3RBdXRob3JpdHl9L3JlZmxlY3RgO1xuICAgICAgICBsZXQgY29ubmVjdGlvblN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgZ2V0TmV4dFJldHJ5RGVsYXlNcyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlZHVsZSA9IFsuLi5XRUJTT0NLRVRfQ09OTkVDVElPTl9DT05GSUcucmV0cnlEZWxheVNjaGVkdWxlTXNdO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IChzY2hlZHVsZS5sZW5ndGggPiAxID8gc2NoZWR1bGUuc2hpZnQoKSA6IHNjaGVkdWxlWzBdKTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgbGV0IG5leHRKc29uUnBjTWVzc2FnZUlkID0gMTtcbiAgICAgICAgbGV0IGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgICAgIGxldCBlbmNvZGluZztcbiAgICAgICAgbGV0IHN0YXRlID0geyBfX3R5cGU6ICdkaXNjb25uZWN0ZWQnIH07XG4gICAgICAgIGxldCBzb2NrZXQ7XG4gICAgICAgIGxldCBkaXNwb3NlU29ja2V0O1xuICAgICAgICBsZXQgZGVjb2RlQnl0ZXMgPSAoZXZ0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT0gJ2Jhc2U2NCcpIHsgLy8gYmFzZTY0IGVuY29kaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHlpZWxkIGV2dC5kYXRhO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1VpbnQ4QXJyYXkobWVzc2FnZSkuYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGV2dC5kYXRhLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZWZsZWN0b3IgQ29ubmVjdGlvbiBQaGFzZVxuICAgICAgICAvLyBoZXJlIHdlIGNvbm5lY3QgdG8gdGhlIHJlZmxlY3RvciBhbmQgd2FpdCBmb3IgdGhlIFJFRkxFQ1RPUl9JRCBtZXNzYWdlIFxuICAgICAgICAvLyBzbyB3ZSBidWlsZCB0aGUgYXNzb2NpYXRpb24gVVJMIGFuZCByZXR1cm4gdGhhdCBiYWNrIHRvIHRoZSBjYWxsZXJcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25VcmwgPSB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVPcGVuID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5fX3R5cGUgIT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGFkYXB0ZXIgc3RhdGUgdG8gYmUgYGNvbm5lY3RpbmdgIGF0IHRoZSBtb21lbnQgdGhlIHdlYnNvY2tldCBvcGVucy4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBgR290IFxcYCR7c3RhdGUuX190eXBlfVxcYC5gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnByb3RvY29sLmluY2x1ZGVzKFdFQlNPQ0tFVF9QUk9UT0NPTF9CQVNFNjQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gJ2Jhc2U2NCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9ICdiaW5hcnknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDbG9zZSA9IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZ0Lndhc0NsZWFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyBfX3R5cGU6ICdkaXNjb25uZWN0ZWQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fQ0xPU0VELCBgVGhlIHdhbGxldCBzZXNzaW9uIGRyb3BwZWQgdW5leHBlY3RlZGx5ICgke2V2dC5jb2RlfTogJHtldnQucmVhc29ufSkuYCwgeyBjbG9zZUV2ZW50OiBldnQgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwb3NlU29ja2V0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoX2V2dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGNvbm5lY3Rpb25TdGFydFRpbWUgPj0gV0VCU09DS0VUX0NPTk5FQ1RJT05fQ09ORklHLnRpbWVvdXRNcykge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fVElNRU9VVCwgYEZhaWxlZCB0byBjb25uZWN0IHRvIHRoZSB3YWxsZXQgd2Vic29ja2V0IGF0ICR7d2Vic29ja2V0VVJMfS5gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnlEZWxheU1zID0gZ2V0TmV4dFJldHJ5RGVsYXlNcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlXYWl0VGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheU1zKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVSZWZsZWN0b3JJZE1lc3NhZ2UgPSAoZXZ0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCdWZmZXIgPSB5aWVsZCBkZWNvZGVCeXRlcyhldnQpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5fX3R5cGUgPT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VCdWZmZXIuYnl0ZUxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIHVuZXhwZWN0ZWQgbWVzc2FnZSB3aGlsZSBjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmbGVjdG9ySWQgPSBnZXRSZWZsZWN0b3JJZEZyb21CeXRlQXJyYXkocmVzcG9uc2VCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdHlwZTogJ3JlZmxlY3Rvcl9pZF9yZWNlaXZlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZsZWN0b3JJZDogcmVmbGVjdG9ySWRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25VcmwgPSB5aWVsZCBnZXRSZW1vdGVBc3NvY2lhdGVBbmRyb2lkSW50ZW50VVJMKGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksIGNvbmZpZy5yZW1vdGVIb3N0QXV0aG9yaXR5LCByZWZsZWN0b3JJZCwgY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmJhc2VVcmkpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZVJlZmxlY3RvcklkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHJldHJ5V2FpdFRpbWVvdXRJZDtcbiAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwb3NlU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Nvbm5lY3RpbmcnLCBhc3NvY2lhdGlvbktleXBhaXIgfTtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvblN0YXJ0VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25TdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHdlYnNvY2tldFVSTCwgW1dFQlNPQ0tFVF9QUk9UT0NPTF9CSU5BUlksIFdFQlNPQ0tFVF9QUk9UT0NPTF9CQVNFNjRdKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGhhbmRsZUNsb3NlKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVSZWZsZWN0b3JJZE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQocmV0cnlXYWl0VGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCBoYW5kbGVPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlUmVmbGVjdG9ySWRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXYWxsZXQgQ29ubmVjdGlvbiBQaGFzZVxuICAgICAgICAvLyBoZXJlIHdlIHJldHVybiB0aGUgYXNzb2NpYXRpb24gVVJMIChjb250YWluaW5nIHRoZSByZWZsZWN0b3IgSUQpIHRvIHRoZSBjYWxsZXIgKyBcbiAgICAgICAgLy8gYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHRoZSBNb2JpbGVXYWxsZXQgb2JqZWN0IG9uY2UgdGhlIHdhbGxldCBjb25uZWN0cy5cbiAgICAgICAgbGV0IHNlc3Npb25Fc3RhYmxpc2hlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaGFuZGxlQ2xvc2U7XG4gICAgICAgIHJldHVybiB7IGFzc29jaWF0aW9uVXJsLCBjbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGhhbmRsZUNsb3NlKCk7XG4gICAgICAgICAgICB9LCB3YWxsZXQ6IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25ScGNSZXNwb25zZVByb21pc2VzID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlTWVzc2FnZSA9IChldnQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCdWZmZXIgPSB5aWVsZCBkZWNvZGVCeXRlcyhldnQpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLl9fdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVmbGVjdG9yX2lkX3JlY2VpdmVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VCdWZmZXIuYnl0ZUxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIHVuZXhwZWN0ZWQgbWVzc2FnZSB3aGlsZSBhd2FpdGluZyByZWZsZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjZGhLZXlwYWlyID0geWllbGQgZ2VuZXJhdGVFQ0RIS2V5cGFpcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmFyeU1zZyA9IHlpZWxkIGNyZWF0ZUhlbGxvUmVxKGVjZGhLZXlwYWlyLnB1YmxpY0tleSwgYXNzb2NpYXRpb25LZXlwYWlyLnByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChmcm9tVWludDhBcnJheSQxKGJpbmFyeU1zZykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoYmluYXJ5TXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdHlwZTogJ2hlbGxvX3JlcV9zZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb25QdWJsaWNLZXk6IGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjZGhQcml2YXRlS2V5OiBlY2RoS2V5cGFpci5wcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyVmVjdG9yID0gcmVzcG9uc2VCdWZmZXIuc2xpY2UoMCwgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSBnZXRTZXF1ZW5jZU51bWJlckZyb21CeXRlQXJyYXkoc2VxdWVuY2VOdW1iZXJWZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXIgIT09IChsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBoYXMgaW52YWxpZCBzZXF1ZW5jZSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QganNvblJwY01lc3NhZ2UgPSB5aWVsZCBkZWNyeXB0SnNvblJwY01lc3NhZ2UocmVzcG9uc2VCdWZmZXIsIHN0YXRlLnNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IGpzb25ScGNSZXNwb25zZVByb21pc2VzW2pzb25ScGNNZXNzYWdlLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb25ScGNSZXNwb25zZVByb21pc2VzW2pzb25ScGNNZXNzYWdlLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlc29sdmUoanNvblJwY01lc3NhZ2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0ganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbZS5qc29uUnBjTWVzc2FnZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tlLmpzb25ScGNNZXNzYWdlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoZWxsb19yZXFfc2VudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFyZWRTZWNyZXQgPSB5aWVsZCBwYXJzZUhlbGxvUnNwKHJlc3BvbnNlQnVmZmVyLCBzdGF0ZS5hc3NvY2lhdGlvblB1YmxpY0tleSwgc3RhdGUuZWNkaFByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyID0gcmVzcG9uc2VCdWZmZXIuc2xpY2UoRU5DT0RFRF9QVUJMSUNfS0VZX0xFTkdUSF9CWVRFUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblByb3BlcnRpZXMgPSBzZXNzaW9uUHJvcGVydGllc0J1ZmZlci5ieXRlTGVuZ3RoICE9PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geWllbGQgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyVmVjdG9yID0gc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIuc2xpY2UoMCwgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0gZ2V0U2VxdWVuY2VOdW1iZXJGcm9tQnl0ZUFycmF5KHNlcXVlbmNlTnVtYmVyVmVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXF1ZW5jZU51bWJlciAhPT0gKGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBoYXMgaW52YWxpZCBzZXF1ZW5jZSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciA9IHNlcXVlbmNlTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU2Vzc2lvblByb3BzKHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyLCBzaGFyZWRTZWNyZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkoKSA6IHsgcHJvdG9jb2xfdmVyc2lvbjogJ2xlZ2FjeScgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgX190eXBlOiAnY29ubmVjdGVkJywgc2hhcmVkU2VjcmV0LCBzZXNzaW9uUHJvcGVydGllcyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IGNyZWF0ZU1vYmlsZVdhbGxldFByb3h5KHNlc3Npb25Qcm9wZXJ0aWVzLnByb3RvY29sX3ZlcnNpb24sIChtZXRob2QsIHBhcmFtcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpZCA9IG5leHRKc29uUnBjTWVzc2FnZUlkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmFyeU1zZyA9IHlpZWxkIGVuY3J5cHRKc29uUnBjTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nID09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChmcm9tVWludDhBcnJheSQxKGJpbmFyeU1zZykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoYmluYXJ5TXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhdXRob3JpemUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVhdXRob3JpemUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRfdXJpX2Jhc2UgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2FsbGV0X3VyaV9iYXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFNlY3VyZUVuZHBvaW50U3BlY2lmaWNVUkkod2FsbGV0X3VyaV9iYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uRXN0YWJsaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUod2FsbGV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uRXN0YWJsaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfU0VTU0lPTl9DTE9TRUQsIGBUaGUgd2FsbGV0IHNlc3Npb24gd2FzIGNsb3NlZCBiZWZvcmUgY29ubmVjdGlvbi5gLCB7IGNsb3NlRXZlbnQ6IG5ldyBDbG9zZUV2ZW50KCdzb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgY29ubmVjdGlvbicpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSB9O1xuICAgIH0pO1xufVxuXG5leHBvcnQgeyBTb2xhbmFDbG9uZUF1dGhvcml6YXRpb24sIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvciwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZSwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3IsIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yQ29kZSwgU29sYW5hU2lnbkluV2l0aFNvbGFuYSwgU29sYW5hU2lnblRyYW5zYWN0aW9ucywgc3RhcnRSZW1vdGVTY2VuYXJpbywgdHJhbnNhY3QgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/wallet-standard-mobile/node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js\n");

/***/ })

};
;